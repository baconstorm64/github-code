--[ 2019.09.24.10.04.54.541.0 ]--
NewLogger: CR00_Hex
Version: 1.3
--[ 2019.09.24.10.04.54.560.0 ]--
InitTree:
/Subject0/src/algs4.jar
/Subject0/src/stdlib.jar
/Subject0/src/HexBoard.java
/Subject0/src/HexBoardStats.java
/Subject0/src/HexBoardVisualizer.java
/Subject0/src/InteractiveHexBoardVisualizer.java
/Subject0/.idea/copyright/profiles_settings.xml
/Subject0/.idea/libraries/src.xml
/Subject0/.idea/libraries/algs4.xml
/Subject0/.idea/libraries/stdlib.xml
/Subject0/.idea/.name
/Subject0/.idea/misc.xml
/Subject0/.idea/modules.xml
/Subject0/.idea/compiler.xml
/Subject0/.idea/workspace.xml
/Subject0/.idea/uiDesigner.xml
/Subject0/tests/.donotlog
/Subject0/tests/input-1-p1.txt
/Subject0/tests/input-1-p2.txt
/Subject0/tests/input-3-p1.txt
/Subject0/tests/input-3-p2.txt
/Subject0/tests/input-7-p2.txt
/Subject0/tests/input-11-p2.txt
/Subject0/tests/input-17-p1.txt
/Subject0/tests/input-random-5.txt
/Subject0/tests/input-random-13.txt
/Subject0/tests/input-random-49.txt
/Subject0/tests/input-random-99.txt
/Subject0/tests/input-random-199.txt
/Subject0/tests/input-1-nowinners.txt
/Subject0/tests/input-zigzag-5-p1.txt
/Subject0/tests/input-zigzag-5-p2.txt
/Subject0/tests/input-zigzag-13-p1.txt
/Subject0/tests/input-zigzag-17-p2.txt
/Subject0/tests/input-zigzag-31-p2.txt
/Subject0/.cos265
/Subject0/P01_Hex.iml
/Subject1/src/algs4.jar
/Subject1/src/stdlib.jar
/Subject1/src/HexBoard.java
/Subject1/src/HexBoardStats.java
/Subject1/src/HexBoardVisualizer.java
/Subject1/src/InteractiveHexBoardVisualizer.java
/Subject1/.idea/copyright/profiles_settings.xml
/Subject1/.idea/libraries/src.xml
/Subject1/.idea/libraries/algs4.xml
/Subject1/.idea/libraries/stdlib.xml
/Subject1/.idea/.name
/Subject1/.idea/misc.xml
/Subject1/.idea/modules.xml
/Subject1/.idea/compiler.xml
/Subject1/.idea/workspace.xml
/Subject1/.idea/uiDesigner.xml
/Subject1/tests/.donotlog
/Subject1/tests/input-1-p1.txt
/Subject1/tests/input-1-p2.txt
/Subject1/tests/input-3-p1.txt
/Subject1/tests/input-3-p2.txt
/Subject1/tests/input-7-p2.txt
/Subject1/tests/input-11-p2.txt
/Subject1/tests/input-17-p1.txt
/Subject1/tests/input-random-5.txt
/Subject1/tests/input-random-13.txt
/Subject1/tests/input-random-49.txt
/Subject1/tests/input-random-99.txt
/Subject1/tests/input-random-199.txt
/Subject1/tests/input-1-nowinners.txt
/Subject1/tests/input-zigzag-5-p1.txt
/Subject1/tests/input-zigzag-5-p2.txt
/Subject1/tests/input-zigzag-13-p1.txt
/Subject1/tests/input-zigzag-17-p2.txt
/Subject1/tests/input-zigzag-31-p2.txt
/Subject1/.cos265
/Subject1/P01_Hex.iml
/Subject2/src/algs4.jar
/Subject2/src/stdlib.jar
/Subject2/src/HexBoard.java
/Subject2/src/HexBoardStats.java
/Subject2/src/HexBoardVisualizer.java
/Subject2/src/InteractiveHexBoardVisualizer.java
/Subject2/.idea/copyright/profiles_settings.xml
/Subject2/.idea/libraries/src.xml
/Subject2/.idea/libraries/algs4.xml
/Subject2/.idea/libraries/stdlib.xml
/Subject2/.idea/.name
/Subject2/.idea/misc.xml
/Subject2/.idea/modules.xml
/Subject2/.idea/compiler.xml
/Subject2/.idea/workspace.xml
/Subject2/.idea/uiDesigner.xml
/Subject2/tests/.donotlog
/Subject2/tests/input-1-p1.txt
/Subject2/tests/input-1-p2.txt
/Subject2/tests/input-3-p1.txt
/Subject2/tests/input-3-p2.txt
/Subject2/tests/input-7-p2.txt
/Subject2/tests/input-11-p2.txt
/Subject2/tests/input-17-p1.txt
/Subject2/tests/input-random-5.txt
/Subject2/tests/input-random-13.txt
/Subject2/tests/input-random-49.txt
/Subject2/tests/input-random-99.txt
/Subject2/tests/input-random-199.txt
/Subject2/tests/input-1-nowinners.txt
/Subject2/tests/input-zigzag-5-p1.txt
/Subject2/tests/input-zigzag-5-p2.txt
/Subject2/tests/input-zigzag-13-p1.txt
/Subject2/tests/input-zigzag-17-p2.txt
/Subject2/tests/input-zigzag-31-p2.txt
/Subject2/.cos265
/Subject2/P01_Hex.iml
/readme.html

--[ 2019.09.24.10.04.54.560.1 ]--
InitFile: /Subject0/src/HexBoardStats.java
/****************************************************************************
 *  Command: HexBoardStats N0 N1 T
 *
 *  This program takes the board sizes N0,N1 and game count T as a command-line
 *  arguments. Then, the program runs T games for each board size N where
 *  N0 <= N <= N1 and where each play randomly chooses an unset tile to set in
 *  order to estimate the probability that player 1 will win.
 ****************************************************************************/

public class HexBoardStats {
    private int minBoardSize;
    private int maxBoardSize;
    private int numGames;

    public static void main(String[] args) {
        // default argument values
        int minBoardSize = 2;
        int maxBoardSize = 15;
        int numGames = 100000;
        int choiceOfStatisticsOutput = 0;
        // command-line argument values, if supplied
        if (args.length == 3 || args.length == 4) {
            minBoardSize = Integer.parseInt(args[0]);
            maxBoardSize = Integer.parseInt(args[1]);
            numGames = Integer.parseInt(args[2]);
            if (args.length == 4) {
                choiceOfStatisticsOutput = Integer.parseInt(args[3]);
            }
        }

        if (choiceOfStatisticsOutput == 0) {
            // run the tests for seeing the probabilities of player 1 winning
            Stopwatch stopwatch = new Stopwatch();
            HexBoardStats gameStatistics = new HexBoardStats(minBoardSize, maxBoardSize, numGames);
            // print out the statistics
            StdOut.println("T = " + numGames);
            double P1Odds;
            for (int boardSize=minBoardSize; boardSize<=maxBoardSize; boardSize++) {
                P1Odds = gameStatistics.getP1WinProbabilityEstimate(boardSize);
                StdOut.print("N = " + boardSize + ", ");
                StdOut.printf("P1 = %.4f (%d), ", P1Odds, (int)Math.round((numGames*P1Odds)));
                StdOut.printf("P2 = %.4f (%d)", (1.0-P1Odds), (int)Math.round((numGames*(1.0-P1Odds))));
                StdOut.println();
            }
            StdOut.println("\nExecution of " + numGames + " hex games for board sizes " + minBoardSize + " to " + maxBoardSize + " took " + stopwatch.elapsedTime() + " seconds");
        }

        else if (choiceOfStatisticsOutput == 1) {
            // run the tests for seeing runtimes for varying board sizes (numGames is constant)
            HexBoardStats gameStatistics = new HexBoardStats(minBoardSize, maxBoardSize, numGames);
            //int[] boardSizesArray = {1,10,20,40,80,160,320,640,1280,2560,5120,10240};
            int[] boardSizesArray = {1,10,20,40,80,160,320};
            for (int boardSize : boardSizesArray) {
                gameStatistics.getP1WinProbabilityEstimate(boardSize);
            }
        }
        else if (choiceOfStatisticsOutput == 2) {
            // run the tests for seeing runtimes for varying numGames (board size is constant)
            int[] numberOfGamesArray = {1,10,100,1000,10000,20000,40000,80000,160000,320000};
            for (int numberOfGames : numberOfGamesArray) {
                HexBoardStats gameStatistics = new HexBoardStats(minBoardSize, maxBoardSize, numberOfGames);
                gameStatistics.getP1WinProbabilityEstimate(minBoardSize);
            }
        }

    }

    // constructor
    public HexBoardStats(int N0, int N1, int T) {
        if (N0 <= 0 || N1 < N0 || T <= 0) {
            throw new java.lang.IllegalArgumentException("Invalid HexBoardStats arguments " + N0 + " " + N1 + " " + T);
        }
        minBoardSize = N0;
        maxBoardSize = N1;
        numGames = T;
    }

    public double getP1WinProbabilityEstimate(int N) {
        if (N < minBoardSize || N > maxBoardSize) {
            throw new java.lang.IndexOutOfBoundsException("Board size " + N + " is not between " + minBoardSize + " and " + maxBoardSize);
        }
        HexBoard board;
        int[][] tileLocations;
        double numWinsPlayer1 = 0.0;

        double UFImplementationRuntime = 0.0;
        int numTilesPlaced = 0;
        Stopwatch UFImplementationStopwatch;

        // iterate to complete the specified number of games for board size N
        for (int game=0; game<numGames; game++) {
            board = new HexBoard(N);
            tileLocations = new int[N*N][2];

            // set up tileLocations
            for (int r=0; r<N; r++) {
                for (int c=0; c<N; c++) {
                    tileLocations[r*N +c][0] = r;
                    tileLocations[r*N +c][1] = c;
                }
            }
            shuffleArray(tileLocations);

            int tileLocationIndex = 0;
            int player = 1;

            UFImplementationStopwatch = new Stopwatch();

            // play the game with random tile setting
            while (!(board.hasPlayer1Won() || board.hasPlayer2Won())) {
                board.setTile(tileLocations[tileLocationIndex][0], tileLocations[tileLocationIndex][1], player);
                if (player == 1) player = 2;
                else player = 1;
                tileLocationIndex++;
            }
            if (board.hasPlayer1Won()) {
                numWinsPlayer1 += 1.0;
            }
            UFImplementationRuntime += UFImplementationStopwatch.elapsedTime();
            numTilesPlaced += tileLocationIndex;
        }

        // after all the games done with a specific board size, return player1's win ratio

        /*
        double numTilesPlacedFloat = numTilesPlaced;
        StdOut.printf("Implementation of UF for board size %d over %d games. ", N, numGames);
        StdOut.printf("Time per tile placement: %.4f. ", (UFImplementationRuntime/numTilesPlacedFloat)*10000000);
        StdOut.printf("Overall running time: %.4f seconds\n", UFImplementationRuntime);
        */

        return numWinsPlayer1/numGames;
    }

    // helper function to randomly mix an array's contents
    private void shuffleArray(int[][] array) {
        int randomIndexA;
        int randomIndexB;
        int[] temp;
        for (int s=0; s<array.length; s++) {
            randomIndexA = StdRandom.uniform(0, array.length);
            randomIndexB = StdRandom.uniform(0, array.length);
            temp = array[randomIndexA];
            array[randomIndexA] = array[randomIndexB];
            array[randomIndexB] = temp;
        }
    }
}

--[ 2019.09.24.10.04.54.560.2 ]--
InitFile: /Subject2/.cos265


--[ 2019.09.24.10.04.54.560.3 ]--
InitFile: /Subject2/src/HexBoard.java
/****************************************************************************
 *  This class manages an N-by-N hex game board .
 ****************************************************************************/

public class HexBoard {

    //class variables
    int[][] board;
    int unset;
    int N;
    int i;
    QuickFindUF uf;
    int player1Left;
    int player1Right;
    int player2Left;
    int player2Right;
    Stack stack;



    /**
     * Constructor for class
     * @param N Board size
     */
    public HexBoard(int N) {

        board = new int[N][N];
        unset = N*N;
        uf = new QuickFindUF(N*N +4);
        this.N = N;
        player1Left = N*N;
        player1Right = N+N+2;
        player2Left = N*N+3;
        player2Right = N*N+1;
        stack =  new Stack();
    }

    public int getPlayer(int row, int col) {

        return board[row][col];
    }
    
    public boolean isSet(int row, int col) {
        if (board[row][col]==0) {
            return false;
        } else {
            return true;
        }
    }

    public boolean isOnWinningPath(int row, int col) {
        if (uf.connected(player1Left, CoordinatesToIndex(row, col)) && uf.connected(player1Right, CoordinatesToIndex(row, col))){
            return true;
        }
        if (uf.connected(player2Left, CoordinatesToIndex(row, col)) && uf.connected(player2Right, CoordinatesToIndex(row, col))){
            return true;
        }
        return false;
    }
    public int CoordinatesToIndex(int row, int col){
        return col+N*row;
    }

    public void setTile(int row, int col, int player) {
        board[row][col] = player;
        i = col + N *row;
        if(player==1 && col==0){
            uf.union(i, player1Left);
        }
        if(player==1 && col==N-1){
            uf.union(i, player1Right);
        }
        if(player==2 && row==0){
            uf.union(i, player2Left);
        }
        if(player==2 && row==N-1) {
            uf.union(i, player2Right);
        }
        notTile(row, col,row-1,col);
        notTile(row, col,row,col-1);
        notTile(row, col,row+1,col-1);
        notTile(row, col,row+1,col);
        notTile(row, col,row,col+1);
        notTile(row, col,row-1,col+1);
        unset = unset-1;
    }
    private void notTile(int row0, int col0, int row1, int col1){
        if(row1 == -1){ return;}
        if(col1 == N){ return;}
        if(col1 == -1){ return;}
        if(row1 == N) { return;}
        if(board[row0][col0] == board[row1][col1]){
                uf.union(col0 + N *row0, col1 +N * row1);
        }
    }

    public boolean hasPlayer1Won() {
        return uf.connected(player1Left,player1Right);
    }

    public boolean hasPlayer2Won() {
        return uf.connected(player2Left,player2Right);
    }

    public int numberOfUnsetTiles() {
        return unset;
    }
}

--[ 2019.09.24.10.04.54.561.0 ]--
InitFile: /Subject1/P01_Hex.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.09.24.10.04.54.561.1 ]--
InitFile: /Subject0/P01_Hex.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.09.24.10.04.54.561.2 ]--
InitFile: /Subject2/P01_Hex.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
      <excludeFolder url="file://$MODULE_DIR$/.log" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.09.24.10.04.54.561.3 ]--
InitFile: /Subject1/.cos265


--[ 2019.09.24.10.04.54.561.4 ]--
InitFile: /Subject2/src/HexBoardVisualizer.java
/****************************************************************************
 *  Command: HexBoardVisualizer input.txt
 *
 *  This program takes the name of a file as a command-line argument.
 *  From that file, it
 *
 *    - Reads the board size N of the Hex game board.
 *    - Creates an N-by-N grid of tiles (initially all unset)
 *    - Reads in a sequence of triplets (r, c, p) to set tile row r, col c by player p.
 *
 *  After each tile is set, it redraws the game board.
 *  Unset tiles are drawn in gray, tiles set by player 1 in red,
 *  tiles set by player 2 in blue, and tiles along game-winning path
 *  are drawn in lighter version of the player color.
 *  Tile (0, 0) is the leftmost corner tile.
 *
 ****************************************************************************/

import java.awt.*;

public class HexBoardVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // colors of board when unset or set by player 1 or player 2
    private final static Color cUnset      = new Color(192, 192, 192);
    private final static Color cPlayer1    = new Color(240,  32,  32);
    private final static Color cWinPath1   = new Color(255, 144, 128);
    private final static Color cEdge1      = new Color(160,  80,  80);
    private final static Color cPlayer2    = new Color( 32,  32, 240);
    private final static Color cWinPath2   = new Color(128, 144, 255);
    private final static Color cEdge2      = new Color( 80,  80, 160);
    private final static Color cBackground = new Color( 96,  96,  96);
    private final static Color cStatusBG   = new Color(255, 255, 255, 128);

    private static void drawHexXY(double cx, double cy, Color color, double r) {
        double px[] = { cx + 1.00*r, cx + 0.50*r, cx - 0.50*r, cx - 1.00*r, cx - 0.50*r, cx + 0.50*r };
        double py[] = { cy + 0.00*r, cy - 0.87*r, cy - 0.87*r, cy + 0.00*r, cy + 0.87*r, cy + 0.87*r };
        StdDraw.setPenColor(color);
        StdDraw.filledPolygon(px, py);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.polygon(px, py);
    }

    private static void drawHexRowCol(int row, int col, Color color) {
        double cx = row * 1.50 + col * 1.50;
        double cy = row * 0.87 - col * 0.87;
        drawHexXY(cx, cy, color, 1.0);
    }

    private static void setScale(int N) {
        StdDraw.setXscale(-1.0, (N-1)*3.0+1);
        StdDraw.setYscale(-N * 1.5, N * 1.5);
    }

    public static void drawStatus(int player, HexBoard board, int N) {
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setXscale(0, 200);
        StdDraw.setYscale(0, 200);

        // draw background of status
        StdDraw.setPenColor(cStatusBG);
        StdDraw.filledRectangle(0,0,64,36);

        // report number of unset tiles
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.textLeft(5, 12, board.numberOfUnsetTiles() + " unset tiles");

        if(board.hasPlayer1Won()) {
            StdDraw.textLeft(5, 24, "Player 1 has won!");
        } else if(board.hasPlayer2Won()) {
            StdDraw.textLeft(5, 24, "Player 2 has won!");
        } else if(player == 1 || player == 2){
            double hx = 29.0; //2.25*N;
            double hy = 24.0;

            HexBoardVisualizer.drawHexXY(hx, hy, player == 1 ? cPlayer1 : cPlayer2, 6.0);
            StdDraw.setPenColor(StdDraw.WHITE); //(player == 1 ? StdDraw.WHITE : StdDraw.BLACK);
            StdDraw.text(hx, hy, "" + player);
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.textLeft(5, hy, "Player");
        } else {
            // a special player status for playback
            StdDraw.textLeft(5, 24, "No winner detected...");
        }

        setScale(N);
    }

    // draw N-by-N hex board
    public static void drawBoard(HexBoard board, int N) {
        StdDraw.clear();
        StdDraw.clear(cBackground);
        setScale(N);

        int won = board.hasPlayer1Won() ? 1 : (board.hasPlayer2Won() ? 2 : 0);

        for(int row = 0; row < N; row++) {
            for(int col = 0; col < N; col++) {
                Color color;
                if(!board.isSet(row, col)) {
                    color = cUnset;
                } else if(won != 0 && board.isOnWinningPath(row, col)) {
                    if(won == 1) {
                        color = cWinPath1;
                    } else {
                        color = cWinPath2;
                    }
                } else if(board.getPlayer(row, col) == 1) {
                    color = cPlayer1;
                } else {
                    color = cPlayer2;
                }
                drawHexRowCol(row, col, color);
            }
        }

        // draw player 1 sides of board
        for(int row = 0; row < N-1; row++) {
            drawHexRowCol(row + 1, -1, cEdge1);
            drawHexRowCol(row, N, cEdge1);
        }

        // draw player 2 sides of board
        for(int col = 0; col < N-1; col++) {
            drawHexRowCol(-1, col + 1, cEdge2);
            drawHexRowCol(N, col, cEdge2);
        }
    }

    public static void drawBoardAndStatus(int player, HexBoard board, int N) {
        drawBoard(board, N);
        drawStatus(player, board, N);
    }

    private static void simulateFromFile(String filename) {
        In in = new In(filename);
        int N = in.readInt();
        HexBoard board = new HexBoard(N);

        // turn on animation mode
        StdDraw.show(0); 

        // repeatedly read in tiles to open and drawBoard resulting system
        drawBoardAndStatus(0, board, N);
        StdDraw.show(DELAY);
        while (!in.isEmpty()) {
            int i = in.readInt();
            int j = in.readInt();
            int p = in.readInt();
            board.setTile(i, j, p);
            drawBoardAndStatus(0, board, N);
            StdDraw.show(DELAY);
            if(board.hasPlayer1Won() || board.hasPlayer2Won()) break;
        }
    }

    public static void main(String[] args) {
        String filename = args[0];
        simulateFromFile(filename);
    }
}

--[ 2019.09.24.10.04.54.562.0 ]--
InitFile: /Subject0/src/HexBoard.java
/****************************************************************************
 *  This class manages an N-by-N hex game board .
 ****************************************************************************/

public class HexBoard {
    private int[][] board;
    private WeightedQuickUnionUF UF;
    //private QuickFindUF UF;
    private WeightedQuickUnionUF physicalConnectionsUF;
    private int UFIndexOfLastTileSet;
    private int unsetTiles;
    private int[] virtualNodes_playerOne = new int[2];
    private int[] virtualNodes_playerTwo = new int[2];

    // constructor
    public HexBoard(int N) {
        if (N<=0) {
            throw new java.lang.IllegalArgumentException("Board size must be greater than zero");
        }

        // initialize the logical board
        board = new int[N][N];
        for (int r=0; r<board.length; r++) {
            for (int c=0; c<board[r].length; c++) {
                board[r][c] = 0;
            }
        }
        unsetTiles = N*N;
        // initialize the logical UnionFind data structure
        UF = new WeightedQuickUnionUF(N*N+4);
        //UF = new QuickFindUF(N*N+4);
        physicalConnectionsUF = new WeightedQuickUnionUF(N*N);
        UFIndexOfLastTileSet = -1;

        virtualNodes_playerOne[0] = N*N;
        virtualNodes_playerOne[1] = N*N+1;
        virtualNodes_playerTwo[0] = N*N+2;
        virtualNodes_playerTwo[1] = N*N+3;
    }

    // return player at tile
    public int getPlayer(int row, int col) {
        validateRowCol(row, col);
        return board[row][col];
    }

    // is tile set?
    public boolean isSet(int row, int col) {
        validateRowCol(row, col);
        return board[row][col] != 0;
    }

    // is tile on winning path?
    public boolean isOnWinningPath(int row, int col) {
        validateRowCol(row, col);
        int winner = -1;
        if (hasPlayer1Won()) {winner = 1;}
        else if (hasPlayer2Won()) {winner = 2;}
        if (getPlayer(row, col) == winner) {
            int currentTile = getUFRepresentation(row,col);
            return physicalConnectionsUF.connected(currentTile, UFIndexOfLastTileSet);
        }
        return false;
    }

    // mark a tile according to which player
    public void setTile(int row, int col, int player) {
        validateRowCol(row, col);
        if (isSet(row,col)) {
            throw new java.lang.IllegalArgumentException("Tile at " + row + ", " + col + " is already set");
        }
        board[row][col] = player;
        unsetTiles--;

        // keep track of connections within UF data structure
        linkTouchingTiles(row, col, player);

        // check if a connection should be made to a virtual node on the edge of the board
        int UFIndex = getUFRepresentation(row, col);
        UFIndexOfLastTileSet = UFIndex;
        if (player == 1) {
            if (col == 0) {UF.union(UFIndex, virtualNodes_playerOne[0]);}
            if (col == board.length-1) {UF.union(UFIndex, virtualNodes_playerOne[1]);}
        }
        else if (player == 2) {
            if (row == 0) {UF.union(UFIndex, virtualNodes_playerTwo[0]);}
            if (row == board.length-1) {UF.union(UFIndex, virtualNodes_playerTwo[1]);}
        }
        else {
            throw new java.lang.IllegalArgumentException("Player " + player + " is invalid. Valid players are 1 and 2");
        }
    }

    // has player1 connected their opposing sides?
    public boolean hasPlayer1Won() {
        return UF.connected(virtualNodes_playerOne[0], virtualNodes_playerOne[1]);
    }

    // has player2 connected their opposing sides?
    public boolean hasPlayer2Won() {
        return UF.connected(virtualNodes_playerTwo[0], virtualNodes_playerTwo[1]);
    }

    // return the number of free, untouched tiles
    public int numberOfUnsetTiles() {
        return unsetTiles;
    }

    // helper function to validate a tile coordinate
    private void validateRowCol(int row, int col) {
        if (row<0 || row>=board.length || col<0 || col>=board[row].length) {
            throw new java.lang.IndexOutOfBoundsException("Invalid row and column arguments " + row + ", " + col);
        }
    }

    // helper function to convert from tile coordinate to UnionFind parent array index
    private int getUFRepresentation(int row, int col) {
        return (board.length * row) + col;
    }

    // helper function to search around a tile that has just been placed and to make any available connections
    private void linkTouchingTiles(int row, int col, int player) {
        int[][] touchingTilesDeltaArray = {{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0}};
        for (int[] deltaArray: touchingTilesDeltaArray) {
            int rowToCheck = row+deltaArray[0];
            int colToCheck = col+deltaArray[1];
            if (!(rowToCheck<0 || rowToCheck>=board.length || colToCheck<0 || colToCheck>=board[rowToCheck].length)) {
                if (getPlayer(rowToCheck, colToCheck) == player) {
                    int p = getUFRepresentation(row,col);
                    int q = getUFRepresentation(rowToCheck,colToCheck);
                    UF.union(p,q);
                    physicalConnectionsUF.union(p,q);
                }
            }
        }
    }
}

--[ 2019.09.24.10.04.54.562.1 ]--
InitFile: /Subject0/.cos265


--[ 2019.09.24.10.04.54.562.2 ]--
InitFile: /Subject2/src/HexBoardStats.java
/****************************************************************************
 *  Command: HexBoardStats N0 N1 T
 *
 *  This program takes the board sizes N0,N1 and game count T as a command-line
 *  arguments. Then, the program runs T games for each board size N where
 *  N0 <= N <= N1 and where each play randomly chooses an unset tile to set in
 *  order to estimate the probability that player 1 will win.
 ****************************************************************************/

public class HexBoardStats {
    int T;
    int N0;
    int N1;

    public static void main(String[] args) {
        HexBoardStats HexBoard = new HexBoardStats(2, 15, 100);
    }
    public HexBoardStats(int N0, int N1, int T){
        this.T = T;
        this. N0 = N0;
        this. N1 = N1;
        for (int N = N0; N <= N1; N++){
           double numberEstimated= getP1WinProbabilityEstimate(N);
           StdOut.println(N);
           StdOut.println(numberEstimated);
        }

    }

    public double getP1WinProbabilityEstimate(int N){
        int playerCount=0;
        for(int i = 0; i < T; i++){
            if (playGame(N))
                playerCount++;
        }
        return (playerCount/T);
    }
    private boolean playGame(int N){
        HexBoard board = new HexBoard(N);
        int player = 1;
        /*while(!true ){
            StdRandom.uniform(0.0, (double)N);
        }*/

        return true;
    }
}

--[ 2019.09.24.10.04.54.562.3 ]--
InitFile: /Subject1/src/HexBoardVisualizer.java
/****************************************************************************
 *  Command: HexBoardVisualizer input.txt
 *
 *  This program takes the name of a file as a command-line argument.
 *  From that file, it
 *
 *    - Reads the board size N of the Hex game board.
 *    - Creates an N-by-N grid of tiles (initially all unset)
 *    - Reads in a sequence of triplets (r, c, p) to set tile row r, col c by player p.
 *
 *  After each tile is set, it redraws the game board.
 *  Unset tiles are drawn in gray, tiles set by player 1 in red,
 *  tiles set by player 2 in blue, and tiles along game-winning path
 *  are drawn in lighter version of the player color.
 *  Tile (0, 0) is the leftmost corner tile.
 *
 ****************************************************************************/

import java.awt.*;

public class HexBoardVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // colors of board when unset or set by player 1 or player 2
    private final static Color cUnset      = new Color(192, 192, 192);
    private final static Color cPlayer1    = new Color(240,  32,  32);
    private final static Color cWinPath1   = new Color(255, 144, 128);
    private final static Color cEdge1      = new Color(160,  80,  80);
    private final static Color cPlayer2    = new Color( 32,  32, 240);
    private final static Color cWinPath2   = new Color(128, 144, 255);
    private final static Color cEdge2      = new Color( 80,  80, 160);
    private final static Color cBackground = new Color( 96,  96,  96);
    private final static Color cStatusBG   = new Color(255, 255, 255, 128);

    private static void drawHexXY(double cx, double cy, Color color, double r) {
        double px[] = { cx + 1.00*r, cx + 0.50*r, cx - 0.50*r, cx - 1.00*r, cx - 0.50*r, cx + 0.50*r };
        double py[] = { cy + 0.00*r, cy - 0.87*r, cy - 0.87*r, cy + 0.00*r, cy + 0.87*r, cy + 0.87*r };
        StdDraw.setPenColor(color);
        StdDraw.filledPolygon(px, py);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.polygon(px, py);
    }

    private static void drawHexRowCol(int row, int col, Color color) {
        double cx = row * 1.50 + col * 1.50;
        double cy = row * 0.87 - col * 0.87;
        drawHexXY(cx, cy, color, 1.0);
    }

    private static void setScale(int N) {
        StdDraw.setXscale(-1.0, (N-1)*3.0+1);
        StdDraw.setYscale(-N * 1.5, N * 1.5);
    }

    public static void drawStatus(int player, HexBoard board, int N) {
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setXscale(0, 200);
        StdDraw.setYscale(0, 200);

        // draw background of status
        StdDraw.setPenColor(cStatusBG);
        StdDraw.filledRectangle(0,0,64,36);

        // report number of unset tiles
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.textLeft(5, 12, board.numberOfUnsetTiles() + " unset tiles");

        if(board.hasPlayer1Won()) {
            StdDraw.textLeft(5, 24, "Player 1 has won!");
        } else if(board.hasPlayer2Won()) {
            StdDraw.textLeft(5, 24, "Player 2 has won!");
        } else if(player == 1 || player == 2){
            double hx = 29.0; //2.25*N;
            double hy = 24.0;

            HexBoardVisualizer.drawHexXY(hx, hy, player == 1 ? cPlayer1 : cPlayer2, 6.0);
            StdDraw.setPenColor(StdDraw.WHITE); //(player == 1 ? StdDraw.WHITE : StdDraw.BLACK);
            StdDraw.text(hx, hy, "" + player);
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.textLeft(5, hy, "Player");
        } else {
            // a special player status for playback
            StdDraw.textLeft(5, 24, "No winner detected...");
        }

        setScale(N);
    }

    // draw N-by-N hex board
    public static void drawBoard(HexBoard board, int N) {
        StdDraw.clear();
        StdDraw.clear(cBackground);
        setScale(N);

        int won = board.hasPlayer1Won() ? 1 : (board.hasPlayer2Won() ? 2 : 0);

        for(int row = 0; row < N; row++) {
            for(int col = 0; col < N; col++) {
                Color color;
                if(!board.isSet(row, col)) {
                    color = cUnset;
                } else if(won != 0 && board.isOnWinningPath(row, col)) {
                    if(won == 1) {
                        color = cWinPath1;
                    } else {
                        color = cWinPath2;
                    }
                } else if(board.getPlayer(row, col) == 1) {
                    color = cPlayer1;
                } else {
                    color = cPlayer2;
                }
                drawHexRowCol(row, col, color);
            }
        }

        // draw player 1 sides of board
        for(int row = 0; row < N-1; row++) {
            drawHexRowCol(row + 1, -1, cEdge1);
            drawHexRowCol(row, N, cEdge1);
        }

        // draw player 2 sides of board
        for(int col = 0; col < N-1; col++) {
            drawHexRowCol(-1, col + 1, cEdge2);
            drawHexRowCol(N, col, cEdge2);
        }
    }

    public static void drawBoardAndStatus(int player, HexBoard board, int N) {
        drawBoard(board, N);
        drawStatus(player, board, N);
    }

    private static void simulateFromFile(String filename) {
        In in = new In(filename);
        int N = in.readInt();
        HexBoard board = new HexBoard(N);

        // turn on animation mode
        StdDraw.show(0); 

        // repeatedly read in tiles to open and drawBoard resulting system
        drawBoardAndStatus(0, board, N);
        StdDraw.show(DELAY);
        while (!in.isEmpty()) {
            int i = in.readInt();
            int j = in.readInt();
            int p = in.readInt();
            board.setTile(i, j, p);
            drawBoardAndStatus(0, board, N);
            StdDraw.show(DELAY);
            if(board.hasPlayer1Won() || board.hasPlayer2Won()) break;
        }
    }

    public static void main(String[] args) {
        String filename = args[0];
        simulateFromFile(filename);
    }
}

--[ 2019.09.24.10.04.54.562.4 ]--
InitFile: /Subject1/src/HexBoard.java
/****************************************************************************
 *  This class manages an N-by-N hex game board .
 ****************************************************************************/

public class HexBoard {
    private int[][] boardArray;

    private WeightedQuickUnionUF player1NodeMap; // Left/Right
    private WeightedQuickUnionUF player2NodeMap; // Top/Bottom
    private WeightedQuickUnionUF player1NodeMapNoVirtual; // Left/Right
    private WeightedQuickUnionUF player2NodeMapNoVirtual; // Top/Bottom

    private int size;
    private int area;
    private int pieces;
    private int leftVNode, rightVNode, topVNode, bottomVNode;

    private int lastMove;
    private boolean gameIsWon;


    public HexBoard(int N) {
        if (N <= 0) throw new IllegalArgumentException();
        boardArray = new int[N][N];
        size = N;
        area = N*N;
        pieces = 0;

        lastMove = -1;
        gameIsWon = false;

        player1NodeMapNoVirtual = new WeightedQuickUnionUF(area);
        player2NodeMapNoVirtual = new WeightedQuickUnionUF(area);

        player1NodeMap = new WeightedQuickUnionUF(area+2); // Last two are virtual nodes (Left, Right)
        player2NodeMap = new WeightedQuickUnionUF(area+2); // Last four are virtual nodes (Top, Bottom)
        leftVNode = area;           // Player 1
        rightVNode = area + 1;      // Player 1
        topVNode = area;            // Player 2
        bottomVNode = area + 1;     // Player 2

        for (int i = 0; i < size; i++) { // Connect Virtual Nodes
            player1NodeMap.union(leftVNode, flatten(i, 0));
            player1NodeMap.union(rightVNode, flatten(i, size-1));
            player2NodeMap.union(bottomVNode, flatten(0, i));
            player2NodeMap.union(topVNode, flatten(size-1, i));
        }
    }

    public int getPlayer(int row, int col) {
        if (!checkIsInBounds(row, col)) throw new IndexOutOfBoundsException();

        return boardArray[row][col];
    }

    public boolean isSet(int row, int col) {
        return getPlayer(row, col) != 0;
    }

    public boolean isOnWinningPath(int row, int col) {
        if (!checkIsInBounds(row, col)) throw new IndexOutOfBoundsException();

        if (!gameIsWon)
            return false;

        return player1NodeMapNoVirtual.connected(lastMove, flatten(row, col)) || player2NodeMapNoVirtual.connected(lastMove, flatten(row, col));
    }

    public void setTile(int row, int col, int player) {
        if (!checkIsInBounds(row, col)) throw new IndexOutOfBoundsException();

        if(boardArray[row][col] == 0) {
            pieces++;
            lastMove = flatten(row, col);
        } else
            throw new IllegalArgumentException();
        boardArray[row][col] = player;

        // Iterate through surrounding cells
        for (int r = row - 1; r <= row + 1; r++) {
            for (int c = col - 1; c <= col + 1; c++) {
                if (checkIsInBounds(r,c)) {
                    if (r == row && c == col)
                        continue; // Skip the center cell
                    if (r == row - 1 && c == col - 1)
                        continue; // Skip the bottom left cell (not adjacent)
                    if (r == row + 1 && c == col + 1)
                        continue; // Skip the top right cell (not adjacent)

                    if (boardArray[r][c] == player) {
                        if (player == 1) {
                            player1NodeMap.union(flatten(r, c), flatten(row, col)); // Join to adjacent cells inhabited by this player
                            player1NodeMapNoVirtual.union(flatten(r, c), flatten(row, col)); // Join in nodemap for checking winning path
                        } else {
                            player2NodeMap.union(flatten(r, c), flatten(row, col)); // Join to adjacent cells inhabited by this player
                            player2NodeMapNoVirtual.union(flatten(r, c), flatten(row, col)); // Join in nodemap for checking winning path
                        }
                    }
                }
            }
        }
    }

    public boolean hasPlayer1Won() {
        if (gameIsWon)
            return true;
        if (player1NodeMap.connected(leftVNode, rightVNode))
            gameIsWon = true;
        return gameIsWon;
    }

    public boolean hasPlayer2Won() {
        if (gameIsWon)
            return true;
        if (player2NodeMap.connected(topVNode, bottomVNode))
            gameIsWon = true;
        return gameIsWon;
    }

    public int numberOfUnsetTiles() {
        return size*size - pieces;
    }

    private boolean checkIsInBounds(int row, int col) { // Returns true if in bounds
        return !(row < 0 || row >= size || col < 0 || col >= size);
    }

    private int flatten(int row, int col){ // Returns the index of the spot given the rox, col
        return row * size + col;
    }

    private int[] expand(int i){ // Returns [row, col] of spot given index
        int col = i % size;
        int row = i / size;
        return new int[] {row, col};
    }
}

--[ 2019.09.24.10.04.54.563.0 ]--
InitFile: /Subject0/src/HexBoardVisualizer.java
/****************************************************************************
 *  Command: HexBoardVisualizer input.txt
 *
 *  This program takes the name of a file as a command-line argument.
 *  From that file, it
 *
 *    - Reads the board size N of the Hex game board.
 *    - Creates an N-by-N grid of tiles (initially all unset)
 *    - Reads in a sequence of triplets (r, c, p) to set tile row r, col c by player p.
 *
 *  After each tile is set, it redraws the game board.
 *  Unset tiles are drawn in gray, tiles set by player 1 in red,
 *  tiles set by player 2 in blue, and tiles along game-winning path
 *  are drawn in lighter version of the player color.
 *  Tile (0, 0) is the leftmost corner tile.
 *
 ****************************************************************************/

import java.awt.*;

public class HexBoardVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 100;

    // colors of board when unset or set by player 1 or player 2
    private final static Color cUnset      = new Color(192, 192, 192);
    private final static Color cPlayer1    = new Color(240,  32,  32);
    private final static Color cWinPath1   = new Color(255, 144, 128);
    private final static Color cEdge1      = new Color(160,  80,  80);
    private final static Color cPlayer2    = new Color( 32,  32, 240);
    private final static Color cWinPath2   = new Color(128, 144, 255);
    private final static Color cEdge2      = new Color( 80,  80, 160);
    private final static Color cBackground = new Color( 96,  96,  96);
    private final static Color cStatusBG   = new Color(255, 255, 255, 128);

    private static void drawHexXY(double cx, double cy, Color color, double r) {
        double px[] = { cx + 1.00*r, cx + 0.50*r, cx - 0.50*r, cx - 1.00*r, cx - 0.50*r, cx + 0.50*r };
        double py[] = { cy + 0.00*r, cy - 0.87*r, cy - 0.87*r, cy + 0.00*r, cy + 0.87*r, cy + 0.87*r };
        StdDraw.setPenColor(color);
        StdDraw.filledPolygon(px, py);
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.polygon(px, py);
    }

    private static void drawHexRowCol(int row, int col, Color color) {
        double cx = row * 1.50 + col * 1.50;
        double cy = row * 0.87 - col * 0.87;
        drawHexXY(cx, cy, color, 1.0);
    }

    private static void setScale(int N) {
        StdDraw.setXscale(-1.0, (N-1)*3.0+1);
        StdDraw.setYscale(-N * 1.5, N * 1.5);
    }

    public static void drawStatus(int player, HexBoard board, int N) {
        StdDraw.setFont(new Font("SansSerif", Font.PLAIN, 12));
        StdDraw.setXscale(0, 200);
        StdDraw.setYscale(0, 200);

        // draw background of status
        StdDraw.setPenColor(cStatusBG);
        StdDraw.filledRectangle(0,0,64,36);

        // report number of unset tiles
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.textLeft(5, 12, board.numberOfUnsetTiles() + " unset tiles");

        if(board.hasPlayer1Won()) {
            StdDraw.textLeft(5, 24, "Player 1 has won!");
        } else if(board.hasPlayer2Won()) {
            StdDraw.textLeft(5, 24, "Player 2 has won!");
        } else if(player == 1 || player == 2){
            double hx = 29.0; //2.25*N;
            double hy = 24.0;

            HexBoardVisualizer.drawHexXY(hx, hy, player == 1 ? cPlayer1 : cPlayer2, 6.0);
            StdDraw.setPenColor(StdDraw.WHITE); //(player == 1 ? StdDraw.WHITE : StdDraw.BLACK);
            StdDraw.text(hx, hy, "" + player);
            StdDraw.setPenColor(StdDraw.BLACK);
            StdDraw.textLeft(5, hy, "Player");
        } else {
            // a special player status for playback
            StdDraw.textLeft(5, 24, "No winner detected...");
        }

        setScale(N);
    }

    // draw N-by-N hex board
    public static void drawBoard(HexBoard board, int N) {
        StdDraw.clear();
        StdDraw.clear(cBackground);
        setScale(N);

        int won = board.hasPlayer1Won() ? 1 : (board.hasPlayer2Won() ? 2 : 0);

        for(int row = 0; row < N; row++) {
            for(int col = 0; col < N; col++) {
                Color color;
                if(!board.isSet(row, col)) {
                    color = cUnset;
                } else if(won != 0 && board.isOnWinningPath(row, col)) {
                    if(won == 1) {
                        color = cWinPath1;
                    } else {
                        color = cWinPath2;
                    }
                } else if(board.getPlayer(row, col) == 1) {
                    color = cPlayer1;
                } else {
                    color = cPlayer2;
                }
                drawHexRowCol(row, col, color);
            }
        }

        // draw player 1 sides of board
        for(int row = 0; row < N-1; row++) {
            drawHexRowCol(row + 1, -1, cEdge1);
            drawHexRowCol(row, N, cEdge1);
        }

        // draw player 2 sides of board
        for(int col = 0; col < N-1; col++) {
            drawHexRowCol(-1, col + 1, cEdge2);
            drawHexRowCol(N, col, cEdge2);
        }
    }

    public static void drawBoardAndStatus(int player, HexBoard board, int N) {
        drawBoard(board, N);
        drawStatus(player, board, N);
    }

    private static void simulateFromFile(String filename) {
        In in = new In(filename);
        int N = in.readInt();
        HexBoard board = new HexBoard(N);

        // turn on animation mode
        StdDraw.show(0); 

        // repeatedly read in tiles to open and drawBoard resulting system
        drawBoardAndStatus(0, board, N);
        StdDraw.show(DELAY);
        while (!in.isEmpty()) {
            int i = in.readInt();
            int j = in.readInt();
            int p = in.readInt();
            board.setTile(i, j, p);
            drawBoardAndStatus(0, board, N);
            StdDraw.show(DELAY);
            if(board.hasPlayer1Won() || board.hasPlayer2Won()) break;
        }
    }

    public static void main(String[] args) {
        String filename = args[0];
        simulateFromFile(filename);
    }
}

--[ 2019.09.24.10.04.54.563.1 ]--
InitFile: /Subject1/src/HexBoardStats.java
import javafx.scene.paint.Stop;

import java.util.Timer;

/****************************************************************************
 *  Command: HexBoardStats N0 N1 T
 *
 *  This program takes the board sizes N0,N1 and game count T as a command-line
 *  arguments. Then, the program runs T games for each board size N where
 *  N0 <= N <= N1 and where each play randomly chooses an unset tile to set in
 *  order to estimate the probability that player 1 will win.
 ****************************************************************************/

public class HexBoardStats {
    private int low, high, tests;

    public static void main(String[] args) {
//        HexBoardStats stats = new HexBoardStats(Integer.parseInt(args[0]), Integer.parseInt(args[1]), Integer.parseInt(args[2]));
        Stopwatch global = new Stopwatch();
        int T = 1000;
        int N = 10;

        StdOut.println("T    |    N    | time");
        for (; N <= 100; N+=10) {
            HexBoardStats stats = new HexBoardStats(1,1000000,T);
            Stopwatch local = new Stopwatch();
            double prob = stats.getP1WinProbabilityEstimate(N);
            //StdOut.printf("N = %d, P1 = %1.2f, P2 = %1.2f\n", N, prob, 1-prob);
            StdOut.printf("%d | %d | %.3f\n" , T, N, local.elapsedTime());
        }
        StdOut.println(global.elapsedTime());
    }

    public HexBoardStats(int N0, int N1, int T) {
        if (N0 <= 0 || N1 < N0 || T <= 0) throw new IllegalArgumentException();

        low = N0;
        high = N1;
        tests = T;
    }

    public double getP1WinProbabilityEstimate(int N) {
        if (N < low || N > high) throw new IndexOutOfBoundsException();

        int player1Victories = 0;

        for (int test = 0; test < tests; test++) {
            if (playGame(N)) {
                player1Victories++;
            }
        }

        return (double)player1Victories/tests;
    }

    private boolean playGame(int N) { // Returns true if player 1 won
       HexBoard board = new HexBoard(N);

       int currentPlayer = 1;

       do {
           int move = getNewMove(board, N);
           board.setTile(move/N, move%N, currentPlayer);
           currentPlayer = currentPlayer == 1 ? 2 : 1; // Switch Player

       } while (!board.hasPlayer1Won() && !board.hasPlayer2Won());
       return board.hasPlayer1Won();
    }

    private int getNewMove(HexBoard board, int N) {
       int move = -1;
       while (move == -1 || board.isSet(move/N, move%N)){
           move = (int)(StdRandom.random()*N*N);
       }
       return move;
    }
}

--[ 2019.09.24.10.04.54.563.2 ]--
InitFile: /Subject0/src/InteractiveHexBoardVisualizer.java
/****************************************************************************
 *  Command: InteractiveHexBoardVisualizer N
 *
 *  This program takes the board size N as a command-line argument.
 *  Then, the user repeatedly clicks tiles to set with the mouse.
 *  After each tile is set, it redraws the game board (see comments in
 *  HexBoardVisualizer.java file for details).
 *
 ****************************************************************************/

public class InteractiveHexBoardVisualizer {
    private final static int DELAY = 20;

    public static void main(String[] args) {
        // N-by-N hex board game (read from command-line, default = 5)
        int N = 5;
        if (args.length == 1) N = Integer.parseInt(args[0]);

        int player = 1;

        // turn on animation mode
        StdDraw.show(0);

        StdOut.println(N);

        HexBoard board = new HexBoard(N);

        HexBoardVisualizer.drawBoardAndStatus(player, board, N);
        StdDraw.show(DELAY);

        while (true) {

            // detected mouse click
            if(StdDraw.mousePressed() && !board.hasPlayer1Won() && !board.hasPlayer2Won()) {

                // screen coordinates
                double x = StdDraw.mouseX();
                double y = StdDraw.mouseY();

                // find row,col of click
                double r = (x + 1.73 * y) / 3.00;
                double c = x / 1.5 - r;
                int i = (int)Math.round(r);
                int j = (int)Math.round(c);

                // make sure player clicks close enough to center of tile
                if(Math.abs(r - i) < 0.4 && Math.abs(c - j) < 0.4) {
                    // is tile a valid position on board?
                    if (i >= 0 && i < N && j >= 0 && j < N) {
                        // is board tile already set?
                        if (!board.isSet(i, j)) {
                            StdOut.println(i + " " + j + " " + player);
                            // set board tile
                            board.setTile(i, j, player);

                            // switch player
                            player = (player==1) ? 2 : 1;

                            // redraw board
                            HexBoardVisualizer.drawBoardAndStatus(player, board, N);
                        }
                    }
                }
            }

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.09.24.10.04.54.563.3 ]--
InitFile: /Subject2/src/InteractiveHexBoardVisualizer.java
/****************************************************************************
 *  Command: InteractiveHexBoardVisualizer N
 *
 *  This program takes the board size N as a command-line argument.
 *  Then, the user repeatedly clicks tiles to set with the mouse.
 *  After each tile is set, it redraws the game board (see comments in
 *  HexBoardVisualizer.java file for details).
 *
 ****************************************************************************/

public class InteractiveHexBoardVisualizer {
    private final static int DELAY = 20;

    public static void main(String[] args) {
        // N-by-N hex board game (read from command-line, default = 5)
        int N = 5;
        if (args.length == 1) N = Integer.parseInt(args[0]);

        int player = 1;

        // turn on animation mode
        StdDraw.show(0);

        StdOut.println(N);

        HexBoard board = new HexBoard(N);

        HexBoardVisualizer.drawBoardAndStatus(player, board, N);
        StdDraw.show(DELAY);

        while (true) {

            // detected mouse click
            if(StdDraw.mousePressed() && !board.hasPlayer1Won() && !board.hasPlayer2Won()) {

                // screen coordinates
                double x = StdDraw.mouseX();
                double y = StdDraw.mouseY();

                // find row,col of click
                double r = (x + 1.73 * y) / 3.00;
                double c = x / 1.5 - r;
                int i = (int)Math.round(r);
                int j = (int)Math.round(c);

                // make sure player clicks close enough to center of tile
                if(Math.abs(r - i) < 0.4 && Math.abs(c - j) < 0.4) {
                    // is tile a valid position on board?
                    if (i >= 0 && i < N && j >= 0 && j < N) {
                        // is board tile already set?
                        if (!board.isSet(i, j)) {
                            StdOut.println(i + " " + j + " " + player);
                            // set board tile
                            board.setTile(i, j, player);

                            // switch player
                            player = (player==1) ? 2 : 1;

                            // redraw board
                            HexBoardVisualizer.drawBoardAndStatus(player, board, N);
                        }
                    }
                }
            }

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.09.24.10.04.54.563.4 ]--
InitFile: /Subject1/src/InteractiveHexBoardVisualizer.java
/****************************************************************************
 *  Command: InteractiveHexBoardVisualizer N
 *
 *  This program takes the board size N as a command-line argument.
 *  Then, the user repeatedly clicks tiles to set with the mouse.
 *  After each tile is set, it redraws the game board (see comments in
 *  HexBoardVisualizer.java file for details).
 *
 ****************************************************************************/

public class InteractiveHexBoardVisualizer {
    private final static int DELAY = 20;

    public static void main(String[] args) {
        // N-by-N hex board game (read from command-line, default = 5)
        int N = 5;
        if (args.length == 1) N = Integer.parseInt(args[0]);

        int player = 1;

        // turn on animation mode
        StdDraw.show(0);

        StdOut.println(N);

        HexBoard board = new HexBoard(N);

        HexBoardVisualizer.drawBoardAndStatus(player, board, N);
        StdDraw.show(DELAY);

        while (true) {

            // detected mouse click
            if(StdDraw.mousePressed() && !board.hasPlayer1Won() && !board.hasPlayer2Won()) {

                // screen coordinates
                double x = StdDraw.mouseX();
                double y = StdDraw.mouseY();

                // find row,col of click
                double r = (x + 1.73 * y) / 3.00;
                double c = x / 1.5 - r;
                int i = (int)Math.round(r);
                int j = (int)Math.round(c);

                // make sure player clicks close enough to center of tile
                if(Math.abs(r - i) < 0.4 && Math.abs(c - j) < 0.4) {
                    // is tile a valid position on board?
                    if (i >= 0 && i < N && j >= 0 && j < N) {
                        // is board tile already set?
                        if (!board.isSet(i, j)) {
                            StdOut.println(i + " " + j + " " + player);
                            // set board tile
                            board.setTile(i, j, player);

                            // switch player
                            player = (player==1) ? 2 : 1;

                            // redraw board
                            HexBoardVisualizer.drawBoardAndStatus(player, board, N);
                        }
                    }
                }
            }

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.09.24.10.04.55.117.0 ]--
UpdateTree (AD): 1 0
+ /.log/history.log

--[ 2019.09.24.10.05.29.765.0 ]--
UpdateTree (AD): 1 0
+ /.idea/CR00_Hex.iml

--[ 2019.09.24.10.05.30.470.0 ]--
UpdateTree (AD): 1 0
+ /.idea/workspace.xml

--[ 2019.09.24.10.05.30.559.0 ]--
UpdateTree (AD): 1 0
+ /.idea/modules.xml

--[ 2019.09.24.10.08.26.849.0 ]--
UpdateTree (AD): 1 0
+ /.idea/misc.xml

--[ 2019.09.24.10.57.28.178.0 ]--
DisposeComponent
