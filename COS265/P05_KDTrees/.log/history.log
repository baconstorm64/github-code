--[ 2019.11.12.09.57.45.732.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.12.09.57.45.754.0 ]--
InitTree:
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.12.09.57.45.757.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.12.09.57.45.759.0 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    // constructor makes empty collection
    public PSBruteForce() { }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return 0; }

    // return whether the KDTree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.12.09.57.45.766.0 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.12.09.57.45.769.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSKDTree<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.12.09.57.45.772.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.12.09.57.45.775.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.12.09.57.45.779.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.12.09.57.45.781.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.12.09.57.45.783.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.12.09.57.45.787.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.12.09.57.45.790.0 ]--
InitFile: /.cos265


--[ 2019.11.12.09.57.45.792.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.12.09.57.45.795.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.12.10.18.01.353.0 ]--
UpdateTree (AD): 23 0
+ /out/production/P05_KDTrees/.donotlog
+ /out/production/P05_KDTrees/algs4.jar
+ /out/production/P05_KDTrees/stdlib.jar
+ /out/production/P05_KDTrees/Mouse.class
+ /out/production/P05_KDTrees/Point.class
+ /out/production/P05_KDTrees/input1M.txt
+ /out/production/P05_KDTrees/Point$1.class
+ /out/production/P05_KDTrees/Point$2.class
+ /out/production/P05_KDTrees/Point$3.class
+ /out/production/P05_KDTrees/Point$4.class
+ /out/production/P05_KDTrees/input100K.txt
+ /out/production/P05_KDTrees/KeyPress.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/burgerking.csv
+ /out/production/P05_KDTrees/Partition.class
+ /out/production/P05_KDTrees/PointDist.class
+ /out/production/P05_KDTrees/Visualizer.class
+ /out/production/P05_KDTrees/PointSearch.class
+ /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class
+ /out/production/P05_KDTrees/FastFoodVisualizer.class
+ /out/production/P05_KDTrees/Partition$Direction.class
+ /out/production/P05_KDTrees/NearestNeighborVisualizer.class

--[ 2019.11.12.10.18.01.372.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.18.08.823.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.18.15.785.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.21.06.820.0 ]--
:/src/PSBruteForce.java
+ 9     public PSBruteForce() { 
r 10     }
--[ 2019.11.12.10.21.06.886.0 ]--
+ 10         
--[ 2019.11.12.10.21.18.080.0 ]--
+ 8     
--[ 2019.11.12.10.21.28.051.0 ]--
r 8     r
--[ 2019.11.12.10.21.28.293.0 ]--
r 8     rb
--[ 2019.11.12.10.21.28.831.0 ]--
r 8     r
--[ 2019.11.12.10.21.29.667.0 ]--
r 8     
--[ 2019.11.12.10.21.34.682.0 ]--
r 10     public PSBruteForce() {
r 11 
--[ 2019.11.12.10.21.40.472.0 ]--
r 8     P
--[ 2019.11.12.10.21.40.655.0 ]--
r 8     Po
--[ 2019.11.12.10.21.40.841.0 ]--
r 8     Poi
--[ 2019.11.12.10.21.40.917.0 ]--
r 8     Poin
--[ 2019.11.12.10.21.41.035.0 ]--
r 8     Point
--[ 2019.11.12.10.21.41.430.0 ]--
r 8     PointS
--[ 2019.11.12.10.21.42.380.0 ]--
r 8     PointS 
--[ 2019.11.12.10.21.42.426.0 ]--
r 8     PointS
--[ 2019.11.12.10.21.42.592.0 ]--
r 8     
--[ 2019.11.12.10.21.43.537.0 ]--
r 8     p
--[ 2019.11.12.10.21.44.239.0 ]--
r 8     
--[ 2019.11.12.10.21.44.379.0 ]--
r 8     P
--[ 2019.11.12.10.21.44.565.0 ]--
r 8     Po
--[ 2019.11.12.10.21.44.737.0 ]--
r 8     Poi
--[ 2019.11.12.10.21.44.810.0 ]--
r 8     Poin
--[ 2019.11.12.10.21.44.916.0 ]--
r 8     Point
--[ 2019.11.12.10.21.45.974.0 ]--
r 8     Point 
--[ 2019.11.12.10.21.48.408.0 ]--
r 8     
--[ 2019.11.12.10.21.49.079.0 ]--
r 8     V
--[ 2019.11.12.10.21.49.341.0 ]--
r 8     Vl
--[ 2019.11.12.10.21.49.617.0 ]--
r 8     V
--[ 2019.11.12.10.21.49.737.0 ]--
r 8     Va
--[ 2019.11.12.10.21.49.819.0 ]--
r 8     Val
--[ 2019.11.12.10.21.49.973.0 ]--
r 8     Valu
--[ 2019.11.12.10.21.50.128.0 ]--
r 8     Value
--[ 2019.11.12.10.21.50.301.0 ]--
r 8     Value 
--[ 2019.11.12.10.21.56.672.0 ]--
r 8     Value r
--[ 2019.11.12.10.21.56.879.0 ]--
r 8     Value rb
--[ 2019.11.12.10.21.57.103.0 ]--
r 8     Value rbT
--[ 2019.11.12.10.21.57.334.0 ]--
r 8     Value rbTr
--[ 2019.11.12.10.21.57.754.0 ]--
r 8     Value rbTre
--[ 2019.11.12.10.21.57.864.0 ]--
r 8     Value rbTree
--[ 2019.11.12.10.21.58.137.0 ]--
r 8     Value rbTree 
--[ 2019.11.12.10.21.58.311.0 ]--
r 8     Value rbTree =
--[ 2019.11.12.10.21.58.414.0 ]--
r 8     Value rbTree = 
--[ 2019.11.12.10.21.59.128.0 ]--
r 8     Value rbTree = n
--[ 2019.11.12.10.21.59.224.0 ]--
r 8     Value rbTree = ne
--[ 2019.11.12.10.21.59.396.0 ]--
r 8     Value rbTree = new
--[ 2019.11.12.10.21.59.622.0 ]--
r 8     Value rbTree = new 
--[ 2019.11.12.10.22.00.471.0 ]--
r 8     Value rbTree = new r
--[ 2019.11.12.10.22.00.557.0 ]--
r 8     Value rbTree = new re
--[ 2019.11.12.10.22.01.058.0 ]--
r 8     Value rbTree = new r
--[ 2019.11.12.10.22.01.166.0 ]--
r 8     Value rbTree = new 
--[ 2019.11.12.10.22.01.395.0 ]--
r 8     Value rbTree = new R
--[ 2019.11.12.10.22.01.653.0 ]--
r 8     Value rbTree = new Re
--[ 2019.11.12.10.22.01.817.0 ]--
r 8     Value rbTree = new Red
--[ 2019.11.12.10.22.02.382.0 ]--
r 8     Value rbTree = new RedB
--[ 2019.11.12.10.22.03.381.0 ]--
r 8     Value rbTree = new RedBlackBST
--[ 2019.11.12.10.22.03.406.0 ]--
r 8     Value rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.05.015.0 ]--
r 8     Value rbTree = new RedBlackBST<V>()
--[ 2019.11.12.10.22.05.249.0 ]--
r 8     Value rbTree = new RedBlackBST<Va>()
--[ 2019.11.12.10.22.05.770.0 ]--
r 8     Value rbTree = new RedBlackBST<Val>()
--[ 2019.11.12.10.22.06.113.0 ]--
r 8     Value rbTree = new RedBlackBST<Vale>()
--[ 2019.11.12.10.22.06.440.0 ]--
r 8     Value rbTree = new RedBlackBST<Val>()
--[ 2019.11.12.10.22.06.739.0 ]--
r 8     Value rbTree = new RedBlackBST<Valu>()
--[ 2019.11.12.10.22.06.780.0 ]--
r 8     Value rbTree = new RedBlackBST<Value>()
--[ 2019.11.12.10.22.07.002.0 ]--
r 8     Value rbTree = new RedBlackBST<Value >()
--[ 2019.11.12.10.22.07.100.0 ]--
r 8     Value rbTree = new RedBlackBST<Value>()
--[ 2019.11.12.10.22.07.229.0 ]--
r 8     Value rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.09.991.0 ]--
r 8     R rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.10.105.0 ]--
r 8     Re rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.10.260.0 ]--
r 8     Reb rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.11.116.0 ]--
r 8     RebB rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.11.303.0 ]--
r 8     Reb rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.11.400.0 ]--
r 8     Re rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.11.490.0 ]--
r 8     Red rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.11.673.0 ]--
r 8     RedB rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.12.084.0 ]--
r 8     RedBlackBST rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.12.821.0 ]--
r 8     RedBlackBST> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.13.380.0 ]--
r 8     RedBlackBST rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.13.560.0 ]--
r 8     RedBlackBST> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.13.581.0 ]--
r 8     RedBlackBST>< rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.070.0 ]--
r 8     RedBlackBST> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.182.0 ]--
r 8     RedBlackBST rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.643.0 ]--
r 8     RedBlackBST<> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.742.0 ]--
r 8     RedBlackBST<v> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.767.0 ]--
r 8     RedBlackBST<va> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.822.0 ]--
r 8     RedBlackBST<val> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.14.976.0 ]--
r 8     RedBlackBST<valu> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.15.077.0 ]--
r 8     RedBlackBST<value> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.17.403.0 ]--
r 8     RedBlackBST<alue> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.17.414.0 ]--
r 8     RedBlackBST<=alue> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.17.532.0 ]--
r 8     RedBlackBST<=Value> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.18.212.0 ]--
r 8     RedBlackBST<=alue> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.18.732.0 ]--
r 8     RedBlackBST<alue> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.18.980.0 ]--
r 8     RedBlackBST<Value> rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.22.23.455.0 ]--
r 8     RedBlackBST<Value> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.42.733.0 ]--
r 8     RedBlackBST<> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.45.031.0 ]--
r 8     RedBlackBST<P> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.45.194.0 ]--
r 8     RedBlackBST<Po> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.45.382.0 ]--
r 8     RedBlackBST<Poi> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.45.426.0 ]--
r 8     RedBlackBST<Poin> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.45.484.0 ]--
r 8     RedBlackBST<Point> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.45.626.0 ]--
r 8     RedBlackBST<Point.,> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.46.022.0 ]--
r 8     RedBlackBST<Point.> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.46.093.0 ]--
r 8     RedBlackBST<Point> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.46.774.0 ]--
r 8     RedBlackBST<Point.> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.46.854.0 ]--
r 8     RedBlackBST<Point. > rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.46.997.0 ]--
r 8     RedBlackBST<Point. V> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.135.0 ]--
r 8     RedBlackBST<Point. Va> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.277.0 ]--
r 8     RedBlackBST<Point. Val> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.495.0 ]--
r 8     RedBlackBST<Point. Va> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.597.0 ]--
r 8     RedBlackBST<Point. V> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.701.0 ]--
r 8     RedBlackBST<Point. > rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.831.0 ]--
r 8     RedBlackBST<Point.> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.47.979.0 ]--
r 8     RedBlackBST<Point> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.165.0 ]--
r 8     RedBlackBST<Point,> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.264.0 ]--
r 8     RedBlackBST<Point, > rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.511.0 ]--
r 8     RedBlackBST<Point, V> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.601.0 ]--
r 8     RedBlackBST<Point, Va> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.623.0 ]--
r 8     RedBlackBST<Point, Val> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.769.0 ]--
r 8     RedBlackBST<Point, Valu> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.48.856.0 ]--
r 8     RedBlackBST<Point, Value> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.50.639.0 ]--
r 8     RedBlackBST<Point, Value>  rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.50.710.0 ]--
r 8     RedBlackBST<Point, Value> rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.22.53.561.0 ]--
- 11
--[ 2019.11.12.10.22.53.768.0 ]--
+ 11         
--[ 2019.11.12.10.22.58.876.0 ]--
r 8     RedBlackBST<Point, Value> rbTree
--[ 2019.11.12.10.23.00.857.0 ]--
- 11
--[ 2019.11.12.10.23.01.430.0 ]--
+ 11         
--[ 2019.11.12.10.23.03.822.0 ]--
r 8     RedBlackBST<Point, Value> rbTree;
--[ 2019.11.12.10.23.07.910.0 ]--
r 11         r
--[ 2019.11.12.10.23.08.073.0 ]--
r 11         rb
--[ 2019.11.12.10.23.08.345.0 ]--
r 11         rbT
--[ 2019.11.12.10.23.08.511.0 ]--
r 11         rbTr
--[ 2019.11.12.10.23.08.631.0 ]--
r 11         rbTre
--[ 2019.11.12.10.23.08.751.0 ]--
r 11         rbTree
--[ 2019.11.12.10.23.08.853.0 ]--
r 11         rbTree 
--[ 2019.11.12.10.23.08.918.0 ]--
r 11         rbTree =
--[ 2019.11.12.10.23.09.025.0 ]--
r 11         rbTree = 
--[ 2019.11.12.10.23.09.093.0 ]--
r 11         rbTree = n
--[ 2019.11.12.10.23.09.487.0 ]--
r 11         rbTree = ne
--[ 2019.11.12.10.23.09.618.0 ]--
r 11         rbTree = new
--[ 2019.11.12.10.23.09.862.0 ]--
r 11         rbTree = new 
--[ 2019.11.12.10.23.11.287.0 ]--
r 11         rbTree = new R
--[ 2019.11.12.10.23.11.450.0 ]--
r 11         rbTree = new Re
--[ 2019.11.12.10.23.11.639.0 ]--
r 11         rbTree = new Reb
--[ 2019.11.12.10.23.12.264.0 ]--
r 11         rbTree = new Re
--[ 2019.11.12.10.23.12.328.0 ]--
r 11         rbTree = new Red
--[ 2019.11.12.10.23.13.052.0 ]--
r 11         rbTree = new Re
--[ 2019.11.12.10.23.13.242.0 ]--
r 11         rbTree = new Red
--[ 2019.11.12.10.23.13.817.0 ]--
r 11         rbTree = new RedBlackBST
--[ 2019.11.12.10.23.13.825.0 ]--
r 11         rbTree = new RedBlackBST<>
--[ 2019.11.12.10.23.13.832.0 ]--
r 11         rbTree = new RedBlackBST<>()
--[ 2019.11.12.10.23.18.708.0 ]--
r 11         rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.23.22.664.0 ]--
r 11         rbTree = new RedBlackBST<>(); 
--[ 2019.11.12.10.23.22.693.0 ]--
r 11         rbTree = new RedBlackBST<>();
--[ 2019.11.12.10.23.22.909.0 ]--
+ 12         
--[ 2019.11.12.10.23.29.728.0 ]--
- 12
--[ 2019.11.12.10.23.48.163.0 ]--
+ 16         
--[ 2019.11.12.10.23.48.989.0 ]--
r 16         r
--[ 2019.11.12.10.23.49.184.0 ]--
r 16         rb
--[ 2019.11.12.10.23.49.394.0 ]--
r 16         rbT
--[ 2019.11.12.10.23.49.551.0 ]--
r 16         rbTr
--[ 2019.11.12.10.23.49.674.0 ]--
r 16         rbTre
--[ 2019.11.12.10.23.49.776.0 ]--
r 16         rbTree
--[ 2019.11.12.10.23.49.979.0 ]--
r 16         rbTree.
--[ 2019.11.12.10.23.50.255.0 ]--
r 16         rbTree. 
--[ 2019.11.12.10.23.50.309.0 ]--
r 16         rbTree.
--[ 2019.11.12.10.23.50.645.0 ]--
r 16         rbTree.p
--[ 2019.11.12.10.23.53.898.0 ]--
r 16         rbTree.put
--[ 2019.11.12.10.23.53.905.0 ]--
r 16         rbTree.put()
--[ 2019.11.12.10.23.53.910.0 ]--
r 16         rbTree.put();
--[ 2019.11.12.10.23.54.262.0 ]--
r 16         rbTree.put(p);
--[ 2019.11.12.10.23.54.453.0 ]--
r 16         rbTree.put(p.);
--[ 2019.11.12.10.23.54.532.0 ]--
r 16         rbTree.put(p. );
--[ 2019.11.12.10.23.54.774.0 ]--
r 16         rbTree.put(p. v);
--[ 2019.11.12.10.23.55.238.0 ]--
r 16         rbTree.put(p. );
--[ 2019.11.12.10.23.55.333.0 ]--
r 16         rbTree.put(p.);
--[ 2019.11.12.10.23.55.445.0 ]--
r 16         rbTree.put(p);
--[ 2019.11.12.10.23.55.637.0 ]--
r 16         rbTree.put(p,);
--[ 2019.11.12.10.23.56.154.0 ]--
r 16         rbTree.put(p, );
--[ 2019.11.12.10.23.56.402.0 ]--
r 16         rbTree.put(p, v);
--[ 2019.11.12.10.24.00.487.0 ]--
r 16         rbTree.put(p, v); 
--[ 2019.11.12.10.24.00.517.0 ]--
r 16         rbTree.put(p, v);
--[ 2019.11.12.10.24.18.866.0 ]--
+ 63         
--[ 2019.11.12.10.24.20.759.0 ]--
r 63         r
--[ 2019.11.12.10.24.20.827.0 ]--
r 63         re
--[ 2019.11.12.10.24.21.551.0 ]--
r 63         red
--[ 2019.11.12.10.24.22.041.0 ]--
r 63         red 
--[ 2019.11.12.10.24.22.103.0 ]--
r 63         red
--[ 2019.11.12.10.24.22.221.0 ]--
r 63         re
--[ 2019.11.12.10.24.22.359.0 ]--
r 63         r
--[ 2019.11.12.10.24.22.461.0 ]--
r 63         
--[ 2019.11.12.10.24.22.947.0 ]--
r 63         r
--[ 2019.11.12.10.24.22.988.0 ]--
r 63         re
--[ 2019.11.12.10.24.23.129.0 ]--
r 63         red
--[ 2019.11.12.10.24.23.439.0 ]--
r 63         redB
--[ 2019.11.12.10.24.23.869.0 ]--
r 63         red
--[ 2019.11.12.10.24.23.988.0 ]--
r 63         re
--[ 2019.11.12.10.24.24.105.0 ]--
r 63         r
--[ 2019.11.12.10.24.24.309.0 ]--
r 63         
--[ 2019.11.12.10.24.24.678.0 ]--
r 63         r
--[ 2019.11.12.10.24.24.879.0 ]--
r 63         rb
--[ 2019.11.12.10.24.25.277.0 ]--
r 63         rbT
--[ 2019.11.12.10.24.25.678.0 ]--
r 63         
--[ 2019.11.12.10.24.34.768.0 ]--
- 63
--[ 2019.11.12.10.24.38.933.0 ]--
r 62     public static void main(String[] args) { 
--[ 2019.11.12.10.24.40.149.0 ]--
r 62     public static void main(String[] args) {
--[ 2019.11.12.10.24.40.367.0 ]--
+ 63         
--[ 2019.11.12.10.24.43.894.0 ]--
r 63         P
--[ 2019.11.12.10.24.43.970.0 ]--
r 63         PS
--[ 2019.11.12.10.24.44.129.0 ]--
r 63         PSB
--[ 2019.11.12.10.24.44.664.0 ]--
r 63         PSBruteForce
--[ 2019.11.12.10.24.45.275.0 ]--
r 63         PSBruteForce<>
--[ 2019.11.12.10.24.46.554.0 ]--
r 63         PSBruteForce<V>
--[ 2019.11.12.10.24.46.696.0 ]--
r 63         PSBruteForce<Va>
--[ 2019.11.12.10.24.46.784.0 ]--
r 63         PSBruteForce<Val>
--[ 2019.11.12.10.24.46.938.0 ]--
r 63         PSBruteForce<Valu>
--[ 2019.11.12.10.24.47.023.0 ]--
r 63         PSBruteForce<Value>
--[ 2019.11.12.10.24.49.117.0 ]--
r 63         PSBruteForce<Value> 
--[ 2019.11.12.10.24.53.846.0 ]--
r 63         PSBruteForce<Value> b
--[ 2019.11.12.10.24.54.081.0 ]--
r 63         PSBruteForce<Value> bt
--[ 2019.11.12.10.24.54.191.0 ]--
r 63         PSBruteForce<Value> btu
--[ 2019.11.12.10.24.54.289.0 ]--
r 63         PSBruteForce<Value> btur
--[ 2019.11.12.10.24.54.318.0 ]--
r 63         PSBruteForce<Value> bture
--[ 2019.11.12.10.24.54.770.0 ]--
r 63         PSBruteForce<Value> btur
--[ 2019.11.12.10.24.54.857.0 ]--
r 63         PSBruteForce<Value> btu
--[ 2019.11.12.10.24.54.956.0 ]--
r 63         PSBruteForce<Value> bt
--[ 2019.11.12.10.24.55.077.0 ]--
r 63         PSBruteForce<Value> b
--[ 2019.11.12.10.24.55.578.0 ]--
r 63         PSBruteForce<Value> br
--[ 2019.11.12.10.24.55.673.0 ]--
r 63         PSBruteForce<Value> bru
--[ 2019.11.12.10.24.55.793.0 ]--
r 63         PSBruteForce<Value> brut
--[ 2019.11.12.10.24.55.866.0 ]--
r 63         PSBruteForce<Value> brute
--[ 2019.11.12.10.24.56.159.0 ]--
r 63         PSBruteForce<Value> bruteF
--[ 2019.11.12.10.24.56.256.0 ]--
r 63         PSBruteForce<Value> bruteFo
--[ 2019.11.12.10.24.56.329.0 ]--
r 63         PSBruteForce<Value> bruteFor
--[ 2019.11.12.10.24.56.494.0 ]--
r 63         PSBruteForce<Value> bruteForc
--[ 2019.11.12.10.24.56.534.0 ]--
r 63         PSBruteForce<Value> bruteForce
--[ 2019.11.12.10.24.56.688.0 ]--
r 63         PSBruteForce<Value> bruteForce 
--[ 2019.11.12.10.24.57.198.0 ]--
r 63         PSBruteForce<Value> bruteForce =
--[ 2019.11.12.10.24.57.554.0 ]--
r 63         PSBruteForce<Value> bruteForce = 
--[ 2019.11.12.10.25.00.375.0 ]--
r 63         PSBruteForce<Value> bruteForce = ne
--[ 2019.11.12.10.25.00.513.0 ]--
r 63         PSBruteForce<Value> bruteForce = new
--[ 2019.11.12.10.25.00.605.0 ]--
r 63         PSBruteForce<Value> bruteForce = new 
--[ 2019.11.12.10.25.00.810.0 ]--
r 63         PSBruteForce<Value> bruteForce = new P
--[ 2019.11.12.10.25.00.886.0 ]--
r 63         PSBruteForce<Value> bruteForce = new PS
--[ 2019.11.12.10.25.01.130.0 ]--
r 63         PSBruteForce<Value> bruteForce = new PSB
--[ 2019.11.12.10.25.01.704.0 ]--
r 63         PSBruteForce<Value> bruteForce = new PSBruteForce
--[ 2019.11.12.10.25.01.712.0 ]--
r 63         PSBruteForce<Value> bruteForce = new PSBruteForce<>
--[ 2019.11.12.10.25.01.718.0 ]--
r 63         PSBruteForce<Value> bruteForce = new PSBruteForce<>()
--[ 2019.11.12.10.25.02.862.0 ]--
r 63         PSBruteForce<Value> bruteForce = new PSBruteForce<>();
--[ 2019.11.12.10.25.07.102.0 ]--
r 63         
--[ 2019.11.12.10.25.07.311.0 ]--
- 63
--[ 2019.11.12.10.25.42.875.0 ]--
:/src/NearestNeighborVisualizer.java
r 18         return new P<>();
--[ 2019.11.12.10.25.42.981.0 ]--
r 18         return new PS<>();
--[ 2019.11.12.10.25.43.649.0 ]--
r 18         return new PSBruteForce<>();
--[ 2019.11.12.10.25.43.654.0 ]--
r 18         return new PSBruteForce();
--[ 2019.11.12.10.25.43.662.0 ]--
r 18         return new PSBruteForce<>();
--[ 2019.11.12.10.25.50.413.0 ]--
:/src/FastFoodVisualizer.java
r 63         PointSearch<String[]> psBurgerKings = new P<>();
--[ 2019.11.12.10.25.50.485.0 ]--
r 63         PointSearch<String[]> psBurgerKings = new PS<>();
--[ 2019.11.12.10.25.50.737.0 ]--
r 63         PointSearch<String[]> psBurgerKings = new PSB<>();
--[ 2019.11.12.10.25.51.299.0 ]--
r 63         PointSearch<String[]> psBurgerKings = new PSBruteForce<>();
--[ 2019.11.12.10.25.51.307.0 ]--
r 63         PointSearch<String[]> psBurgerKings = new PSBruteForce();
--[ 2019.11.12.10.25.51.325.0 ]--
r 63         PointSearch<String[]> psBurgerKings = new PSBruteForce<>();
--[ 2019.11.12.10.28.21.275.0 ]--
:/src/PSBruteForce.java
r 56     public int size() { return ; }
--[ 2019.11.12.10.28.22.199.0 ]--
r 56     public int size() { return r; }
--[ 2019.11.12.10.28.22.434.0 ]--
r 56     public int size() { return rb; }
--[ 2019.11.12.10.28.22.845.0 ]--
r 56     public int size() { return rbTree; }
--[ 2019.11.12.10.28.23.020.0 ]--
r 56     public int size() { return rbTree/.; }
--[ 2019.11.12.10.28.23.491.0 ]--
r 56     public int size() { return rbTree/; }
--[ 2019.11.12.10.28.23.555.0 ]--
r 56     public int size() { return rbTree; }
--[ 2019.11.12.10.28.23.692.0 ]--
r 56     public int size() { return rbTree.; }
--[ 2019.11.12.10.28.23.817.0 ]--
r 56     public int size() { return rbTree.s; }
--[ 2019.11.12.10.28.24.401.0 ]--
r 56     public int size() { return rbTree.size; }
--[ 2019.11.12.10.28.24.406.0 ]--
r 56     public int size() { return rbTree.size(); }
--[ 2019.11.12.10.28.25.485.0 ]--
r 56     public int size() { return rbTree.size() ; }
--[ 2019.11.12.10.28.25.550.0 ]--
r 56     public int size() { return rbTree.size(); }
--[ 2019.11.12.10.28.28.877.0 ]--
r 59     public boolean isEmpty() { return i; }
--[ 2019.11.12.10.28.28.968.0 ]--
r 59     public boolean isEmpty() { return if; }
--[ 2019.11.12.10.28.29.014.0 ]--
r 59     public boolean isEmpty() { return if ; }
--[ 2019.11.12.10.28.29.506.0 ]--
r 59     public boolean isEmpty() { return if r; }
--[ 2019.11.12.10.28.29.639.0 ]--
r 59     public boolean isEmpty() { return if rb; }
--[ 2019.11.12.10.28.30.135.0 ]--
r 59     public boolean isEmpty() { return if r; }
--[ 2019.11.12.10.28.30.385.0 ]--
r 59     public boolean isEmpty() { return if ; }
--[ 2019.11.12.10.28.30.738.0 ]--
r 59     public boolean isEmpty() { return ; }
--[ 2019.11.12.10.28.34.077.0 ]--
r 59     public boolean isEmpty() { return 0; }
--[ 2019.11.12.10.28.38.296.0 ]--
r 59     public boolean isEmpty() { return ; }
--[ 2019.11.12.10.28.38.400.0 ]--
r 59     public boolean isEmpty() { return t; }
--[ 2019.11.12.10.28.38.551.0 ]--
r 59     public boolean isEmpty() { return tr; }
--[ 2019.11.12.10.28.38.657.0 ]--
r 59     public boolean isEmpty() { return tru; }
--[ 2019.11.12.10.28.38.723.0 ]--
r 59     public boolean isEmpty() { return true; }
--[ 2019.11.12.10.28.42.232.0 ]--
+ 59     public boolean isEmpty() { 
r 60         return true; }
--[ 2019.11.12.10.28.44.168.0 ]--
+ 60         return true; 
r 61     }
--[ 2019.11.12.10.28.45.631.0 ]--
+ 60         
--[ 2019.11.12.10.28.56.173.0 ]--
r 60         i
--[ 2019.11.12.10.28.56.322.0 ]--
r 60         if
--[ 2019.11.12.10.28.56.758.0 ]--
r 60         if()
--[ 2019.11.12.10.28.59.020.0 ]--
r 60         if( )
--[ 2019.11.12.10.28.59.086.0 ]--
r 60         if()
--[ 2019.11.12.10.28.59.203.0 ]--
r 60         if(s)
--[ 2019.11.12.10.28.59.327.0 ]--
r 60         if(si)
--[ 2019.11.12.10.28.59.533.0 ]--
r 60         if(s)
--[ 2019.11.12.10.29.00.067.0 ]--
r 60         if(sz)
--[ 2019.11.12.10.29.00.243.0 ]--
r 60         if(sze)
--[ 2019.11.12.10.29.00.565.0 ]--
r 60         if(sz)
--[ 2019.11.12.10.29.00.659.0 ]--
r 60         if(s)
--[ 2019.11.12.10.29.01.506.0 ]--
r 60         if(si)
--[ 2019.11.12.10.29.01.573.0 ]--
r 60         if(siz)
--[ 2019.11.12.10.29.01.795.0 ]--
r 60         if(size)
--[ 2019.11.12.10.29.02.007.0 ]--
r 60         if(size())
--[ 2019.11.12.10.29.02.200.0 ]--
r 60         if(size() )
--[ 2019.11.12.10.29.02.860.0 ]--
r 60         if(size() =)
--[ 2019.11.12.10.29.02.978.0 ]--
r 60         if(size() ==)
--[ 2019.11.12.10.29.03.108.0 ]--
r 60         if(size() == )
--[ 2019.11.12.10.29.03.781.0 ]--
r 60         if(size() == 0)
--[ 2019.11.12.10.29.05.485.0 ]--
r 60         if(size() == 0){
--[ 2019.11.12.10.29.05.658.0 ]--
+ 61 
+ 62 }
--[ 2019.11.12.10.29.05.666.0 ]--
r 62         }
--[ 2019.11.12.10.29.05.684.0 ]--
r 61             
--[ 2019.11.12.10.29.06.724.0 ]--
r 62         return true; 
r 63         }
--[ 2019.11.12.10.29.06.734.0 ]--
r 61 
r 62             return true;
--[ 2019.11.12.10.29.07.348.0 ]--
r 61             return true;
r 62 
--[ 2019.11.12.10.29.08.658.0 ]--
+ 64         
--[ 2019.11.12.10.29.08.980.0 ]--
r 64         e
--[ 2019.11.12.10.29.09.087.0 ]--
r 64         el
--[ 2019.11.12.10.29.09.140.0 ]--
r 64         els
--[ 2019.11.12.10.29.09.262.0 ]--
r 64         else
--[ 2019.11.12.10.29.09.417.0 ]--
r 64         else{
--[ 2019.11.12.10.29.10.026.0 ]--
+ 65 
+ 66 }
--[ 2019.11.12.10.29.10.049.0 ]--
r 66         }
--[ 2019.11.12.10.29.10.074.0 ]--
r 65             
--[ 2019.11.12.10.29.10.436.0 ]--
r 65             r
--[ 2019.11.12.10.29.10.459.0 ]--
r 65             re
--[ 2019.11.12.10.29.10.640.0 ]--
r 65             ret
--[ 2019.11.12.10.29.10.726.0 ]--
r 65             retu
--[ 2019.11.12.10.29.10.823.0 ]--
r 65             retur
--[ 2019.11.12.10.29.10.867.0 ]--
r 65             return
--[ 2019.11.12.10.29.10.943.0 ]--
r 65             return 
--[ 2019.11.12.10.29.11.203.0 ]--
r 65             return f
--[ 2019.11.12.10.29.11.279.0 ]--
r 65             return fa
--[ 2019.11.12.10.29.11.381.0 ]--
r 65             return fal
--[ 2019.11.12.10.29.11.459.0 ]--
r 65             return fals
--[ 2019.11.12.10.29.11.564.0 ]--
r 65             return false
--[ 2019.11.12.10.29.11.611.0 ]--
r 65             return false;
--[ 2019.11.12.10.29.12.668.0 ]--
r 65             return false; 
--[ 2019.11.12.10.29.12.742.0 ]--
r 65             return false;
--[ 2019.11.12.10.29.15.012.0 ]--
- 64
- 64
r 64         
--[ 2019.11.12.10.29.15.234.0 ]--
- 64
--[ 2019.11.12.10.29.15.619.0 ]--
+ 64         
--[ 2019.11.12.10.29.15.872.0 ]--
r 64         r
--[ 2019.11.12.10.29.15.909.0 ]--
r 64         re
--[ 2019.11.12.10.29.16.013.0 ]--
r 64         ret
--[ 2019.11.12.10.29.16.132.0 ]--
r 64         retu
--[ 2019.11.12.10.29.16.173.0 ]--
r 64         retur
--[ 2019.11.12.10.29.16.261.0 ]--
r 64         return
--[ 2019.11.12.10.29.16.403.0 ]--
r 64         return 
--[ 2019.11.12.10.29.16.459.0 ]--
r 64         return f
--[ 2019.11.12.10.29.16.541.0 ]--
r 64         return fa
--[ 2019.11.12.10.29.16.634.0 ]--
r 64         return fal
--[ 2019.11.12.10.29.16.703.0 ]--
r 64         return fals
--[ 2019.11.12.10.29.16.856.0 ]--
r 64         return false
--[ 2019.11.12.10.29.17.201.0 ]--
r 64         return false;
--[ 2019.11.12.10.29.19.457.0 ]--
r 59     public boolean isEmpty() {
--[ 2019.11.12.10.29.20.609.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.29.34.237.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.29.38.450.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.29.41.229.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.29.54.268.0 ]--
+ 45     public Point min() { return 
r 46     ; }
--[ 2019.11.12.10.29.54.288.0 ]--
r 46             ; }
--[ 2019.11.12.10.29.54.388.0 ]--
r 46             r; }
--[ 2019.11.12.10.29.54.564.0 ]--
r 46             rb; }
--[ 2019.11.12.10.29.55.509.0 ]--
r 46             rb.; }
--[ 2019.11.12.10.29.55.970.0 ]--
r 46             rb; }
--[ 2019.11.12.10.29.56.360.0 ]--
r 46             rbT; }
--[ 2019.11.12.10.29.56.798.0 ]--
r 46             rbTree; }
--[ 2019.11.12.10.29.56.868.0 ]--
r 46             rbTree.; }
--[ 2019.11.12.10.29.57.418.0 ]--
r 46             rbTree.m; }
--[ 2019.11.12.10.29.57.510.0 ]--
r 46             rbTree.ma; }
--[ 2019.11.12.10.29.58.556.0 ]--
r 46             rbTree.; }
--[ 2019.11.12.10.29.58.898.0 ]--
r 46             rbTree; }
--[ 2019.11.12.10.29.59.047.0 ]--
r 46             ; }
--[ 2019.11.12.10.29.59.252.0 ]--
r 46 ; }
--[ 2019.11.12.10.29.59.662.0 ]--
- 45
r 45     public Point min() { return ; }
--[ 2019.11.12.10.30.00.232.0 ]--
r 45     public Point min() { return; }
--[ 2019.11.12.10.30.00.583.0 ]--
r 45     public Point min() { return ; }
--[ 2019.11.12.10.30.00.840.0 ]--
r 45     public Point min() { return r; }
--[ 2019.11.12.10.30.01.013.0 ]--
r 45     public Point min() { return rb; }
--[ 2019.11.12.10.30.01.509.0 ]--
r 45     public Point min() { return rbTree; }
--[ 2019.11.12.10.30.01.595.0 ]--
r 45     public Point min() { return rbTree.; }
--[ 2019.11.12.10.30.02.006.0 ]--
r 45     public Point min() { return rbTree.m; }
--[ 2019.11.12.10.30.02.181.0 ]--
r 45     public Point min() { return rbTree.mi; }
--[ 2019.11.12.10.30.02.227.0 ]--
r 45     public Point min() { return rbTree.min; }
--[ 2019.11.12.10.30.02.750.0 ]--
r 45     public Point min() { return rbTree.min(); }
--[ 2019.11.12.10.30.04.954.0 ]--
r 46     public Point max() { return r; }
--[ 2019.11.12.10.30.05.134.0 ]--
r 46     public Point max() { return rb; }
--[ 2019.11.12.10.30.05.644.0 ]--
r 46     public Point max() { return rbTree; }
--[ 2019.11.12.10.30.05.739.0 ]--
r 46     public Point max() { return rbTree.; }
--[ 2019.11.12.10.30.06.498.0 ]--
r 46     public Point max() { return rbTree.m; }
--[ 2019.11.12.10.30.06.567.0 ]--
r 46     public Point max() { return rbTree.ma; }
--[ 2019.11.12.10.30.06.752.0 ]--
r 46     public Point max() { return rbTree.max; }
--[ 2019.11.12.10.30.06.939.0 ]--
r 46     public Point max() { return rbTree.max(); }
--[ 2019.11.12.10.30.07.829.0 ]--
r 46     public Point max() { return rbTree.max() ; }
--[ 2019.11.12.10.30.07.877.0 ]--
r 46     public Point max() { return rbTree.max(); }
--[ 2019.11.12.10.30.23.858.0 ]--
+ 45     public Point min() { return 
r 46     rbTree.min(); }
--[ 2019.11.12.10.30.23.880.0 ]--
r 46             rbTree.min(); }
--[ 2019.11.12.10.30.26.379.0 ]--
+ 46             rbTree.min(); 
r 47     }
--[ 2019.11.12.10.30.34.040.0 ]--
- 46
r 46             rbTree.min(); }
--[ 2019.11.12.10.30.34.485.0 ]--
- 45
r 45     public Point min() { return rbTree.min(); }
--[ 2019.11.12.10.30.34.784.0 ]--
r 46     public Point max() { return rbTree.max() ; }
--[ 2019.11.12.10.30.35.877.0 ]--
r 46     public Point max() { return rbTree.max(); }
--[ 2019.11.12.10.30.39.228.0 ]--
r 46     public Point max() { return }
--[ 2019.11.12.10.30.42.845.0 ]--
r 45     public Point min() { return  }
--[ 2019.11.12.10.30.43.744.0 ]--
r 45     public Point min() { return }
--[ 2019.11.12.10.30.44.156.0 ]--
+ 45     public Point min() { return 
r 46     }
--[ 2019.11.12.10.30.44.862.0 ]--
+ 46     
--[ 2019.11.12.10.30.46.319.0 ]--
- 45
r 45     public Point min() { return
--[ 2019.11.12.10.30.48.203.0 ]--
+ 45     public Point min() { 
r 46         return
--[ 2019.11.12.10.30.49.310.0 ]--
+ 46         
--[ 2019.11.12.10.30.50.484.0 ]--
r 46         i
--[ 2019.11.12.10.30.50.550.0 ]--
r 46         if
--[ 2019.11.12.10.30.50.798.0 ]--
r 46         if()
--[ 2019.11.12.10.30.52.293.0 ]--
r 46         if(r)
--[ 2019.11.12.10.30.52.997.0 ]--
r 46         if(r )
--[ 2019.11.12.10.30.53.051.0 ]--
r 46         if(r)
--[ 2019.11.12.10.30.53.221.0 ]--
+ 46         if(r
r 47         )
--[ 2019.11.12.10.30.53.482.0 ]--
r 47         .)
--[ 2019.11.12.10.30.53.753.0 ]--
r 47         )
--[ 2019.11.12.10.30.53.856.0 ]--
- 46
r 46         if(r)
--[ 2019.11.12.10.30.54.284.0 ]--
r 46         if(r.)
--[ 2019.11.12.10.30.54.541.0 ]--
r 46         if(r)
--[ 2019.11.12.10.30.54.663.0 ]--
r 46         if(rb)
--[ 2019.11.12.10.30.54.749.0 ]--
r 46         if(rb.)
--[ 2019.11.12.10.30.55.237.0 ]--
r 46         if(rb)
--[ 2019.11.12.10.30.55.535.0 ]--
r 46         if(rbT)
--[ 2019.11.12.10.30.55.917.0 ]--
r 46         if(rbTree)
--[ 2019.11.12.10.30.56.005.0 ]--
r 46         if(rbTree.)
--[ 2019.11.12.10.30.57.139.0 ]--
r 46         if(rbTree.e)
--[ 2019.11.12.10.30.57.357.0 ]--
r 46         if(rbTree.)
--[ 2019.11.12.10.30.57.521.0 ]--
r 46         if(rbTree.i)
--[ 2019.11.12.10.30.57.558.0 ]--
r 46         if(rbTree.is)
--[ 2019.11.12.10.30.58.345.0 ]--
r 46         if(rbTree.isEmpty)
--[ 2019.11.12.10.30.58.352.0 ]--
r 46         if(rbTree.isEmpty())
--[ 2019.11.12.10.30.59.618.0 ]--
r 46         if(rbTree.isEmpty()){
--[ 2019.11.12.10.30.59.766.0 ]--
+ 47 
+ 48 }
--[ 2019.11.12.10.30.59.782.0 ]--
r 48         }
--[ 2019.11.12.10.30.59.794.0 ]--
r 47             
--[ 2019.11.12.10.31.00.760.0 ]--
r 48         return
r 49         }
--[ 2019.11.12.10.31.00.779.0 ]--
r 47 
r 48             return
--[ 2019.11.12.10.31.01.119.0 ]--
r 47             return
r 48 
--[ 2019.11.12.10.31.03.674.0 ]--
r 47             return 
--[ 2019.11.12.10.31.03.810.0 ]--
r 47             return n
--[ 2019.11.12.10.31.03.850.0 ]--
r 47             return nu
--[ 2019.11.12.10.31.04.048.0 ]--
r 47             return nul
--[ 2019.11.12.10.31.04.144.0 ]--
r 47             return null
--[ 2019.11.12.10.31.04.391.0 ]--
r 47             return null;
--[ 2019.11.12.10.31.05.816.0 ]--
+ 50         
--[ 2019.11.12.10.31.16.501.0 ]--
r 50         r
--[ 2019.11.12.10.31.16.832.0 ]--
r 50         re
--[ 2019.11.12.10.31.16.950.0 ]--
r 50         ret
--[ 2019.11.12.10.31.17.092.0 ]--
r 50         retu
--[ 2019.11.12.10.31.17.511.0 ]--
r 50         retur
--[ 2019.11.12.10.31.17.797.0 ]--
r 50         return
--[ 2019.11.12.10.31.18.556.0 ]--
r 50         return 
--[ 2019.11.12.10.31.19.517.0 ]--
r 50         return r
--[ 2019.11.12.10.31.19.851.0 ]--
r 50         return rb
--[ 2019.11.12.10.31.20.163.0 ]--
r 50         return rbTree
--[ 2019.11.12.10.31.20.432.0 ]--
r 50         return rbTree.
--[ 2019.11.12.10.31.20.773.0 ]--
r 50         return rbTree.m
--[ 2019.11.12.10.31.20.861.0 ]--
r 50         return rbTree.mi
--[ 2019.11.12.10.31.20.913.0 ]--
r 50         return rbTree.min
--[ 2019.11.12.10.31.21.162.0 ]--
r 50         return rbTree.min()
--[ 2019.11.12.10.31.23.360.0 ]--
r 50         return rbTree.min();
--[ 2019.11.12.10.31.26.540.0 ]--
r 52     public Point max() { return \}
--[ 2019.11.12.10.31.26.712.0 ]--
r 52     public Point max() { return \\}
--[ 2019.11.12.10.31.27.354.0 ]--
r 52     public Point max() { return \}
--[ 2019.11.12.10.31.27.467.0 ]--
r 52     public Point max() { return }
--[ 2019.11.12.10.31.27.645.0 ]--
+ 52     public Point max() { return 
r 53     }
--[ 2019.11.12.10.31.27.769.0 ]--
+ 53     
--[ 2019.11.12.10.31.31.898.0 ]--
+ 52     public Point max() { 
r 53         return 
--[ 2019.11.12.10.31.32.582.0 ]--
+ 53         
--[ 2019.11.12.10.31.35.134.0 ]--
r 53         i
--[ 2019.11.12.10.31.35.214.0 ]--
r 53         if
--[ 2019.11.12.10.31.35.406.0 ]--
r 53         if()
--[ 2019.11.12.10.31.35.661.0 ]--
r 53         if(r)
--[ 2019.11.12.10.31.35.858.0 ]--
r 53         if(rb)
--[ 2019.11.12.10.31.36.253.0 ]--
r 53         if(rbTree)
--[ 2019.11.12.10.31.36.355.0 ]--
r 53         if(rbTree.)
--[ 2019.11.12.10.31.36.678.0 ]--
r 53         if(rbTree.i)
--[ 2019.11.12.10.31.37.213.0 ]--
r 53         if(rbTree.isEmpty)
--[ 2019.11.12.10.31.37.227.0 ]--
r 53         if(rbTree.isEmpty())
--[ 2019.11.12.10.31.38.317.0 ]--
r 53         if(rbTree.isEmpty()){
--[ 2019.11.12.10.31.38.488.0 ]--
+ 54 
+ 55 }
--[ 2019.11.12.10.31.38.519.0 ]--
r 55         }
--[ 2019.11.12.10.31.38.534.0 ]--
r 54             
--[ 2019.11.12.10.31.39.311.0 ]--
r 55         return 
r 56         }
--[ 2019.11.12.10.31.39.333.0 ]--
r 54 
r 55             return
--[ 2019.11.12.10.31.39.469.0 ]--
r 54             return
r 55 
--[ 2019.11.12.10.31.41.016.0 ]--
r 54             return 
--[ 2019.11.12.10.31.41.231.0 ]--
r 54             return n
--[ 2019.11.12.10.31.41.295.0 ]--
r 54             return nu
--[ 2019.11.12.10.31.41.494.0 ]--
r 54             return nul
--[ 2019.11.12.10.31.41.591.0 ]--
r 54             return null
--[ 2019.11.12.10.31.42.308.0 ]--
r 54             return null;
--[ 2019.11.12.10.31.43.682.0 ]--
- 57
--[ 2019.11.12.10.31.43.859.0 ]--
+ 57         
--[ 2019.11.12.10.31.44.476.0 ]--
r 57         r
--[ 2019.11.12.10.31.44.533.0 ]--
r 57         re
--[ 2019.11.12.10.31.44.683.0 ]--
r 57         ret
--[ 2019.11.12.10.31.44.744.0 ]--
r 57         retu
--[ 2019.11.12.10.31.44.836.0 ]--
r 57         retur
--[ 2019.11.12.10.31.44.879.0 ]--
r 57         return
--[ 2019.11.12.10.31.45.004.0 ]--
r 57         return 
--[ 2019.11.12.10.31.45.180.0 ]--
r 57         return r
--[ 2019.11.12.10.31.45.355.0 ]--
r 57         return rb
--[ 2019.11.12.10.31.45.798.0 ]--
r 57         return rbTree
--[ 2019.11.12.10.31.46.101.0 ]--
r 57         return rbTree.
--[ 2019.11.12.10.31.50.497.0 ]--
r 57         return rbTree.m
--[ 2019.11.12.10.31.50.655.0 ]--
r 57         return rbTree.ma
--[ 2019.11.12.10.31.50.804.0 ]--
r 57         return rbTree.max
--[ 2019.11.12.10.31.51.063.0 ]--
r 57         return rbTree.max()
--[ 2019.11.12.10.31.51.267.0 ]--
r 57         return rbTree.max();
--[ 2019.11.12.10.31.56.511.0 ]--
r 72         if(r){
--[ 2019.11.12.10.31.56.701.0 ]--
r 72         if(rb){
--[ 2019.11.12.10.31.57.159.0 ]--
r 72         if(rbTree){
--[ 2019.11.12.10.31.57.235.0 ]--
r 72         if(rbTree.){
--[ 2019.11.12.10.31.57.482.0 ]--
r 72         if(rbTree.i){
--[ 2019.11.12.10.31.57.564.0 ]--
r 72         if(rbTree.is){
--[ 2019.11.12.10.31.57.773.0 ]--
r 72         if(rbTree.isEmpty){
--[ 2019.11.12.10.31.57.788.0 ]--
r 72         if(rbTree.isEmpty()){
--[ 2019.11.12.10.32.07.508.0 ]--
r 45     public Point min() {
r 52     public Point max() {
--[ 2019.11.12.10.34.32.978.0 ]--
r 20         return r;
--[ 2019.11.12.10.34.33.189.0 ]--
r 20         return rnb;
--[ 2019.11.12.10.34.33.722.0 ]--
r 20         return rn;
--[ 2019.11.12.10.34.33.832.0 ]--
r 20         return r;
--[ 2019.11.12.10.34.33.902.0 ]--
r 20         return rb;
--[ 2019.11.12.10.34.34.076.0 ]--
r 20         return rb.;
--[ 2019.11.12.10.34.34.646.0 ]--
r 20         return rb;
--[ 2019.11.12.10.34.35.324.0 ]--
r 20         return r;
--[ 2019.11.12.10.34.35.683.0 ]--
r 20         return rb;
--[ 2019.11.12.10.34.36.059.0 ]--
r 20         return rbTree;
--[ 2019.11.12.10.34.36.160.0 ]--
r 20         return rbTree.;
--[ 2019.11.12.10.34.36.266.0 ]--
r 20         return rbTree.g;
--[ 2019.11.12.10.34.36.597.0 ]--
r 20         return rbTree.ge;
--[ 2019.11.12.10.34.36.667.0 ]--
r 20         return rbTree.get;
--[ 2019.11.12.10.34.37.483.0 ]--
r 20         return rbTree.get();
--[ 2019.11.12.10.34.37.681.0 ]--
r 20         return rbTree.get(p);
--[ 2019.11.12.10.34.39.861.0 ]--
r 20         return rbTree.get(p); 
--[ 2019.11.12.10.34.39.925.0 ]--
r 20         return rbTree.get(p);
--[ 2019.11.12.10.34.42.796.0 ]--
r 24         return r;
--[ 2019.11.12.10.34.42.992.0 ]--
r 24         return rb;
--[ 2019.11.12.10.34.43.486.0 ]--
r 24         return rbTree;
--[ 2019.11.12.10.34.43.904.0 ]--
r 24         return rbTree.;
--[ 2019.11.12.10.34.44.294.0 ]--
r 24         return rbTree.c;
--[ 2019.11.12.10.34.44.396.0 ]--
r 24         return rbTree.co;
--[ 2019.11.12.10.34.44.500.0 ]--
r 24         return rbTree.con;
--[ 2019.11.12.10.34.44.844.0 ]--
r 24         return rbTree.contains;
--[ 2019.11.12.10.34.44.851.0 ]--
r 24         return rbTree.contains();
--[ 2019.11.12.10.34.46.208.0 ]--
r 24         return rbTree.contains(p);
--[ 2019.11.12.10.34.51.590.0 ]--
r 29         return r;
--[ 2019.11.12.10.34.51.782.0 ]--
r 29         return rb;
--[ 2019.11.12.10.34.52.432.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.34.52.499.0 ]--
r 29         return rbTree.;
--[ 2019.11.12.10.34.52.751.0 ]--
r 29         return rbTree.p;
--[ 2019.11.12.10.34.52.935.0 ]--
r 29         return rbTree.po;
--[ 2019.11.12.10.34.53.529.0 ]--
r 29         return rbTree.p;
--[ 2019.11.12.10.34.53.661.0 ]--
r 29         return rbTree.;
--[ 2019.11.12.10.34.53.798.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.34.53.905.0 ]--
r 29         return rbTre;
--[ 2019.11.12.10.34.54.307.0 ]--
r 29         return rbTree.po;
--[ 2019.11.12.10.34.54.480.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.34.54.657.0 ]--
r 29         return rb;
--[ 2019.11.12.10.34.55.132.0 ]--
r 29         return null;
--[ 2019.11.12.10.34.56.630.0 ]--
r 29         return null ;
--[ 2019.11.12.10.34.56.674.0 ]--
r 29         return null;
--[ 2019.11.12.10.35.57.154.0 ]--
r 39         return r;
--[ 2019.11.12.10.35.57.346.0 ]--
r 39         return rb;
--[ 2019.11.12.10.35.58.066.0 ]--
r 39         return rbT;
--[ 2019.11.12.10.35.58.244.0 ]--
r 39         return rbTr;
--[ 2019.11.12.10.35.58.377.0 ]--
r 39         return rbTre;
--[ 2019.11.12.10.35.58.476.0 ]--
r 39         return rbTree;
--[ 2019.11.12.10.35.58.582.0 ]--
r 39         return rbTree.;
--[ 2019.11.12.10.35.58.934.0 ]--
r 39         return rbTree.n;
--[ 2019.11.12.10.35.59.015.0 ]--
r 39         return rbTree.ne;
--[ 2019.11.12.10.35.59.038.0 ]--
r 39         return rbTree.nea;
--[ 2019.11.12.10.35.59.360.0 ]--
r 39         return rbTree.near;
--[ 2019.11.12.10.35.59.630.0 ]--
r 39         return rbTree.near ;
--[ 2019.11.12.10.35.59.715.0 ]--
r 39         return rbTree.near;
--[ 2019.11.12.10.35.59.868.0 ]--
r 39         return rbTree.;
--[ 2019.11.12.10.36.00.032.0 ]--
r 39         return rbTree;
--[ 2019.11.12.10.36.00.370.0 ]--
r 39         return ;
--[ 2019.11.12.10.36.01.754.0 ]--
r 39         return n;
--[ 2019.11.12.10.36.01.778.0 ]--
r 39         return nu;
--[ 2019.11.12.10.36.01.982.0 ]--
r 39         return nul;
--[ 2019.11.12.10.36.02.101.0 ]--
r 39         return null;
--[ 2019.11.12.10.41.18.254.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.10.48.48.838.0 ]--
r 29         return r;
--[ 2019.11.12.10.48.49.031.0 ]--
r 29         return rb;
--[ 2019.11.12.10.48.49.486.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.48.49.573.0 ]--
r 29         return rbTree.;
--[ 2019.11.12.10.49.12.997.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.49.13.956.0 ]--
r 29         return ;
--[ 2019.11.12.10.49.15.061.0 ]--
r 29         return n;
--[ 2019.11.12.10.49.15.074.0 ]--
r 29         return nu;
--[ 2019.11.12.10.49.15.270.0 ]--
r 29         return nul;
--[ 2019.11.12.10.49.15.400.0 ]--
r 29         return null;
--[ 2019.11.12.10.49.54.263.0 ]--
r 29         return r;
--[ 2019.11.12.10.49.54.431.0 ]--
r 29         return rb;
--[ 2019.11.12.10.49.54.968.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.49.55.020.0 ]--
r 29         return rbTree.;
--[ 2019.11.12.10.49.55.580.0 ]--
r 29         return rbTree.r;
--[ 2019.11.12.10.49.56.056.0 ]--
r 29         return rbTree.ra;
--[ 2019.11.12.10.49.56.512.0 ]--
r 29         return rbTree.r;
--[ 2019.11.12.10.49.57.730.0 ]--
r 29         return rbTree.;
--[ 2019.11.12.10.50.30.901.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.50.30.992.0 ]--
r 29         return rbTre;
--[ 2019.11.12.10.50.31.102.0 ]--
r 29         return rbTr;
--[ 2019.11.12.10.50.31.218.0 ]--
r 29         return rbT;
--[ 2019.11.12.10.50.31.315.0 ]--
r 29         return rb;
--[ 2019.11.12.10.50.31.432.0 ]--
r 29         return r;
--[ 2019.11.12.10.50.31.794.0 ]--
r 29         return ;
--[ 2019.11.12.10.50.31.992.0 ]--
r 29         return n;
--[ 2019.11.12.10.50.32.034.0 ]--
r 29         return nu;
--[ 2019.11.12.10.50.32.204.0 ]--
r 29         return nul;
--[ 2019.11.12.10.50.32.325.0 ]--
r 29         return null;
--[ 2019.11.12.10.57.32.446.0 ]--
r 29         return nul;
--[ 2019.11.12.10.57.32.558.0 ]--
r 29         return nu;
--[ 2019.11.12.10.57.32.669.0 ]--
r 29         return n;
--[ 2019.11.12.10.57.32.792.0 ]--
r 29         return ;
--[ 2019.11.12.10.57.32.905.0 ]--
r 29         return;
--[ 2019.11.12.10.57.33.041.0 ]--
r 29         returnr;
--[ 2019.11.12.10.57.33.313.0 ]--
r 29         return;
--[ 2019.11.12.10.57.33.426.0 ]--
r 29         return ;
--[ 2019.11.12.10.57.33.553.0 ]--
r 29         return r;
--[ 2019.11.12.10.57.33.752.0 ]--
r 29         return rb;
--[ 2019.11.12.10.57.34.005.0 ]--
r 29         return rbT;
--[ 2019.11.12.10.57.34.385.0 ]--
r 29         return rbT ;
--[ 2019.11.12.10.57.34.442.0 ]--
r 29         return rbT;
--[ 2019.11.12.10.57.35.074.0 ]--
r 29         return rbTr;
--[ 2019.11.12.10.57.35.406.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.57.35.909.0 ]--
r 29         return rbTree/;
--[ 2019.11.12.10.57.36.337.0 ]--
r 29         return rbTree;
--[ 2019.11.12.10.57.36.489.0 ]--
r 29         return rbTree.;
--[ 2019.11.12.10.57.53.568.0 ]--
r 29         return ;
--[ 2019.11.12.10.57.53.704.0 ]--
r 29         return n;
--[ 2019.11.12.10.57.53.766.0 ]--
r 29         return nu;
--[ 2019.11.12.10.57.53.922.0 ]--
r 29         return nul;
--[ 2019.11.12.10.57.54.062.0 ]--
r 29         return null;
--[ 2019.11.12.10.59.09.830.0 ]--
r 29          return null;
--[ 2019.11.12.10.59.10.895.0 ]--
r 28     public Iterable<Point> points()r {
--[ 2019.11.12.10.59.11.157.0 ]--
r 28     public Iterable<Point> points()rb {
--[ 2019.11.12.10.59.11.712.0 ]--
r 28     public Iterable<Point> points()rbt {
--[ 2019.11.12.10.59.13.513.0 ]--
r 28     public Iterable<Point> points()rb {
--[ 2019.11.12.10.59.13.683.0 ]--
r 28     public Iterable<Point> points()r {
--[ 2019.11.12.10.59.14.016.0 ]--
r 28     public Iterable<Point> points() {
--[ 2019.11.12.10.59.14.889.0 ]--
+ 29         
--[ 2019.11.12.10.59.15.562.0 ]--
r 29         r
--[ 2019.11.12.10.59.15.850.0 ]--
r 29         rb
--[ 2019.11.12.10.59.16.155.0 ]--
r 29         rbt
--[ 2019.11.12.10.59.17.130.0 ]--
r 29         rbTree
--[ 2019.11.12.10.59.17.461.0 ]--
r 29         rbTree.
--[ 2019.11.12.11.00.10.588.0 ]--
r 29         rbTree.keys
--[ 2019.11.12.11.00.10.611.0 ]--
r 29         rbTree.keys()
--[ 2019.11.12.11.00.11.890.0 ]--
r 29         rbTree.keys();
--[ 2019.11.12.11.00.14.676.0 ]--
r 30          return;
--[ 2019.11.12.11.00.17.456.0 ]--
r 30          return
--[ 2019.11.12.11.00.19.542.0 ]--
r 30          
--[ 2019.11.12.11.00.20.523.0 ]--
r 29         returnrbTree.keys();
--[ 2019.11.12.11.00.21.087.0 ]--
r 29         return rbTree.keys();
--[ 2019.11.12.11.00.22.822.0 ]--
r 30         
--[ 2019.11.12.11.00.23.006.0 ]--
- 30
--[ 2019.11.12.11.00.28.207.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.00.42.233.0 ]--
r 35     } 
--[ 2019.11.12.11.00.42.291.0 ]--
r 35     }
--[ 2019.11.12.11.02.14.347.0 ]--
+ 34         
--[ 2019.11.12.11.02.15.625.0 ]--
- 34
--[ 2019.11.12.11.02.16.150.0 ]--
+ 34         
--[ 2019.11.12.11.07.25.589.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.14.47.952.0 ]--
r 34         f
--[ 2019.11.12.11.14.48.024.0 ]--
r 34         fo
--[ 2019.11.12.11.14.48.101.0 ]--
r 34         for
--[ 2019.11.12.11.14.48.493.0 ]--
r 34         for()
--[ 2019.11.12.11.14.54.155.0 ]--
r 34         for( )
--[ 2019.11.12.11.14.54.225.0 ]--
r 34         for()
--[ 2019.11.12.11.14.54.383.0 ]--
r 34         for(P)
--[ 2019.11.12.11.14.54.550.0 ]--
r 34         for(Po)
--[ 2019.11.12.11.14.54.737.0 ]--
r 34         for(Poi)
--[ 2019.11.12.11.14.54.777.0 ]--
r 34         for(Poin)
--[ 2019.11.12.11.14.54.898.0 ]--
r 34         for(Point)
--[ 2019.11.12.11.14.54.979.0 ]--
r 34         for(Point )
--[ 2019.11.12.11.14.55.127.0 ]--
r 34         for(Point p)
--[ 2019.11.12.11.14.55.853.0 ]--
r 34         for(Point p )
--[ 2019.11.12.11.14.55.985.0 ]--
r 34         for(Point p :)
--[ 2019.11.12.11.14.56.059.0 ]--
r 34         for(Point p : )
--[ 2019.11.12.11.14.56.835.0 ]--
r 34         for(Point p : p)
--[ 2019.11.12.11.14.56.973.0 ]--
r 34         for(Point p : po)
--[ 2019.11.12.11.14.57.097.0 ]--
r 34         for(Point p : poi)
--[ 2019.11.12.11.14.57.155.0 ]--
r 34         for(Point p : poin)
--[ 2019.11.12.11.14.57.203.0 ]--
r 34         for(Point p : point)
--[ 2019.11.12.11.14.57.331.0 ]--
r 34         for(Point p : points)
--[ 2019.11.12.11.14.57.508.0 ]--
r 34         for(Point p : points())
--[ 2019.11.12.11.14.58.678.0 ]--
r 34         for(Point p : points()){
--[ 2019.11.12.11.14.58.843.0 ]--
+ 35 
+ 36 }
--[ 2019.11.12.11.14.58.854.0 ]--
r 36         }
--[ 2019.11.12.11.14.58.871.0 ]--
r 35             
--[ 2019.11.12.11.15.06.492.0 ]--
r 34         for(Point  : points()){
--[ 2019.11.12.11.15.10.762.0 ]--
r 34         for(Point k : points()){
--[ 2019.11.12.11.15.12.026.0 ]--
r 34         for(Point k  : points()){
--[ 2019.11.12.11.15.12.052.0 ]--
r 34         for(Point k : points()){
--[ 2019.11.12.11.15.35.854.0 ]--
+ 34         
--[ 2019.11.12.11.16.54.509.0 ]--
- 36
--[ 2019.11.12.11.16.54.692.0 ]--
+ 36             
--[ 2019.11.12.11.16.55.099.0 ]--
r 36             k
--[ 2019.11.12.11.16.55.288.0 ]--
r 36             k.
--[ 2019.11.12.11.16.55.495.0 ]--
r 36             k.e
--[ 2019.11.12.11.16.56.184.0 ]--
r 36             k.eu
--[ 2019.11.12.11.16.56.785.0 ]--
r 36             k.e
--[ 2019.11.12.11.16.56.852.0 ]--
r 36             k.
--[ 2019.11.12.11.16.57.022.0 ]--
r 36             k.d
--[ 2019.11.12.11.16.57.134.0 ]--
r 36             k.di
--[ 2019.11.12.11.16.59.632.0 ]--
r 36             k.di 
--[ 2019.11.12.11.16.59.715.0 ]--
r 36             k.di
--[ 2019.11.12.11.16.59.861.0 ]--
r 36             k.
--[ 2019.11.12.11.17.00.075.0 ]--
r 36             k
--[ 2019.11.12.11.17.00.489.0 ]--
r 36             
--[ 2019.11.12.11.17.00.630.0 ]--
- 36
--[ 2019.11.12.11.17.02.292.0 ]--
- 35
- 35
--[ 2019.11.12.11.17.02.532.0 ]--
- 34
--[ 2019.11.12.11.21.31.116.0 ]--
+ 34         
--[ 2019.11.12.11.21.56.020.0 ]--
r 34         r
--[ 2019.11.12.11.21.56.083.0 ]--
r 34         rb
--[ 2019.11.12.11.21.57.465.0 ]--
r 34         r
--[ 2019.11.12.11.21.57.606.0 ]--
r 34         
--[ 2019.11.12.11.21.58.021.0 ]--
r 34         r
--[ 2019.11.12.11.21.58.146.0 ]--
r 34         rn
--[ 2019.11.12.11.21.59.285.0 ]--
r 34         r
--[ 2019.11.12.11.21.59.403.0 ]--
r 34         
--[ 2019.11.12.11.21.59.754.0 ]--
r 34         r
--[ 2019.11.12.11.21.59.841.0 ]--
r 34         rn
--[ 2019.11.12.11.22.00.592.0 ]--
r 34         r
--[ 2019.11.12.11.22.00.797.0 ]--
r 34         rb
--[ 2019.11.12.11.22.01.188.0 ]--
r 34         rbTree
--[ 2019.11.12.11.22.01.336.0 ]--
r 34         rbTree.
--[ 2019.11.12.11.22.01.872.0 ]--
r 34         rbTree
--[ 2019.11.12.11.22.02.019.0 ]--
r 34         
--[ 2019.11.12.11.22.22.769.0 ]--
r 34         f
--[ 2019.11.12.11.22.22.876.0 ]--
r 34         fi
--[ 2019.11.12.11.22.22.970.0 ]--
r 34         fir
--[ 2019.11.12.11.22.23.593.0 ]--
r 34         fir*
--[ 2019.11.12.11.22.23.847.0 ]--
r 34         fir
--[ 2019.11.12.11.22.23.969.0 ]--
r 34         fi
--[ 2019.11.12.11.22.24.071.0 ]--
r 34         f
--[ 2019.11.12.11.22.24.253.0 ]--
r 34         fo
--[ 2019.11.12.11.22.24.354.0 ]--
r 34         for
--[ 2019.11.12.11.22.24.549.0 ]--
r 34         for()
--[ 2019.11.12.11.22.25.168.0 ]--
r 34         for(p)
--[ 2019.11.12.11.22.25.363.0 ]--
r 34         for(po)
--[ 2019.11.12.11.22.25.495.0 ]--
r 34         for(poi)
--[ 2019.11.12.11.22.25.575.0 ]--
r 34         for(poin)
--[ 2019.11.12.11.22.25.700.0 ]--
r 34         for(point)
--[ 2019.11.12.11.22.25.904.0 ]--
r 34         for(point )
--[ 2019.11.12.11.22.26.042.0 ]--
r 34         for(point q)
--[ 2019.11.12.11.22.26.329.0 ]--
r 34         for(point q:)
--[ 2019.11.12.11.22.26.463.0 ]--
r 34         for(point q: )
--[ 2019.11.12.11.22.26.926.0 ]--
r 34         for(point q)
--[ 2019.11.12.11.22.27.087.0 ]--
r 34         for(point )
--[ 2019.11.12.11.22.27.412.0 ]--
r 34         for(point)
--[ 2019.11.12.11.22.27.554.0 ]--
r 34         for(poin)
--[ 2019.11.12.11.22.27.667.0 ]--
r 34         for(poi)
--[ 2019.11.12.11.22.27.768.0 ]--
r 34         for(po)
--[ 2019.11.12.11.22.27.895.0 ]--
r 34         for(p)
--[ 2019.11.12.11.22.28.346.0 ]--
r 34         for()
--[ 2019.11.12.11.22.28.967.0 ]--
r 34         for(O)
--[ 2019.11.12.11.22.29.152.0 ]--
r 34         for(Oi)
--[ 2019.11.12.11.22.29.578.0 ]--
r 34         for(O=)
--[ 2019.11.12.11.22.29.655.0 ]--
r 34         for(O)
--[ 2019.11.12.11.22.30.087.0 ]--
r 34         for()
--[ 2019.11.12.11.22.30.260.0 ]--
r 34         for(P)
--[ 2019.11.12.11.22.30.400.0 ]--
r 34         for(Po)
--[ 2019.11.12.11.22.30.563.0 ]--
r 34         for(Poi)
--[ 2019.11.12.11.22.30.610.0 ]--
r 34         for(Poin)
--[ 2019.11.12.11.22.30.682.0 ]--
r 34         for(Poinr)
--[ 2019.11.12.11.22.30.844.0 ]--
r 34         for(Poinrt)
--[ 2019.11.12.11.22.30.909.0 ]--
r 34         for(Poinrt )
--[ 2019.11.12.11.22.31.014.0 ]--
r 34         for(Poinrt q)
--[ 2019.11.12.11.22.31.312.0 ]--
r 34         for(Poinrt )
--[ 2019.11.12.11.22.31.534.0 ]--
r 34         for(Poinrt)
--[ 2019.11.12.11.22.31.754.0 ]--
r 34         for(Poinr)
--[ 2019.11.12.11.22.31.995.0 ]--
r 34         for(Poin)
--[ 2019.11.12.11.22.32.168.0 ]--
r 34         for(Point)
--[ 2019.11.12.11.22.32.305.0 ]--
r 34         for(Point )
--[ 2019.11.12.11.22.32.396.0 ]--
r 34         for(Point q)
--[ 2019.11.12.11.22.33.288.0 ]--
r 34         for(Point q )
--[ 2019.11.12.11.22.33.390.0 ]--
r 34         for(Point q :)
--[ 2019.11.12.11.22.33.478.0 ]--
r 34         for(Point q : )
--[ 2019.11.12.11.22.34.729.0 ]--
r 34         for(Point q : p)
--[ 2019.11.12.11.22.34.890.0 ]--
r 34         for(Point q : po)
--[ 2019.11.12.11.22.35.027.0 ]--
r 34         for(Point q : poi)
--[ 2019.11.12.11.22.35.059.0 ]--
r 34         for(Point q : poin)
--[ 2019.11.12.11.22.35.145.0 ]--
r 34         for(Point q : point)
--[ 2019.11.12.11.22.35.235.0 ]--
r 34         for(Point q : points)
--[ 2019.11.12.11.22.35.528.0 ]--
r 34         for(Point q : points())
--[ 2019.11.12.11.22.36.837.0 ]--
r 34         for(Point q : points()){
--[ 2019.11.12.11.22.37.381.0 ]--
r 34         for(Point q : points()){ 
--[ 2019.11.12.11.22.37.414.0 ]--
r 34         for(Point q : points()){
--[ 2019.11.12.11.22.37.599.0 ]--
+ 35 
+ 36 }
--[ 2019.11.12.11.22.37.612.0 ]--
r 36         }
--[ 2019.11.12.11.22.37.621.0 ]--
r 35             
--[ 2019.11.12.11.22.42.113.0 ]--
r 35             q
--[ 2019.11.12.11.22.42.177.0 ]--
r 35             q.
--[ 2019.11.12.11.22.42.651.0 ]--
r 35             q.c
--[ 2019.11.12.11.22.42.776.0 ]--
r 35             q.co
--[ 2019.11.12.11.22.42.813.0 ]--
r 35             q.com
--[ 2019.11.12.11.22.44.579.0 ]--
r 35             q.compareTo
--[ 2019.11.12.11.22.44.585.0 ]--
r 35             q.compareTo()
--[ 2019.11.12.11.22.45.197.0 ]--
r 35             q.compareTo(p)
--[ 2019.11.12.11.22.46.737.0 ]--
r 35             q.compareTo(p);
--[ 2019.11.12.11.22.48.047.0 ]--
r 35             q.compareTo(p); 
--[ 2019.11.12.11.22.48.131.0 ]--
r 35             q.compareTo(p);
--[ 2019.11.12.11.22.54.810.0 ]--
+ 34         
--[ 2019.11.12.11.23.01.001.0 ]--
r 34         p
--[ 2019.11.12.11.23.01.177.0 ]--
r 34         po
--[ 2019.11.12.11.23.02.538.0 ]--
r 34         p
--[ 2019.11.12.11.23.02.668.0 ]--
r 34         
--[ 2019.11.12.11.23.02.967.0 ]--
r 34         P
--[ 2019.11.12.11.23.03.123.0 ]--
r 34         Po
--[ 2019.11.12.11.23.03.274.0 ]--
r 34         Poi
--[ 2019.11.12.11.23.03.357.0 ]--
r 34         Poin
--[ 2019.11.12.11.23.03.440.0 ]--
r 34         Point
--[ 2019.11.12.11.23.03.533.0 ]--
r 34         Point 
--[ 2019.11.12.11.23.03.726.0 ]--
r 34         Point m
--[ 2019.11.12.11.23.03.790.0 ]--
r 34         Point mi
--[ 2019.11.12.11.23.03.863.0 ]--
r 34         Point min
--[ 2019.11.12.11.23.04.616.0 ]--
r 34         Point min;
--[ 2019.11.12.11.23.05.440.0 ]--
r 34         Point min; 
--[ 2019.11.12.11.23.05.481.0 ]--
r 34         Point min;
--[ 2019.11.12.11.23.08.681.0 ]--
+ 37             
--[ 2019.11.12.11.23.09.024.0 ]--
r 37             i
--[ 2019.11.12.11.23.09.105.0 ]--
r 37             if
--[ 2019.11.12.11.23.09.928.0 ]--
r 37             if()
--[ 2019.11.12.11.23.12.134.0 ]--
r 37             if(q)
--[ 2019.11.12.11.23.12.609.0 ]--
r 37             if()
--[ 2019.11.12.11.23.14.227.0 ]--
r 37             if(
--[ 2019.11.12.11.23.14.398.0 ]--
r 37             if
--[ 2019.11.12.11.23.14.556.0 ]--
r 37             i
--[ 2019.11.12.11.23.14.920.0 ]--
r 37             
--[ 2019.11.12.11.23.15.168.0 ]--
r 37              
--[ 2019.11.12.11.23.15.259.0 ]--
r 37             
--[ 2019.11.12.11.23.15.439.0 ]--
- 37
--[ 2019.11.12.11.23.17.905.0 ]--
r 36             i
--[ 2019.11.12.11.23.18.002.0 ]--
r 36             if
--[ 2019.11.12.11.23.18.257.0 ]--
r 36             if()
--[ 2019.11.12.11.23.18.682.0 ]--
r 36             if(q)
--[ 2019.11.12.11.23.19.056.0 ]--
r 36             if(q.)
--[ 2019.11.12.11.23.19.304.0 ]--
r 36             if(q.c)
--[ 2019.11.12.11.23.19.363.0 ]--
r 36             if(q.co)
--[ 2019.11.12.11.23.19.423.0 ]--
r 36             if(q.com)
--[ 2019.11.12.11.23.19.666.0 ]--
r 36             if(q.compareTo)
--[ 2019.11.12.11.23.19.671.0 ]--
r 36             if(q.compareTo())
--[ 2019.11.12.11.23.21.056.0 ]--
r 36             if(q.compareTo(p))
--[ 2019.11.12.11.23.21.959.0 ]--
r 36             if(q.compareTo(p) )
--[ 2019.11.12.11.23.25.911.0 ]--
r 36             if(q.compareTo(p) <)
--[ 2019.11.12.11.23.26.100.0 ]--
r 36             if(q.compareTo(p) < )
--[ 2019.11.12.11.23.30.183.0 ]--
r 36             if(q.compareTo(p) <)
--[ 2019.11.12.11.23.30.299.0 ]--
r 36             if(q.compareTo(p) )
--[ 2019.11.12.11.23.30.689.0 ]--
r 36             if(q.compareTo(p)  )
--[ 2019.11.12.11.23.30.762.0 ]--
r 36             if(q.compareTo(p) )
--[ 2019.11.12.11.23.31.662.0 ]--
r 36             if(q.compareTo(p) <)
--[ 2019.11.12.11.23.31.986.0 ]--
r 36             if(q.compareTo(p) < )
--[ 2019.11.12.11.23.32.091.0 ]--
r 36             if(q.compareTo(p) < 0)
--[ 2019.11.12.11.23.35.087.0 ]--
r 36             if(q.compareTo(p) < 0){
--[ 2019.11.12.11.23.35.296.0 ]--
+ 37 
+ 38 }
--[ 2019.11.12.11.23.35.309.0 ]--
r 38             }
--[ 2019.11.12.11.23.35.318.0 ]--
r 37                 
--[ 2019.11.12.11.23.43.456.0 ]--
r 37                 m
--[ 2019.11.12.11.23.43.539.0 ]--
r 37                 mi
--[ 2019.11.12.11.23.43.610.0 ]--
r 37                 min
--[ 2019.11.12.11.23.43.724.0 ]--
r 37                 min 
--[ 2019.11.12.11.23.43.949.0 ]--
r 37                 min  
--[ 2019.11.12.11.23.44.103.0 ]--
r 37                 min 
--[ 2019.11.12.11.23.44.263.0 ]--
r 37                 min =
--[ 2019.11.12.11.23.44.395.0 ]--
r 37                 min = 
--[ 2019.11.12.11.23.44.532.0 ]--
r 37                 min = q
--[ 2019.11.12.11.23.45.089.0 ]--
r 37                 min = q;
--[ 2019.11.12.11.23.46.703.0 ]--
r 40         return nul;
--[ 2019.11.12.11.23.46.799.0 ]--
r 40         return nu;
--[ 2019.11.12.11.23.46.903.0 ]--
r 40         return n;
--[ 2019.11.12.11.23.47.207.0 ]--
r 40         return ;
--[ 2019.11.12.11.23.47.327.0 ]--
r 40         return q;
--[ 2019.11.12.11.23.52.638.0 ]--
r 40         return qm;
--[ 2019.11.12.11.23.52.720.0 ]--
r 40         return qmi;
--[ 2019.11.12.11.23.52.782.0 ]--
r 40         return qmin;
--[ 2019.11.12.11.23.52.958.0 ]--
r 40         return qmi;
--[ 2019.11.12.11.23.53.062.0 ]--
r 40         return qm;
--[ 2019.11.12.11.23.53.167.0 ]--
r 40         return q;
--[ 2019.11.12.11.23.53.292.0 ]--
r 40         return ;
--[ 2019.11.12.11.23.53.419.0 ]--
r 40         return m;
--[ 2019.11.12.11.23.53.484.0 ]--
r 40         return mi;
--[ 2019.11.12.11.23.53.539.0 ]--
r 40         return min;
--[ 2019.11.12.11.24.06.251.0 ]--
+ 9     
--[ 2019.11.12.11.24.07.788.0 ]--
- 9
--[ 2019.11.12.11.24.09.587.0 ]--
+ 9     
--[ 2019.11.12.11.24.14.584.0 ]--
r 9     p
--[ 2019.11.12.11.24.14.697.0 ]--
r 9     pr
--[ 2019.11.12.11.24.14.742.0 ]--
r 9     pri
--[ 2019.11.12.11.24.14.889.0 ]--
r 9     priv
--[ 2019.11.12.11.24.14.950.0 ]--
r 9     priva
--[ 2019.11.12.11.24.15.091.0 ]--
r 9     privat
--[ 2019.11.12.11.24.15.136.0 ]--
r 9     private
--[ 2019.11.12.11.24.15.162.0 ]--
r 9     private 
--[ 2019.11.12.11.24.15.272.0 ]--
r 9     private P
--[ 2019.11.12.11.24.15.402.0 ]--
r 9     private Po
--[ 2019.11.12.11.24.15.538.0 ]--
r 9     private Poi
--[ 2019.11.12.11.24.15.647.0 ]--
r 9     private Poin
--[ 2019.11.12.11.24.15.742.0 ]--
r 9     private Point
--[ 2019.11.12.11.24.15.828.0 ]--
r 9     private Point 
--[ 2019.11.12.11.24.15.849.0 ]--
r 9     private Point m
--[ 2019.11.12.11.24.15.939.0 ]--
r 9     private Point mi
--[ 2019.11.12.11.24.15.982.0 ]--
r 9     private Point min
--[ 2019.11.12.11.24.16.216.0 ]--
r 9     private Point min;
--[ 2019.11.12.11.24.21.288.0 ]--
r 35         m
--[ 2019.11.12.11.24.21.371.0 ]--
r 35         mi
--[ 2019.11.12.11.24.21.433.0 ]--
r 35         min
--[ 2019.11.12.11.24.21.557.0 ]--
r 35         min 
--[ 2019.11.12.11.24.21.636.0 ]--
r 35         min =
--[ 2019.11.12.11.24.21.718.0 ]--
r 35         min = 
--[ 2019.11.12.11.24.21.852.0 ]--
r 35         min = n
--[ 2019.11.12.11.24.22.071.0 ]--
r 35         min = nw
--[ 2019.11.12.11.24.22.291.0 ]--
r 35         min = n
--[ 2019.11.12.11.24.22.351.0 ]--
r 35         min = ne
--[ 2019.11.12.11.24.22.522.0 ]--
r 35         min = new
--[ 2019.11.12.11.24.22.587.0 ]--
r 35         min = new 
--[ 2019.11.12.11.24.22.709.0 ]--
r 35         min = new P
--[ 2019.11.12.11.24.22.844.0 ]--
r 35         min = new Po
--[ 2019.11.12.11.24.22.986.0 ]--
r 35         min = new Poi
--[ 2019.11.12.11.24.23.021.0 ]--
r 35         min = new Poin
--[ 2019.11.12.11.24.23.093.0 ]--
r 35         min = new Point
--[ 2019.11.12.11.24.24.561.0 ]--
r 35         min = new Point;
--[ 2019.11.12.11.24.26.919.0 ]--
r 35         min = new Point();
--[ 2019.11.12.11.24.28.609.0 ]--
r 35         min = new Point(;
--[ 2019.11.12.11.24.28.738.0 ]--
r 35         min = new Point;
--[ 2019.11.12.11.24.31.955.0 ]--
r 35         min = new Point
--[ 2019.11.12.11.24.32.877.0 ]--
r 35         min = new Point()
--[ 2019.11.12.11.24.34.793.0 ]--
r 35         min = new Point();
--[ 2019.11.12.11.24.35.690.0 ]--
r 35         min = new Point(); 
--[ 2019.11.12.11.24.35.744.0 ]--
r 35         min = new Point();
--[ 2019.11.12.11.24.36.902.0 ]--
r 35         min = new Point<>();
--[ 2019.11.12.11.24.40.635.0 ]--
r 35         
--[ 2019.11.12.11.24.40.960.0 ]--
- 35
--[ 2019.11.12.11.24.43.585.0 ]--
r 34     public Point nearest(Point p) { 
--[ 2019.11.12.11.24.43.631.0 ]--
r 34     public Point nearest(Point p) {
--[ 2019.11.12.11.24.46.570.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.25.13.748.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.25.38.906.0 ]--
r 36             if(q.c(p) < 0){
--[ 2019.11.12.11.25.39.870.0 ]--
r 36             if(q.(p) < 0){
--[ 2019.11.12.11.25.40.200.0 ]--
r 36             if(q(p) < 0){
--[ 2019.11.12.11.25.40.437.0 ]--
r 36             if(q.(p) < 0){
--[ 2019.11.12.11.25.40.772.0 ]--
r 36             if(q(p) < 0){
--[ 2019.11.12.11.25.41.023.0 ]--
r 36             if(q.(p) < 0){
--[ 2019.11.12.11.25.47.745.0 ]--
r 36             if(q.dist(p) < 0){
--[ 2019.11.12.11.26.40.865.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.27.04.179.0 ]--
+ 36             
--[ 2019.11.12.11.27.04.445.0 ]--
r 36             m
--[ 2019.11.12.11.27.04.539.0 ]--
r 36             mi
--[ 2019.11.12.11.27.04.591.0 ]--
r 36             min
--[ 2019.11.12.11.27.04.757.0 ]--
r 36             min 
--[ 2019.11.12.11.27.04.832.0 ]--
r 36             min =
--[ 2019.11.12.11.27.05.198.0 ]--
r 36             min = 
--[ 2019.11.12.11.27.05.278.0 ]--
r 36             min = 0
--[ 2019.11.12.11.27.05.429.0 ]--
r 36             min = 0;
--[ 2019.11.12.11.27.06.272.0 ]--
r 36             min = 0; 
--[ 2019.11.12.11.27.06.319.0 ]--
r 36             min = 0;
--[ 2019.11.12.11.27.13.302.0 ]--
r 36             
--[ 2019.11.12.11.27.13.504.0 ]--
- 36
--[ 2019.11.12.11.27.13.841.0 ]--
+ 36             min = 0;
--[ 2019.11.12.11.27.14.163.0 ]--
r 36             min = 0; 
--[ 2019.11.12.11.27.14.314.0 ]--
r 36             
--[ 2019.11.12.11.27.14.443.0 ]--
- 36
--[ 2019.11.12.11.27.14.682.0 ]--
r 36             if(q.(p) < 0){
--[ 2019.11.12.11.27.14.843.0 ]--
r 36             if(q(p) < 0){
--[ 2019.11.12.11.27.15.220.0 ]--
r 36             if(q.(p) < 0){
--[ 2019.11.12.11.27.15.411.0 ]--
r 36             if(q(p) < 0){
--[ 2019.11.12.11.27.15.589.0 ]--
r 36             if(q.c(p) < 0){
--[ 2019.11.12.11.27.15.802.0 ]--
r 36             if(q.compareTo(p) < 0){
--[ 2019.11.12.11.27.18.734.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.29.48.438.0 ]--
+ 35         
--[ 2019.11.12.11.29.51.354.0 ]--
r 35         M
--[ 2019.11.12.11.29.51.523.0 ]--
r 35         Mi
--[ 2019.11.12.11.29.51.576.0 ]--
r 35         Min
--[ 2019.11.12.11.29.52.293.0 ]--
r 35         MinP
--[ 2019.11.12.11.29.52.414.0 ]--
r 35         MinPQ
--[ 2019.11.12.11.29.53.678.0 ]--
r 35         MinPQ<>
--[ 2019.11.12.11.29.54.428.0 ]--
r 35         MinPQ<P>
--[ 2019.11.12.11.29.54.576.0 ]--
r 35         MinPQ<Po>
--[ 2019.11.12.11.29.54.787.0 ]--
r 35         MinPQ<Poi>
--[ 2019.11.12.11.29.54.842.0 ]--
r 35         MinPQ<Poin>
--[ 2019.11.12.11.29.54.954.0 ]--
r 35         MinPQ<Point>
--[ 2019.11.12.11.29.55.283.0 ]--
r 35         MinPQ<PointD>
--[ 2019.11.12.11.29.55.399.0 ]--
r 35         MinPQ<PointDi>
--[ 2019.11.12.11.29.55.568.0 ]--
r 35         MinPQ<PointDis>
--[ 2019.11.12.11.29.55.736.0 ]--
r 35         MinPQ<PointDist>
--[ 2019.11.12.11.29.56.932.0 ]--
r 35         MinPQ<PointDist> 
--[ 2019.11.12.11.29.57.507.0 ]--
r 35         MinPQ<PointDist> p
--[ 2019.11.12.11.29.57.567.0 ]--
r 35         MinPQ<PointDist> pq
--[ 2019.11.12.11.29.57.889.0 ]--
r 35         MinPQ<PointDist> pq 
--[ 2019.11.12.11.29.58.050.0 ]--
r 35         MinPQ<PointDist> pq =
--[ 2019.11.12.11.29.58.151.0 ]--
r 35         MinPQ<PointDist> pq = 
--[ 2019.11.12.11.29.58.263.0 ]--
r 35         MinPQ<PointDist> pq = n
--[ 2019.11.12.11.29.58.351.0 ]--
r 35         MinPQ<PointDist> pq = ne
--[ 2019.11.12.11.29.58.521.0 ]--
r 35         MinPQ<PointDist> pq = new
--[ 2019.11.12.11.29.58.578.0 ]--
r 35         MinPQ<PointDist> pq = new 
--[ 2019.11.12.11.29.59.758.0 ]--
r 35         MinPQ<PointDist> pq = new m
--[ 2019.11.12.11.30.00.009.0 ]--
r 35         MinPQ<PointDist> pq = new 
--[ 2019.11.12.11.30.00.133.0 ]--
r 35         MinPQ<PointDist> pq = new M
--[ 2019.11.12.11.30.00.237.0 ]--
r 35         MinPQ<PointDist> pq = new Mi
--[ 2019.11.12.11.30.00.298.0 ]--
r 35         MinPQ<PointDist> pq = new Min
--[ 2019.11.12.11.30.00.714.0 ]--
r 35         MinPQ<PointDist> pq = new MinPQ
--[ 2019.11.12.11.30.00.726.0 ]--
r 35         MinPQ<PointDist> pq = new MinPQ<>
--[ 2019.11.12.11.30.00.735.0 ]--
r 35         MinPQ<PointDist> pq = new MinPQ<>()
--[ 2019.11.12.11.30.01.815.0 ]--
r 35         MinPQ<PointDist> pq = new MinPQ<>();
--[ 2019.11.12.11.30.09.361.0 ]--
+ 37             
--[ 2019.11.12.11.30.11.087.0 ]--
r 37             p
--[ 2019.11.12.11.30.11.264.0 ]--
r 37             p.
--[ 2019.11.12.11.30.11.542.0 ]--
r 37             p
--[ 2019.11.12.11.30.11.597.0 ]--
r 37             pq
--[ 2019.11.12.11.30.11.670.0 ]--
r 37             pq.
--[ 2019.11.12.11.30.13.150.0 ]--
r 37             pq.insert
--[ 2019.11.12.11.30.13.155.0 ]--
r 37             pq.insert()
--[ 2019.11.12.11.30.13.161.0 ]--
r 37             pq.insert();
--[ 2019.11.12.11.30.14.089.0 ]--
r 37             pq.insert(n);
--[ 2019.11.12.11.30.14.169.0 ]--
r 37             pq.insert(ne);
--[ 2019.11.12.11.30.14.319.0 ]--
r 37             pq.insert(new);
--[ 2019.11.12.11.30.15.397.0 ]--
r 37             pq.insert(new );
--[ 2019.11.12.11.30.15.594.0 ]--
r 37             pq.insert(new P);
--[ 2019.11.12.11.30.15.745.0 ]--
r 37             pq.insert(new Po);
--[ 2019.11.12.11.30.15.895.0 ]--
r 37             pq.insert(new Poi);
--[ 2019.11.12.11.30.15.949.0 ]--
r 37             pq.insert(new Poin);
--[ 2019.11.12.11.30.16.088.0 ]--
r 37             pq.insert(new Point);
--[ 2019.11.12.11.30.16.838.0 ]--
r 37             pq.insert(new PointD);
--[ 2019.11.12.11.30.17.359.0 ]--
r 37             pq.insert(new PointDist);
--[ 2019.11.12.11.30.17.369.0 ]--
r 37             pq.insert(new PointDist());
--[ 2019.11.12.11.30.18.795.0 ]--
r 37             pq.insert(new PointDist(q));
--[ 2019.11.12.11.30.18.900.0 ]--
r 37             pq.insert(new PointDist(q,));
--[ 2019.11.12.11.30.18.988.0 ]--
r 37             pq.insert(new PointDist(q, ));
--[ 2019.11.12.11.30.19.297.0 ]--
r 37             pq.insert(new PointDist(q, p));
--[ 2019.11.12.11.30.19.491.0 ]--
r 37             pq.insert(new PointDist(q, p.));
--[ 2019.11.12.11.30.19.650.0 ]--
r 37             pq.insert(new PointDist(q, p.d));
--[ 2019.11.12.11.30.19.757.0 ]--
r 37             pq.insert(new PointDist(q, p.di));
--[ 2019.11.12.11.30.19.854.0 ]--
r 37             pq.insert(new PointDist(q, p.dis));
--[ 2019.11.12.11.30.20.302.0 ]--
r 37             pq.insert(new PointDist(q, p.dist));
--[ 2019.11.12.11.30.20.579.0 ]--
r 37             pq.insert(new PointDist(q, p.dist()));
--[ 2019.11.12.11.30.20.756.0 ]--
r 37             pq.insert(new PointDist(q, p.dist(q)));
--[ 2019.11.12.11.30.26.324.0 ]--
- 38
- 38
r 38             
--[ 2019.11.12.11.30.26.644.0 ]--
- 38
--[ 2019.11.12.11.30.28.962.0 ]--
r 39         return p;
--[ 2019.11.12.11.30.29.071.0 ]--
r 39         return pq;
--[ 2019.11.12.11.30.29.179.0 ]--
r 39         return pq.;
--[ 2019.11.12.11.30.29.478.0 ]--
r 39         return pq.m;
--[ 2019.11.12.11.30.29.633.0 ]--
r 39         return pq.mi;
--[ 2019.11.12.11.30.29.673.0 ]--
r 39         return pq.min;
--[ 2019.11.12.11.30.30.004.0 ]--
r 39         return pq.min();
--[ 2019.11.12.11.30.35.996.0 ]--
r 39         return pq.min().;
--[ 2019.11.12.11.30.36.953.0 ]--
r 39         return pq.min();
--[ 2019.11.12.11.30.37.084.0 ]--
r 39         return pq.min(;
--[ 2019.11.12.11.30.37.205.0 ]--
r 39         return pq.min;
--[ 2019.11.12.11.30.37.325.0 ]--
r 39         return pq.mi;
--[ 2019.11.12.11.30.37.455.0 ]--
r 39         return pq.m;
--[ 2019.11.12.11.30.37.599.0 ]--
r 39         return pq.;
--[ 2019.11.12.11.30.37.764.0 ]--
r 39         return pq;
--[ 2019.11.12.11.30.37.895.0 ]--
r 39         return p;
--[ 2019.11.12.11.30.37.998.0 ]--
r 39         return ;
--[ 2019.11.12.11.30.38.265.0 ]--
r 39         return m;
--[ 2019.11.12.11.30.38.364.0 ]--
r 39         return mi;
--[ 2019.11.12.11.30.38.415.0 ]--
r 39         return min;
--[ 2019.11.12.11.30.38.570.0 ]--
r 39         return min ;
--[ 2019.11.12.11.30.38.658.0 ]--
r 39         return min;
--[ 2019.11.12.11.30.57.575.0 ]--
+ 38             
--[ 2019.11.12.11.30.57.781.0 ]--
r 38             i
--[ 2019.11.12.11.30.57.881.0 ]--
r 38             if
--[ 2019.11.12.11.30.58.156.0 ]--
r 38             if()
--[ 2019.11.12.11.30.59.797.0 ]--
r 38             if( )
--[ 2019.11.12.11.30.59.865.0 ]--
r 38             if()
--[ 2019.11.12.11.31.00.016.0 ]--
r 38             if(q)
--[ 2019.11.12.11.31.00.959.0 ]--
r 38             if()
--[ 2019.11.12.11.31.02.619.0 ]--
r 38             
--[ 2019.11.12.11.31.02.849.0 ]--
- 38
--[ 2019.11.12.11.31.03.204.0 ]--
r 37             pq.insert(new PointDist(q, p.dist(q))); 
--[ 2019.11.12.11.31.03.259.0 ]--
r 37             pq.insert(new PointDist(q, p.dist(q)));
--[ 2019.11.12.11.31.06.674.0 ]--
- 35
- 35
- 35
r 35 
--[ 2019.11.12.11.31.07.034.0 ]--
- 35
--[ 2019.11.12.11.31.13.313.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.36.35.239.0 ]--
r 35         return n;
--[ 2019.11.12.11.36.35.274.0 ]--
r 35         return nu;
--[ 2019.11.12.11.36.35.494.0 ]--
r 35         return nul;
--[ 2019.11.12.11.36.35.627.0 ]--
r 35         return null;
--[ 2019.11.12.11.36.44.468.0 ]--
r 40         return n;
--[ 2019.11.12.11.36.44.594.0 ]--
r 40         return ne;
--[ 2019.11.12.11.36.44.636.0 ]--
r 40         return nea;
--[ 2019.11.12.11.36.44.719.0 ]--
r 40         return near;
--[ 2019.11.12.11.36.45.087.0 ]--
r 40         return neart;
--[ 2019.11.12.11.36.45.147.0 ]--
r 40         return nearte;
--[ 2019.11.12.11.36.45.306.0 ]--
r 40         return neartes;
--[ 2019.11.12.11.36.45.419.0 ]--
r 40         return neartest;
--[ 2019.11.12.11.36.45.863.0 ]--
r 40         return neartes;
--[ 2019.11.12.11.36.46.062.0 ]--
r 40         return nearte;
--[ 2019.11.12.11.36.46.400.0 ]--
r 40         return neart;
--[ 2019.11.12.11.36.46.589.0 ]--
r 40         return near;
--[ 2019.11.12.11.36.47.162.0 ]--
r 40         return neare;
--[ 2019.11.12.11.36.47.348.0 ]--
r 40         return neares;
--[ 2019.11.12.11.36.47.446.0 ]--
r 40         return nearest;
--[ 2019.11.12.11.36.47.658.0 ]--
r 40         return nearest();
--[ 2019.11.12.11.36.47.906.0 ]--
r 40         return nearest().;
--[ 2019.11.12.11.36.48.768.0 ]--
r 40         return nearest();
--[ 2019.11.12.11.36.49.709.0 ]--
r 40         return nearest(;
--[ 2019.11.12.11.36.50.207.0 ]--
r 40         return nearest().;
--[ 2019.11.12.11.36.50.401.0 ]--
r 40         return near;
--[ 2019.11.12.11.36.50.560.0 ]--
r 40         return neartest;
--[ 2019.11.12.11.36.50.896.0 ]--
r 40         return null;
--[ 2019.11.12.11.36.53.241.0 ]--
r 40         return p;
--[ 2019.11.12.11.36.53.435.0 ]--
r 40         return p.;
--[ 2019.11.12.11.36.53.886.0 ]--
r 40         return p.n;
--[ 2019.11.12.11.36.53.951.0 ]--
r 40         return p.ne;
--[ 2019.11.12.11.36.53.986.0 ]--
r 40         return p.nea;
--[ 2019.11.12.11.36.54.093.0 ]--
r 40         return p.near;
--[ 2019.11.12.11.36.55.092.0 ]--
r 40         return p.;
--[ 2019.11.12.11.36.55.693.0 ]--
r 40         return p;
--[ 2019.11.12.11.36.55.934.0 ]--
r 40         return p.;
--[ 2019.11.12.11.36.59.899.0 ]--
r 40         return p;
--[ 2019.11.12.11.37.00.045.0 ]--
r 40         return ;
--[ 2019.11.12.11.37.00.762.0 ]--
r 40         return n;
--[ 2019.11.12.11.37.00.942.0 ]--
r 40         return nu;
--[ 2019.11.12.11.37.01.146.0 ]--
r 40         return nul;
--[ 2019.11.12.11.37.01.294.0 ]--
r 40         return null;
--[ 2019.11.12.11.37.03.451.0 ]--
r 40         return null ;
--[ 2019.11.12.11.37.03.541.0 ]--
r 40         return null;
--[ 2019.11.12.11.42.05.697.0 ]--
+ 35         
--[ 2019.11.12.11.42.06.961.0 ]--
r 35         f
--[ 2019.11.12.11.42.07.097.0 ]--
r 35         fo
--[ 2019.11.12.11.42.07.214.0 ]--
r 35         for
--[ 2019.11.12.11.42.08.395.0 ]--
r 35         for()
--[ 2019.11.12.11.42.08.584.0 ]--
r 35         for(p)
--[ 2019.11.12.11.42.08.884.0 ]--
r 35         for(pi)
--[ 2019.11.12.11.42.09.179.0 ]--
r 35         for(p)
--[ 2019.11.12.11.42.09.306.0 ]--
r 35         for(po)
--[ 2019.11.12.11.42.09.459.0 ]--
r 35         for(poi)
--[ 2019.11.12.11.42.09.514.0 ]--
r 35         for(poin)
--[ 2019.11.12.11.42.09.714.0 ]--
r 35         for(poi)
--[ 2019.11.12.11.42.09.834.0 ]--
r 35         for(po)
--[ 2019.11.12.11.42.09.947.0 ]--
r 35         for(p)
--[ 2019.11.12.11.42.10.052.0 ]--
r 35         for()
--[ 2019.11.12.11.42.10.220.0 ]--
r 35         for(P)
--[ 2019.11.12.11.42.10.389.0 ]--
r 35         for(Po)
--[ 2019.11.12.11.42.10.577.0 ]--
r 35         for(Poi)
--[ 2019.11.12.11.42.10.749.0 ]--
r 35         for(Poin)
--[ 2019.11.12.11.42.10.853.0 ]--
r 35         for(Point)
--[ 2019.11.12.11.42.10.933.0 ]--
r 35         for(Point )
--[ 2019.11.12.11.42.11.056.0 ]--
r 35         for(Point q)
--[ 2019.11.12.11.42.11.478.0 ]--
r 35         for(Point q:)
--[ 2019.11.12.11.42.11.676.0 ]--
r 35         for(Point q: )
--[ 2019.11.12.11.42.12.252.0 ]--
r 35         for(Point q:)
--[ 2019.11.12.11.42.12.337.0 ]--
r 35         for(Point q)
--[ 2019.11.12.11.42.12.460.0 ]--
r 35         for(Point q )
--[ 2019.11.12.11.42.12.543.0 ]--
r 35         for(Point q :)
--[ 2019.11.12.11.42.12.640.0 ]--
r 35         for(Point q : )
--[ 2019.11.12.11.42.15.544.0 ]--
r 35         for(Point q : p)
--[ 2019.11.12.11.42.15.824.0 ]--
r 35         for(Point q : pi)
--[ 2019.11.12.11.42.15.890.0 ]--
r 35         for(Point q : pin)
--[ 2019.11.12.11.42.15.968.0 ]--
r 35         for(Point q : pint)
--[ 2019.11.12.11.42.16.296.0 ]--
r 35         for(Point q : pin)
--[ 2019.11.12.11.42.16.392.0 ]--
r 35         for(Point q : pi)
--[ 2019.11.12.11.42.16.515.0 ]--
r 35         for(Point q : p)
--[ 2019.11.12.11.42.16.664.0 ]--
r 35         for(Point q : po)
--[ 2019.11.12.11.42.16.834.0 ]--
r 35         for(Point q : poi)
--[ 2019.11.12.11.42.16.898.0 ]--
r 35         for(Point q : poin)
--[ 2019.11.12.11.42.16.985.0 ]--
r 35         for(Point q : point)
--[ 2019.11.12.11.42.17.042.0 ]--
r 35         for(Point q : points)
--[ 2019.11.12.11.42.17.281.0 ]--
r 35         for(Point q : points())
--[ 2019.11.12.11.42.17.360.0 ]--
r 35         for(Point q : points(0))
--[ 2019.11.12.11.42.17.738.0 ]--
r 35         for(Point q : points(0 ))
--[ 2019.11.12.11.42.17.791.0 ]--
r 35         for(Point q : points(0))
--[ 2019.11.12.11.42.18.023.0 ]--
r 35         for(Point q : points())
--[ 2019.11.12.11.42.19.127.0 ]--
r 35         for(Point q : points()){
--[ 2019.11.12.11.42.19.348.0 ]--
+ 36 
+ 37 }
--[ 2019.11.12.11.42.19.385.0 ]--
r 37         }
--[ 2019.11.12.11.42.19.405.0 ]--
r 36             
--[ 2019.11.12.11.42.20.506.0 ]--
r 36             i
--[ 2019.11.12.11.42.20.576.0 ]--
r 36             if
--[ 2019.11.12.11.42.20.813.0 ]--
r 36             if()
--[ 2019.11.12.11.42.22.600.0 ]--
r 36             if(q)
--[ 2019.11.12.11.42.22.664.0 ]--
r 36             if(q.)
--[ 2019.11.12.11.42.22.826.0 ]--
r 36             if(q.c)
--[ 2019.11.12.11.42.22.929.0 ]--
r 36             if(q.co)
--[ 2019.11.12.11.42.22.981.0 ]--
r 36             if(q.com)
--[ 2019.11.12.11.42.23.336.0 ]--
r 36             if(q.compareTo)
--[ 2019.11.12.11.42.23.342.0 ]--
r 36             if(q.compareTo())
--[ 2019.11.12.11.42.24.272.0 ]--
r 36             if(q.compareTo(p))
--[ 2019.11.12.11.42.25.564.0 ]--
r 36             if(q.compareTo(p) )
--[ 2019.11.12.11.42.25.657.0 ]--
r 36             if(q.compareTo(p) <)
--[ 2019.11.12.11.42.25.743.0 ]--
r 36             if(q.compareTo(p) < )
--[ 2019.11.12.11.42.26.112.0 ]--
r 36             if(q.compareTo(p) < 0)
--[ 2019.11.12.11.42.26.865.0 ]--
r 36             if(q.compareTo(p) < 0){
--[ 2019.11.12.11.42.27.084.0 ]--
+ 37 
+ 38 }
--[ 2019.11.12.11.42.27.097.0 ]--
r 38             }
--[ 2019.11.12.11.42.27.115.0 ]--
r 37                 
--[ 2019.11.12.11.42.28.519.0 ]--
r 37                 ,
--[ 2019.11.12.11.42.28.769.0 ]--
r 37                 
--[ 2019.11.12.11.42.28.919.0 ]--
r 37                 m
--[ 2019.11.12.11.42.29.004.0 ]--
r 37                 mi
--[ 2019.11.12.11.42.29.082.0 ]--
r 37                 min
--[ 2019.11.12.11.42.29.205.0 ]--
r 37                 min 
--[ 2019.11.12.11.42.29.318.0 ]--
r 37                 min =
--[ 2019.11.12.11.42.29.412.0 ]--
r 37                 min = 
--[ 2019.11.12.11.42.30.192.0 ]--
r 37                 min = q
--[ 2019.11.12.11.42.32.045.0 ]--
r 37                 min = q 
--[ 2019.11.12.11.42.32.105.0 ]--
r 37                 min = q
--[ 2019.11.12.11.42.32.246.0 ]--
r 37                 min = q;
--[ 2019.11.12.11.42.34.224.0 ]--
r 40         return nul;
--[ 2019.11.12.11.42.34.346.0 ]--
r 40         return nu;
--[ 2019.11.12.11.42.34.449.0 ]--
r 40         return n;
--[ 2019.11.12.11.42.34.740.0 ]--
r 40         return ;
--[ 2019.11.12.11.42.35.276.0 ]--
r 40         return m;
--[ 2019.11.12.11.42.35.346.0 ]--
r 40         return mi;
--[ 2019.11.12.11.42.35.418.0 ]--
r 40         return min;
--[ 2019.11.12.11.42.39.247.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.43.18.299.0 ]--
+ 35         
--[ 2019.11.12.11.43.18.788.0 ]--
+ 35         
--[ 2019.11.12.11.43.19.103.0 ]--
r 36         /
--[ 2019.11.12.11.43.19.207.0 ]--
r 36         //
--[ 2019.11.12.11.43.19.479.0 ]--
r 36         //D
--[ 2019.11.12.11.43.19.520.0 ]--
r 36         //Do
--[ 2019.11.12.11.43.19.660.0 ]--
r 36         //Doe
--[ 2019.11.12.11.43.19.806.0 ]--
r 36         //Does
--[ 2019.11.12.11.43.19.847.0 ]--
r 36         //Doesn
--[ 2019.11.12.11.43.20.004.0 ]--
r 36         //Doesn'
--[ 2019.11.12.11.43.20.066.0 ]--
r 36         //Doesn't
--[ 2019.11.12.11.43.20.167.0 ]--
r 36         //Doesn't 
--[ 2019.11.12.11.43.20.223.0 ]--
r 36         //Doesn't w
--[ 2019.11.12.11.43.20.315.0 ]--
r 36         //Doesn't wo
--[ 2019.11.12.11.43.20.376.0 ]--
r 36         //Doesn't wor
--[ 2019.11.12.11.43.20.445.0 ]--
r 36         //Doesn't work
--[ 2019.11.12.11.43.20.543.0 ]--
r 36         //Doesn't work 
--[ 2019.11.12.11.43.20.623.0 ]--
r 36         //Doesn't work p
--[ 2019.11.12.11.43.20.703.0 ]--
r 36         //Doesn't work pr
--[ 2019.11.12.11.43.20.801.0 ]--
r 36         //Doesn't work pro
--[ 2019.11.12.11.43.20.960.0 ]--
r 36         //Doesn't work prop
--[ 2019.11.12.11.43.21.060.0 ]--
r 36         //Doesn't work prope
--[ 2019.11.12.11.43.21.093.0 ]--
r 36         //Doesn't work proper
--[ 2019.11.12.11.43.21.208.0 ]--
r 36         //Doesn't work properl
--[ 2019.11.12.11.43.21.306.0 ]--
r 36         //Doesn't work properly
--[ 2019.11.12.11.43.21.407.0 ]--
r 36         //Doesn't work properly,
--[ 2019.11.12.11.43.21.681.0 ]--
r 36         //Doesn't work properly, 
--[ 2019.11.12.11.43.21.956.0 ]--
r 36         //Doesn't work properly, o
--[ 2019.11.12.11.43.22.044.0 ]--
r 36         //Doesn't work properly, on
--[ 2019.11.12.11.43.22.130.0 ]--
r 36         //Doesn't work properly, onl
--[ 2019.11.12.11.43.22.227.0 ]--
r 36         //Doesn't work properly, only
--[ 2019.11.12.11.43.22.313.0 ]--
r 36         //Doesn't work properly, only 
--[ 2019.11.12.11.43.25.855.0 ]--
r 36         //Doesn't work properly, 
--[ 2019.11.12.11.43.26.181.0 ]--
r 36         //Doesn't work properly, b
--[ 2019.11.12.11.43.26.315.0 ]--
r 36         //Doesn't work properly, bu
--[ 2019.11.12.11.43.26.402.0 ]--
r 36         //Doesn't work properly, but
--[ 2019.11.12.11.43.26.529.0 ]--
r 36         //Doesn't work properly, but 
--[ 2019.11.12.11.43.26.655.0 ]--
r 36         //Doesn't work properly, but a
--[ 2019.11.12.11.43.26.919.0 ]--
r 36         //Doesn't work properly, but at
--[ 2019.11.12.11.43.27.060.0 ]--
r 36         //Doesn't work properly, but at 
--[ 2019.11.12.11.43.27.174.0 ]--
r 36         //Doesn't work properly, but at l
--[ 2019.11.12.11.43.27.220.0 ]--
r 36         //Doesn't work properly, but at le
--[ 2019.11.12.11.43.27.276.0 ]--
r 36         //Doesn't work properly, but at lea
--[ 2019.11.12.11.43.27.407.0 ]--
r 36         //Doesn't work properly, but at leas
--[ 2019.11.12.11.43.27.757.0 ]--
r 36         //Doesn't work properly, but at least
--[ 2019.11.12.11.43.27.857.0 ]--
r 36         //Doesn't work properly, but at least 
--[ 2019.11.12.11.43.27.973.0 ]--
r 36         //Doesn't work properly, but at least d
--[ 2019.11.12.11.43.28.110.0 ]--
r 36         //Doesn't work properly, but at least dr
--[ 2019.11.12.11.43.28.184.0 ]--
r 36         //Doesn't work properly, but at least dra
--[ 2019.11.12.11.43.28.673.0 ]--
r 36         //Doesn't work properly, but at least draw
--[ 2019.11.12.11.43.28.823.0 ]--
r 36         //Doesn't work properly, but at least draws
--[ 2019.11.12.11.43.28.935.0 ]--
r 36         //Doesn't work properly, but at least draws 
--[ 2019.11.12.11.43.28.977.0 ]--
r 36         //Doesn't work properly, but at least draws s
--[ 2019.11.12.11.43.29.055.0 ]--
r 36         //Doesn't work properly, but at least draws so
--[ 2019.11.12.11.43.29.089.0 ]--
r 36         //Doesn't work properly, but at least draws som
--[ 2019.11.12.11.43.29.135.0 ]--
r 36         //Doesn't work properly, but at least draws some
--[ 2019.11.12.11.43.29.247.0 ]--
r 36         //Doesn't work properly, but at least draws somet
--[ 2019.11.12.11.43.29.319.0 ]--
r 36         //Doesn't work properly, but at least draws someth
--[ 2019.11.12.11.43.29.384.0 ]--
r 36         //Doesn't work properly, but at least draws somethi
--[ 2019.11.12.11.43.29.471.0 ]--
r 36         //Doesn't work properly, but at least draws somethin
--[ 2019.11.12.11.43.29.508.0 ]--
r 36         //Doesn't work properly, but at least draws something
--[ 2019.11.12.11.43.29.567.0 ]--
r 36         //Doesn't work properly, but at least draws something 
--[ 2019.11.12.11.43.29.654.0 ]--
r 36         //Doesn't work properly, but at least draws something o
--[ 2019.11.12.11.43.29.661.0 ]--
r 36         //Doesn't work properly, but at least draws something on
--[ 2019.11.12.11.43.29.728.0 ]--
r 36         //Doesn't work properly, but at least draws something on 
--[ 2019.11.12.11.43.29.775.0 ]--
r 36         //Doesn't work properly, but at least draws something on t
--[ 2019.11.12.11.43.29.847.0 ]--
r 36         //Doesn't work properly, but at least draws something on th
--[ 2019.11.12.11.43.29.941.0 ]--
r 36         //Doesn't work properly, but at least draws something on the
--[ 2019.11.12.11.43.29.985.0 ]--
r 36         //Doesn't work properly, but at least draws something on the 
--[ 2019.11.12.11.43.30.605.0 ]--
r 36         //Doesn't work properly, but at least draws something on the b
--[ 2019.11.12.11.43.30.674.0 ]--
r 36         //Doesn't work properly, but at least draws something on the bo
--[ 2019.11.12.11.43.30.798.0 ]--
r 36         //Doesn't work properly, but at least draws something on the boa
--[ 2019.11.12.11.43.30.827.0 ]--
r 36         //Doesn't work properly, but at least draws something on the boar
--[ 2019.11.12.11.43.31.072.0 ]--
r 36         //Doesn't work properly, but at least draws something on the board
--[ 2019.11.12.11.43.31.644.0 ]--
r 36         //Doesn't work properly, but at least draws something on the board 
--[ 2019.11.12.11.43.31.755.0 ]--
r 36         //Doesn't work properly, but at least draws something on the board
--[ 2019.11.12.11.43.32.015.0 ]--
r 36         //Doesn't work properly, but at least draws something on the 
--[ 2019.11.12.11.43.32.170.0 ]--
r 36         //Doesn't work properly, but at least draws something on 
--[ 2019.11.12.11.43.32.339.0 ]--
r 36         //Doesn't work properly, but at least draws something 
--[ 2019.11.12.11.43.32.522.0 ]--
r 36         //Doesn't work properly, but at least draws 
--[ 2019.11.12.11.43.34.895.0 ]--
r 36         //Doesn't work properly, but at least draws s
--[ 2019.11.12.11.43.34.981.0 ]--
r 36         //Doesn't work properly, but at least draws so
--[ 2019.11.12.11.43.35.007.0 ]--
r 36         //Doesn't work properly, but at least draws som
--[ 2019.11.12.11.43.35.064.0 ]--
r 36         //Doesn't work properly, but at least draws some
--[ 2019.11.12.11.43.35.152.0 ]--
r 36         //Doesn't work properly, but at least draws somet
--[ 2019.11.12.11.43.35.243.0 ]--
r 36         //Doesn't work properly, but at least draws someth
--[ 2019.11.12.11.43.35.287.0 ]--
r 36         //Doesn't work properly, but at least draws somethi
--[ 2019.11.12.11.43.35.351.0 ]--
r 36         //Doesn't work properly, but at least draws somethin
--[ 2019.11.12.11.43.35.672.0 ]--
r 36         //Doesn't work properly, but at least draws something
--[ 2019.11.12.11.43.35.812.0 ]--
r 36         //Doesn't work properly, but at least draws something 
--[ 2019.11.12.11.43.36.180.0 ]--
r 36         //Doesn't work properly, but at least draws something t
--[ 2019.11.12.11.43.36.284.0 ]--
r 36         //Doesn't work properly, but at least draws something to
--[ 2019.11.12.11.43.36.444.0 ]--
r 36         //Doesn't work properly, but at least draws something to 
--[ 2019.11.12.11.43.36.848.0 ]--
r 36         //Doesn't work properly, but at least draws something to b
--[ 2019.11.12.11.43.36.896.0 ]--
r 36         //Doesn't work properly, but at least draws something to be
--[ 2019.11.12.11.43.37.035.0 ]--
r 36         //Doesn't work properly, but at least draws something to be 
--[ 2019.11.12.11.43.37.112.0 ]--
r 36         //Doesn't work properly, but at least draws something to be v
--[ 2019.11.12.11.43.37.240.0 ]--
r 36         //Doesn't work properly, but at least draws something to be vi
--[ 2019.11.12.11.43.37.332.0 ]--
r 36         //Doesn't work properly, but at least draws something to be vis
--[ 2019.11.12.11.43.37.396.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visu
--[ 2019.11.12.11.43.37.519.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visua
--[ 2019.11.12.11.43.38.571.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visual
--[ 2019.11.12.11.43.38.775.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualz
--[ 2019.11.12.11.43.39.032.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visual
--[ 2019.11.12.11.43.39.175.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visuali
--[ 2019.11.12.11.43.39.541.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualie
--[ 2019.11.12.11.43.39.663.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualied
--[ 2019.11.12.11.43.39.891.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualie
--[ 2019.11.12.11.43.40.003.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visuali
--[ 2019.11.12.11.43.40.059.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualiz
--[ 2019.11.12.11.43.40.243.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualize
--[ 2019.11.12.11.43.40.371.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualized
--[ 2019.11.12.11.43.40.960.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualized 
--[ 2019.11.12.11.43.41.032.0 ]--
r 36         //Doesn't work properly, but at least draws something to be visualized
--[ 2019.11.12.11.43.44.654.0 ]--
r 35 
--[ 2019.11.12.11.43.45.751.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.43.58.104.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.44.01.871.0 ]--
r 36         //Doesn't work properly, but at least g something to be visualized
--[ 2019.11.12.11.44.02.026.0 ]--
r 36         //Doesn't work properly, but at least go something to be visualized
--[ 2019.11.12.11.44.02.105.0 ]--
r 36         //Doesn't work properly, but at least gov something to be visualized
--[ 2019.11.12.11.44.02.169.0 ]--
r 36         //Doesn't work properly, but at least gove something to be visualized
--[ 2019.11.12.11.44.02.331.0 ]--
r 36         //Doesn't work properly, but at least goves something to be visualized
--[ 2019.11.12.11.44.02.810.0 ]--
r 36         //Doesn't work properly, but at least gove something to be visualized
--[ 2019.11.12.11.44.02.939.0 ]--
r 36         //Doesn't work properly, but at least gov something to be visualized
--[ 2019.11.12.11.44.03.041.0 ]--
r 36         //Doesn't work properly, but at least go something to be visualized
--[ 2019.11.12.11.44.03.160.0 ]--
r 36         //Doesn't work properly, but at least g something to be visualized
--[ 2019.11.12.11.44.03.339.0 ]--
r 36         //Doesn't work properly, but at least gi something to be visualized
--[ 2019.11.12.11.44.03.433.0 ]--
r 36         //Doesn't work properly, but at least giv something to be visualized
--[ 2019.11.12.11.44.03.483.0 ]--
r 36         //Doesn't work properly, but at least give something to be visualized
--[ 2019.11.12.11.44.03.650.0 ]--
r 36         //Doesn't work properly, but at least gives something to be visualized
--[ 2019.11.12.11.44.03.823.0 ]--
r 36         //Doesn't work properly, but at least gives  something to be visualized
--[ 2019.11.12.11.44.03.911.0 ]--
r 36         //Doesn't work properly, but at least gives something to be visualized
--[ 2019.11.12.11.44.06.329.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.12.11.44.19.781.0 ]--
DisposeComponent
--[ 2019.11.19.14.26.18.412.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.19.14.26.18.565.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.19.14.26.18.568.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.19.14.26.18.570.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.19.14.26.18.585.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.19.14.26.18.596.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.19.14.26.18.599.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.19.14.26.18.604.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.19.14.26.18.635.0 ]--
InitFile: /.cos265


--[ 2019.11.19.14.26.18.648.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.19.14.26.18.659.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.19.14.26.18.664.0 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        //Doesn't work properly, but at least gives something to be visualized
        for(Point q : points()){
            if(q.compareTo(p) < 0){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return rbTree.min();
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return rbTree.max();
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.19.14.26.18.667.0 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.19.14.26.18.682.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.19.14.26.18.705.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.19.14.37.33.892.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.44.20.215.0 ]--
:/src/PSBruteForce.java
+ 42         
--[ 2019.11.19.14.44.22.276.0 ]--
- 42
--[ 2019.11.19.14.44.30.377.0 ]--
r 38             if(q..(p) < 0){
--[ 2019.11.19.14.44.30.562.0 ]--
r 38             if(q..d(p) < 0){
--[ 2019.11.19.14.44.30.692.0 ]--
r 38             if(q..di(p) < 0){
--[ 2019.11.19.14.44.30.815.0 ]--
r 38             if(q..dis(p) < 0){
--[ 2019.11.19.14.44.31.002.0 ]--
r 38             if(q..di(p) < 0){
--[ 2019.11.19.14.44.31.098.0 ]--
r 38             if(q..d(p) < 0){
--[ 2019.11.19.14.44.31.194.0 ]--
r 38             if(q..(p) < 0){
--[ 2019.11.19.14.44.31.322.0 ]--
r 38             if(q.(p) < 0){
--[ 2019.11.19.14.44.31.478.0 ]--
r 38             if(q.d(p) < 0){
--[ 2019.11.19.14.44.31.525.0 ]--
r 38             if(q.di(p) < 0){
--[ 2019.11.19.14.44.31.622.0 ]--
r 38             if(q.dis(p) < 0){
--[ 2019.11.19.14.44.31.786.0 ]--
r 38             if(q.dist(p) < 0){
--[ 2019.11.19.14.44.32.250.0 ]--
r 38             if(q.dist (p) < 0){
--[ 2019.11.19.14.44.32.298.0 ]--
r 38             if(q.dist(p) < 0){
--[ 2019.11.19.14.44.38.900.0 ]--
r 38             if(q.dist(p) >){
--[ 2019.11.19.14.44.39.668.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.44.40.246.0 ]--
r 38             if(q.dist(p) > p){
--[ 2019.11.19.14.44.40.402.0 ]--
r 38             if(q.dist(p) > p.){
--[ 2019.11.19.14.44.41.035.0 ]--
r 38             if(q.dist(p) > p.d){
--[ 2019.11.19.14.44.41.146.0 ]--
r 38             if(q.dist(p) > p.di){
--[ 2019.11.19.14.44.41.472.0 ]--
r 38             if(q.dist(p) > p.dist){
--[ 2019.11.19.14.44.41.485.0 ]--
r 38             if(q.dist(p) > p.dist()){
--[ 2019.11.19.14.44.42.119.0 ]--
r 38             if(q.dist(p) > p.dist(q)){
--[ 2019.11.19.14.44.46.322.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.44.52.031.0 ]--
r 38             if(q.dist(p) > p){
--[ 2019.11.19.14.44.52.147.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.45.17.342.0 ]--
r 38             if(q.dist(p) > p){
--[ 2019.11.19.14.45.19.583.0 ]--
r 38             if(q.dist(p) > p){ 
--[ 2019.11.19.14.45.19.637.0 ]--
r 38             if(q.dist(p) > p){
--[ 2019.11.19.14.45.20.933.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.47.09.302.0 ]--
r 38             if(q.dist(p) > 0){
--[ 2019.11.19.14.47.10.663.0 ]--
r 38             if(q.dist(p) > 0 ){
--[ 2019.11.19.14.47.10.732.0 ]--
r 38             if(q.dist(p) > 0){
--[ 2019.11.19.14.47.13.215.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.47.43.769.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.47.43.844.0 ]--
r 38             if(q.dist(p) > 1){
--[ 2019.11.19.14.47.46.293.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.47.49.883.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.47.49.949.0 ]--
r 38             if(q.dist(p) > 5){
--[ 2019.11.19.14.47.52.152.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.47.57.643.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.47.57.730.0 ]--
r 38             if(q.dist(p) > 2){
--[ 2019.11.19.14.48.00.064.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.48.02.699.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.48.04.708.0 ]--
r 38             if(q.dist(p) >  ){
--[ 2019.11.19.14.48.04.788.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.48.05.989.0 ]--
r 38             if(q.dist(p) > 0){
--[ 2019.11.19.14.48.06.788.0 ]--
r 38             if(q.dist(p) > 0 ){
--[ 2019.11.19.14.48.07.594.0 ]--
r 38             if(q.dist(p) > 0){
--[ 2019.11.19.14.48.32.307.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.49.42.636.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.49.56.634.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.50.19.773.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.50.22.840.0 ]--
r 38             if(q.dist(p) > 1){
--[ 2019.11.19.14.50.25.635.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.50.36.883.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.51.08.606.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.51.08.655.0 ]--
r 38             if(q.dist(p) > 0){
--[ 2019.11.19.14.51.37.942.0 ]--
r 38             if(q.dist(p) > ){
--[ 2019.11.19.14.52.02.220.0 ]--
- 35
--[ 2019.11.19.14.52.02.428.0 ]--
+ 35         
--[ 2019.11.19.14.52.03.048.0 ]--
+ 35         
--[ 2019.11.19.14.53.17.530.0 ]--
r 39             if(q.dist(p) >  ){
--[ 2019.11.19.14.53.17.588.0 ]--
r 39             if(q.dist(p) > 0 ){
--[ 2019.11.19.14.53.19.115.0 ]--
r 39             if(q.dist(p) > 0){
--[ 2019.11.19.14.53.20.008.0 ]--
r 35 
r 36 
--[ 2019.11.19.14.53.21.129.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.54.04.521.0 ]--
- 39
- 39
r 39             
--[ 2019.11.19.14.54.04.733.0 ]--
- 39
--[ 2019.11.19.14.54.05.241.0 ]--
+ 39             
--[ 2019.11.19.14.54.06.273.0 ]--
- 39
--[ 2019.11.19.14.54.06.424.0 ]--
+ 39             if(q.dist(p) > 0){
+ 40                 min = q;
+ 41             }
--[ 2019.11.19.14.54.29.260.0 ]--
r 36     
--[ 2019.11.19.14.54.29.366.0 ]--
r 36         
--[ 2019.11.19.14.54.38.029.0 ]--
r 36         p
--[ 2019.11.19.14.54.38.139.0 ]--
r 36         p.
--[ 2019.11.19.14.54.38.550.0 ]--
r 36         p.d
--[ 2019.11.19.14.54.38.609.0 ]--
r 36         p.di
--[ 2019.11.19.14.54.38.671.0 ]--
r 36         p.dis
--[ 2019.11.19.14.54.38.845.0 ]--
r 36         p.dist
--[ 2019.11.19.14.54.39.364.0 ]--
r 36         p.dist()
--[ 2019.11.19.14.54.39.787.0 ]--
r 36         p.dist(p)
--[ 2019.11.19.14.54.40.186.0 ]--
r 36         p.dist(p);
--[ 2019.11.19.14.54.42.916.0 ]--
r 36         p.dist(p)
--[ 2019.11.19.14.54.43.048.0 ]--
r 36         p.dist(p
--[ 2019.11.19.14.54.43.172.0 ]--
r 36         p.dist(
--[ 2019.11.19.14.54.43.298.0 ]--
r 36         p.dist
--[ 2019.11.19.14.54.43.424.0 ]--
r 36         p.dis
--[ 2019.11.19.14.54.43.522.0 ]--
r 36         p.di
--[ 2019.11.19.14.54.43.683.0 ]--
r 36         p.d
--[ 2019.11.19.14.54.43.818.0 ]--
r 36         p.
--[ 2019.11.19.14.54.43.938.0 ]--
r 36         p
--[ 2019.11.19.14.54.44.067.0 ]--
r 36         
--[ 2019.11.19.14.55.05.724.0 ]--
r 36         m
--[ 2019.11.19.14.55.05.811.0 ]--
r 36         mi
--[ 2019.11.19.14.55.05.869.0 ]--
r 36         min
--[ 2019.11.19.14.55.06.033.0 ]--
r 36         min 
--[ 2019.11.19.14.55.06.106.0 ]--
r 36         min =
--[ 2019.11.19.14.55.07.495.0 ]--
r 36         min = 
--[ 2019.11.19.14.55.11.310.0 ]--
r 36         min = p
--[ 2019.11.19.14.55.11.468.0 ]--
r 36         min = p.
--[ 2019.11.19.14.55.13.204.0 ]--
r 36         min = p.d
--[ 2019.11.19.14.55.13.272.0 ]--
r 36         min = p.di
--[ 2019.11.19.14.55.13.518.0 ]--
r 36         min = p.dis
--[ 2019.11.19.14.55.13.693.0 ]--
r 36         min = p.dist
--[ 2019.11.19.14.55.16.582.0 ]--
r 36         min = p.dis
--[ 2019.11.19.14.55.16.709.0 ]--
r 36         min = p.di
--[ 2019.11.19.14.55.16.893.0 ]--
r 36         min = p.d
--[ 2019.11.19.14.55.17.072.0 ]--
r 36         min = p.
--[ 2019.11.19.14.55.17.229.0 ]--
r 36         min = p
--[ 2019.11.19.14.55.18.178.0 ]--
r 36         min = 
--[ 2019.11.19.14.55.35.355.0 ]--
r 36         min = o
--[ 2019.11.19.14.55.35.485.0 ]--
r 36         min = oi
--[ 2019.11.19.14.55.35.641.0 ]--
r 36         min = oiu
--[ 2019.11.19.14.55.35.683.0 ]--
r 36         min = oiub
--[ 2019.11.19.14.55.35.770.0 ]--
r 36         min = oiubt
--[ 2019.11.19.14.55.36.064.0 ]--
r 36         min = oiub
--[ 2019.11.19.14.55.36.162.0 ]--
r 36         min = oiu
--[ 2019.11.19.14.55.36.227.0 ]--
r 36         min = oi
--[ 2019.11.19.14.55.36.359.0 ]--
r 36         min = o
--[ 2019.11.19.14.55.36.452.0 ]--
r 36         min = 
--[ 2019.11.19.14.55.36.611.0 ]--
r 36         min = p
--[ 2019.11.19.14.55.37.067.0 ]--
r 36         min = po
--[ 2019.11.19.14.55.37.189.0 ]--
r 36         min = poi
--[ 2019.11.19.14.55.37.251.0 ]--
r 36         min = poin
--[ 2019.11.19.14.55.37.298.0 ]--
r 36         min = point
--[ 2019.11.19.14.55.37.364.0 ]--
r 36         min = points
--[ 2019.11.19.14.55.38.168.0 ]--
r 36         min = points()
--[ 2019.11.19.14.55.39.532.0 ]--
r 36         min = points(
--[ 2019.11.19.14.55.39.954.0 ]--
r 36         min = points
--[ 2019.11.19.14.55.40.322.0 ]--
r 36         min = point
--[ 2019.11.19.14.55.40.623.0 ]--
r 36         min = 
--[ 2019.11.19.14.55.48.373.0 ]--
r 36         min = po
--[ 2019.11.19.14.55.48.931.0 ]--
r 36         min = p
--[ 2019.11.19.14.55.49.212.0 ]--
r 36         min = po
--[ 2019.11.19.14.55.49.366.0 ]--
r 36         min = poi
--[ 2019.11.19.14.55.49.411.0 ]--
r 36         min = poin
--[ 2019.11.19.14.55.49.512.0 ]--
r 36         min = point
--[ 2019.11.19.14.55.49.620.0 ]--
r 36         min = points
--[ 2019.11.19.14.55.50.115.0 ]--
r 36         min = points()
--[ 2019.11.19.14.55.50.362.0 ]--
r 36         min = points().
--[ 2019.11.19.14.56.02.043.0 ]--
r 36         min = points()
--[ 2019.11.19.14.56.11.866.0 ]--
r 36         min = points(
--[ 2019.11.19.14.56.12.371.0 ]--
r 36         min = points
--[ 2019.11.19.14.56.12.409.0 ]--
r 36         min = point
--[ 2019.11.19.14.56.12.424.0 ]--
r 36         min = poin
--[ 2019.11.19.14.56.12.459.0 ]--
r 36         min = poi
--[ 2019.11.19.14.56.12.480.0 ]--
r 36         min = po
--[ 2019.11.19.14.56.12.662.0 ]--
r 36         min = p
--[ 2019.11.19.14.56.12.833.0 ]--
r 36         min = 
--[ 2019.11.19.14.56.38.936.0 ]--
r 36         min =
--[ 2019.11.19.14.56.39.225.0 ]--
r 36         min 
--[ 2019.11.19.14.56.39.376.0 ]--
r 36         min
--[ 2019.11.19.14.56.39.550.0 ]--
r 36         mi
--[ 2019.11.19.14.56.39.723.0 ]--
r 36         m
--[ 2019.11.19.14.56.39.848.0 ]--
r 36         
--[ 2019.11.19.14.56.44.514.0 ]--
r 36         m
--[ 2019.11.19.14.56.44.597.0 ]--
r 36         mi
--[ 2019.11.19.14.56.44.659.0 ]--
r 36         min
--[ 2019.11.19.14.56.45.216.0 ]--
r 36         min 
--[ 2019.11.19.14.56.46.572.0 ]--
r 36         min =
--[ 2019.11.19.14.56.46.899.0 ]--
r 36         min = 
--[ 2019.11.19.14.57.50.249.0 ]--
r 36         min = r
--[ 2019.11.19.14.57.50.431.0 ]--
r 36         min = rb
--[ 2019.11.19.14.57.51.158.0 ]--
r 36         min = rbTree
--[ 2019.11.19.14.57.51.279.0 ]--
r 36         min = rbTree.
--[ 2019.11.19.14.58.24.678.0 ]--
r 39             if(q.dist(p) > ){
--[ 2019.11.19.14.58.24.990.0 ]--
r 39             if(q.dist(p) > m){
--[ 2019.11.19.14.58.25.286.0 ]--
r 39             if(q.dist(p) > mi){
--[ 2019.11.19.14.58.25.354.0 ]--
r 39             if(q.dist(p) > min){
--[ 2019.11.19.14.58.27.311.0 ]--
r 39             if(q.dist(p) > min.){
--[ 2019.11.19.14.58.27.517.0 ]--
r 39             if(q.dist(p) > min.g){
--[ 2019.11.19.14.58.27.557.0 ]--
r 39             if(q.dist(p) > min.ge){
--[ 2019.11.19.14.58.27.679.0 ]--
r 39             if(q.dist(p) > min.get){
--[ 2019.11.19.14.58.28.789.0 ]--
r 39             if(q.dist(p) > min.ge){
--[ 2019.11.19.14.58.28.908.0 ]--
r 39             if(q.dist(p) > min.g){
--[ 2019.11.19.14.58.29.010.0 ]--
r 39             if(q.dist(p) > min.){
--[ 2019.11.19.14.58.29.139.0 ]--
r 39             if(q.dist(p) > min.d){
--[ 2019.11.19.14.58.29.212.0 ]--
r 39             if(q.dist(p) > min.di){
--[ 2019.11.19.14.58.29.272.0 ]--
r 39             if(q.dist(p) > min.dis){
--[ 2019.11.19.14.58.29.367.0 ]--
r 39             if(q.dist(p) > min.dist){
--[ 2019.11.19.14.58.29.969.0 ]--
r 39             if(q.dist(p) > min.dist()){
--[ 2019.11.19.14.58.30.148.0 ]--
r 39             if(q.dist(p) > min.dist(p)){
--[ 2019.11.19.14.58.30.883.0 ]--
r 39             if(q.dist(p) > min.dist(p) ){
--[ 2019.11.19.14.58.30.943.0 ]--
r 39             if(q.dist(p) > min.dist(p)){
--[ 2019.11.19.14.58.32.932.0 ]--
r 36         min 
--[ 2019.11.19.14.58.33.082.0 ]--
r 36         min
--[ 2019.11.19.14.58.33.227.0 ]--
r 36         mi
--[ 2019.11.19.14.58.33.342.0 ]--
r 36         m
--[ 2019.11.19.14.58.33.482.0 ]--
r 36         
--[ 2019.11.19.14.58.37.262.0 ]--
r 36          
--[ 2019.11.19.14.58.37.273.0 ]--
r 36         
--[ 2019.11.19.14.58.37.517.0 ]--
r 36         m
--[ 2019.11.19.14.58.37.572.0 ]--
r 36         mi
--[ 2019.11.19.14.58.37.647.0 ]--
r 36         min
--[ 2019.11.19.14.58.37.807.0 ]--
r 36         min 
--[ 2019.11.19.14.58.37.879.0 ]--
r 36         min =
--[ 2019.11.19.14.58.38.845.0 ]--
r 36         min = 
--[ 2019.11.19.14.58.42.070.0 ]--
r 36         min = 0
--[ 2019.11.19.14.58.43.590.0 ]--
r 36         min = 0;
--[ 2019.11.19.14.58.49.693.0 ]--
r 36         min = ;
--[ 2019.11.19.14.58.49.836.0 ]--
r 36         min = p;
--[ 2019.11.19.14.58.51.779.0 ]--
r 36         min = p ;
--[ 2019.11.19.14.58.51.844.0 ]--
r 36         min = p;
--[ 2019.11.19.14.58.56.175.0 ]--
r 36         min = ;
--[ 2019.11.19.14.58.56.504.0 ]--
r 36         min = p;
--[ 2019.11.19.14.58.56.676.0 ]--
r 36         min = po;
--[ 2019.11.19.14.58.56.814.0 ]--
r 36         min = poi;
--[ 2019.11.19.14.58.56.885.0 ]--
r 36         min = poin;
--[ 2019.11.19.14.58.56.949.0 ]--
r 36         min = point;
--[ 2019.11.19.14.58.57.016.0 ]--
r 36         min = points;
--[ 2019.11.19.14.58.57.414.0 ]--
r 36         min = points();
--[ 2019.11.19.14.58.57.757.0 ]--
r 36         min = points()/.;
--[ 2019.11.19.14.58.58.191.0 ]--
r 36         min = points()/;
--[ 2019.11.19.14.58.58.300.0 ]--
r 36         min = points();
--[ 2019.11.19.14.58.58.443.0 ]--
r 36         min = points().;
--[ 2019.11.19.14.58.58.607.0 ]--
r 36         min = points().f;
--[ 2019.11.19.14.59.01.083.0 ]--
r 36         min = points().;
--[ 2019.11.19.14.59.01.691.0 ]--
r 36         min = points(). ;
--[ 2019.11.19.14.59.01.755.0 ]--
r 36         min = points().;
--[ 2019.11.19.14.59.01.955.0 ]--
r 36         min = points();
--[ 2019.11.19.14.59.02.241.0 ]--
r 36         min = points(;
--[ 2019.11.19.14.59.02.376.0 ]--
r 36         min = points;
--[ 2019.11.19.14.59.04.742.0 ]--
r 36         
--[ 2019.11.19.14.59.05.071.0 ]--
r 36         f
--[ 2019.11.19.14.59.05.169.0 ]--
r 36         fo
--[ 2019.11.19.14.59.05.246.0 ]--
r 36         for
--[ 2019.11.19.14.59.05.766.0 ]--
r 36         for()
--[ 2019.11.19.14.59.06.549.0 ]--
r 36         for(p)
--[ 2019.11.19.14.59.06.885.0 ]--
r 36         for(po)
--[ 2019.11.19.14.59.07.081.0 ]--
r 36         for(poi)
--[ 2019.11.19.14.59.07.146.0 ]--
r 36         for(poin)
--[ 2019.11.19.14.59.07.430.0 ]--
r 36         for(poi)
--[ 2019.11.19.14.59.07.536.0 ]--
r 36         for(po)
--[ 2019.11.19.14.59.07.635.0 ]--
r 36         for(p)
--[ 2019.11.19.14.59.08.097.0 ]--
r 36         for()
--[ 2019.11.19.14.59.08.274.0 ]--
r 36         for(P)
--[ 2019.11.19.14.59.08.407.0 ]--
r 36         for(Po)
--[ 2019.11.19.14.59.08.573.0 ]--
r 36         for(Poi)
--[ 2019.11.19.14.59.08.846.0 ]--
r 36         for(Poin)
--[ 2019.11.19.14.59.08.929.0 ]--
r 36         for(Point)
--[ 2019.11.19.14.59.09.046.0 ]--
r 36         for(Point )
--[ 2019.11.19.14.59.09.282.0 ]--
r 36         for(Point q)
--[ 2019.11.19.14.59.09.636.0 ]--
r 36         for(Point q )
--[ 2019.11.19.14.59.09.762.0 ]--
r 36         for(Point q :)
--[ 2019.11.19.14.59.09.860.0 ]--
r 36         for(Point q : )
--[ 2019.11.19.14.59.10.092.0 ]--
r 36         for(Point q : p)
--[ 2019.11.19.14.59.10.271.0 ]--
r 36         for(Point q : po)
--[ 2019.11.19.14.59.11.258.0 ]--
r 36         for(Point q : points)
--[ 2019.11.19.14.59.11.265.0 ]--
r 36         for(Point q : points())
--[ 2019.11.19.14.59.12.217.0 ]--
r 36         for(Point q : points()){
--[ 2019.11.19.14.59.12.403.0 ]--
+ 37 
+ 38 }
--[ 2019.11.19.14.59.12.450.0 ]--
r 38         }
--[ 2019.11.19.14.59.12.470.0 ]--
r 37             
--[ 2019.11.19.14.59.14.130.0 ]--
r 37             m
--[ 2019.11.19.14.59.14.238.0 ]--
r 37             mi
--[ 2019.11.19.14.59.14.338.0 ]--
r 37             min
--[ 2019.11.19.14.59.14.772.0 ]--
r 37             min 
--[ 2019.11.19.14.59.15.011.0 ]--
r 37             min
--[ 2019.11.19.14.59.15.139.0 ]--
r 37             mi
--[ 2019.11.19.14.59.15.283.0 ]--
r 37             m
--[ 2019.11.19.14.59.15.702.0 ]--
r 37             
--[ 2019.11.19.14.59.16.646.0 ]--
r 37              
--[ 2019.11.19.14.59.16.727.0 ]--
r 37             
--[ 2019.11.19.14.59.19.116.0 ]--
r 37             q
--[ 2019.11.19.14.59.19.448.0 ]--
r 37             
--[ 2019.11.19.14.59.20.404.0 ]--
r 37             m
--[ 2019.11.19.14.59.20.507.0 ]--
r 37             mi
--[ 2019.11.19.14.59.20.538.0 ]--
r 37             min
--[ 2019.11.19.14.59.20.699.0 ]--
r 37             min 
--[ 2019.11.19.14.59.20.771.0 ]--
r 37             min =
--[ 2019.11.19.14.59.20.883.0 ]--
r 37             min = 
--[ 2019.11.19.14.59.21.157.0 ]--
r 37             min = q
--[ 2019.11.19.14.59.21.797.0 ]--
r 37             min = q;
--[ 2019.11.19.14.59.22.935.0 ]--
+ 38             
--[ 2019.11.19.14.59.23.214.0 ]--
r 38             b
--[ 2019.11.19.14.59.23.376.0 ]--
r 38             br
--[ 2019.11.19.14.59.23.433.0 ]--
r 38             brae
--[ 2019.11.19.14.59.23.482.0 ]--
r 38             braek
--[ 2019.11.19.14.59.23.695.0 ]--
r 38             braek;
--[ 2019.11.19.14.59.24.052.0 ]--
r 38             braek
--[ 2019.11.19.14.59.24.150.0 ]--
r 38             brae
--[ 2019.11.19.14.59.24.258.0 ]--
r 38             bra
--[ 2019.11.19.14.59.24.385.0 ]--
r 38             br
--[ 2019.11.19.14.59.24.475.0 ]--
r 38             bre
--[ 2019.11.19.14.59.24.505.0 ]--
r 38             brea
--[ 2019.11.19.14.59.24.617.0 ]--
r 38             breal
--[ 2019.11.19.14.59.25.099.0 ]--
r 38             brea
--[ 2019.11.19.14.59.25.342.0 ]--
r 38             break
--[ 2019.11.19.14.59.25.988.0 ]--
r 38             break;
--[ 2019.11.19.14.59.30.468.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.14.59.35.809.0 ]--
r 42             if(q.dist(p)  min.dist(p)){
--[ 2019.11.19.14.59.36.036.0 ]--
r 42             if(q.dist(p) < min.dist(p)){
--[ 2019.11.19.14.59.38.618.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.00.32.781.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.01.04.800.0 ]--
r 51         return n;
--[ 2019.11.19.15.01.04.863.0 ]--
r 51         return ne;
--[ 2019.11.19.15.01.04.908.0 ]--
r 51         return nea;
--[ 2019.11.19.15.01.04.992.0 ]--
r 51         return near;
--[ 2019.11.19.15.01.05.669.0 ]--
r 51         return neart;
--[ 2019.11.19.15.01.05.718.0 ]--
r 51         return nearte;
--[ 2019.11.19.15.01.05.839.0 ]--
r 51         return neartes;
--[ 2019.11.19.15.01.05.942.0 ]--
r 51         return neartest;
--[ 2019.11.19.15.01.06.220.0 ]--
r 51         return neartes;
--[ 2019.11.19.15.01.06.327.0 ]--
r 51         return nearte;
--[ 2019.11.19.15.01.06.430.0 ]--
r 51         return neart;
--[ 2019.11.19.15.01.06.595.0 ]--
r 51         return neart ;
--[ 2019.11.19.15.01.06.743.0 ]--
r 51         return neart;
--[ 2019.11.19.15.01.07.078.0 ]--
r 51         return near;
--[ 2019.11.19.15.01.07.234.0 ]--
r 51         return neare;
--[ 2019.11.19.15.01.07.824.0 ]--
r 51         return nearest;
--[ 2019.11.19.15.01.07.832.0 ]--
r 51         return nearest();
--[ 2019.11.19.15.01.08.428.0 ]--
r 51         return nearest(p);
--[ 2019.11.19.15.01.09.125.0 ]--
r 51         return nearest(p).;
--[ 2019.11.19.15.01.09.300.0 ]--
r 51         return nearest(p).v;
--[ 2019.11.19.15.01.09.952.0 ]--
r 51         return nearest(p).va;
--[ 2019.11.19.15.01.10.288.0 ]--
r 51         return nearest(p).v;
--[ 2019.11.19.15.01.10.330.0 ]--
r 51         return nearest(p).v ;
--[ 2019.11.19.15.01.10.442.0 ]--
r 51         return nearest(p).v;
--[ 2019.11.19.15.01.10.615.0 ]--
r 51         return nearest(p).;
--[ 2019.11.19.15.01.10.886.0 ]--
r 51         return nearest(p);
--[ 2019.11.19.15.01.11.423.0 ]--
r 51         return nearest(p).v ;
--[ 2019.11.19.15.01.11.571.0 ]--
r 51         return nearest(p).v;
--[ 2019.11.19.15.01.11.722.0 ]--
r 51         return nearest(p).va;
--[ 2019.11.19.15.01.11.921.0 ]--
r 51         return nearest();
--[ 2019.11.19.15.01.12.109.0 ]--
r 51         return neare;
--[ 2019.11.19.15.01.12.688.0 ]--
r 51         return near;
--[ 2019.11.19.15.01.12.942.0 ]--
r 51         return neart ;
--[ 2019.11.19.15.01.13.171.0 ]--
r 51         return neart;
--[ 2019.11.19.15.01.13.382.0 ]--
r 51         return neartest;
--[ 2019.11.19.15.01.13.561.0 ]--
r 51         return null;
--[ 2019.11.19.15.01.14.977.0 ]--
- 42
--[ 2019.11.19.15.01.16.329.0 ]--
+ 42             if(q.dist(p) < min.dist(p)){
--[ 2019.11.19.15.01.19.049.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.02.23.944.0 ]--
+ 74         
--[ 2019.11.19.15.02.26.965.0 ]--
r 74          
--[ 2019.11.19.15.02.27.013.0 ]--
r 74         
--[ 2019.11.19.15.02.49.667.0 ]--
r 7 public class PSBruteFo rce<Value> implements PointSearch<Value> {
--[ 2019.11.19.15.02.49.958.0 ]--
r 7 public class PSBruteForce<Value> implements PointSearch<Value> {
--[ 2019.11.19.15.03.02.380.0 ]--
+ 10     
--[ 2019.11.19.15.03.02.740.0 ]--
r 10     p
--[ 2019.11.19.15.03.02.841.0 ]--
r 10     pr
--[ 2019.11.19.15.03.02.956.0 ]--
r 10     pri
--[ 2019.11.19.15.03.03.093.0 ]--
r 10     priv
--[ 2019.11.19.15.03.03.221.0 ]--
r 10     priva
--[ 2019.11.19.15.03.03.306.0 ]--
r 10     privat
--[ 2019.11.19.15.03.03.371.0 ]--
r 10     private
--[ 2019.11.19.15.03.03.925.0 ]--
r 10     private 
--[ 2019.11.19.15.03.04.171.0 ]--
r 10     private P
--[ 2019.11.19.15.03.04.322.0 ]--
r 10     private Po
--[ 2019.11.19.15.03.04.472.0 ]--
r 10     private Poi
--[ 2019.11.19.15.03.04.508.0 ]--
r 10     private Poin
--[ 2019.11.19.15.03.04.605.0 ]--
r 10     private Point
--[ 2019.11.19.15.03.04.668.0 ]--
r 10     private Point 
--[ 2019.11.19.15.03.08.658.0 ]--
r 10     private Point k
--[ 2019.11.19.15.03.08.809.0 ]--
r 10     private Point km
--[ 2019.11.19.15.03.08.920.0 ]--
r 10     private Point kmi
--[ 2019.11.19.15.03.08.974.0 ]--
r 10     private Point kmin
--[ 2019.11.19.15.03.09.456.0 ]--
r 10     private Point kmin 
--[ 2019.11.19.15.03.09.488.0 ]--
r 10     private Point kmin
--[ 2019.11.19.15.03.09.611.0 ]--
r 10     private Point kmi
--[ 2019.11.19.15.03.09.724.0 ]--
r 10     private Point km
--[ 2019.11.19.15.03.09.830.0 ]--
r 10     private Point k
--[ 2019.11.19.15.03.10.216.0 ]--
r 10     private Point 
--[ 2019.11.19.15.03.10.376.0 ]--
r 10     private Point m
--[ 2019.11.19.15.03.10.539.0 ]--
r 10     private Point mi
--[ 2019.11.19.15.03.10.609.0 ]--
r 10     private Point min
--[ 2019.11.19.15.03.11.029.0 ]--
r 10     private Point mink
--[ 2019.11.19.15.03.12.785.0 ]--
r 10     private Point mink[]
--[ 2019.11.19.15.03.13.216.0 ]--
r 10     private Point mink[];
--[ 2019.11.19.15.03.14.046.0 ]--
r 10     private Point mink[]; 
--[ 2019.11.19.15.03.14.088.0 ]--
r 10     private Point mink[];
--[ 2019.11.19.15.03.20.737.0 ]--
r 75         m
--[ 2019.11.19.15.03.20.799.0 ]--
r 75         mi
--[ 2019.11.19.15.03.20.873.0 ]--
r 75         min
--[ 2019.11.19.15.03.21.018.0 ]--
r 75         mink
--[ 2019.11.19.15.03.21.320.0 ]--
r 75         mink 
--[ 2019.11.19.15.03.21.444.0 ]--
r 75         mink =
--[ 2019.11.19.15.03.21.565.0 ]--
r 75         mink = 
--[ 2019.11.19.15.03.22.103.0 ]--
r 75         mink = n
--[ 2019.11.19.15.03.22.171.0 ]--
r 75         mink = ne
--[ 2019.11.19.15.03.22.290.0 ]--
r 75         mink = new
--[ 2019.11.19.15.03.22.423.0 ]--
r 75         mink = new 
--[ 2019.11.19.15.03.22.559.0 ]--
r 75         mink = new P
--[ 2019.11.19.15.03.22.705.0 ]--
r 75         mink = new Po
--[ 2019.11.19.15.03.22.827.0 ]--
r 75         mink = new Poi
--[ 2019.11.19.15.03.22.891.0 ]--
r 75         mink = new Poin
--[ 2019.11.19.15.03.22.995.0 ]--
r 75         mink = new Point
--[ 2019.11.19.15.03.23.185.0 ]--
r 75         mink = new Point[]
--[ 2019.11.19.15.03.24.188.0 ]--
r 75         mink = new Point[k]
--[ 2019.11.19.15.03.24.873.0 ]--
r 75         mink = new Point[k];
--[ 2019.11.19.15.03.25.565.0 ]--
r 75         mink = new Point[k]; 
--[ 2019.11.19.15.03.25.656.0 ]--
r 75         mink = new Point[k];
--[ 2019.11.19.15.03.25.886.0 ]--
+ 76         
--[ 2019.11.19.15.03.27.196.0 ]--
+ 76         
--[ 2019.11.19.15.03.28.399.0 ]--
- 76
--[ 2019.11.19.15.03.28.982.0 ]--
+ 76         
--[ 2019.11.19.15.05.03.297.0 ]--
r 76 
--[ 2019.11.19.15.05.04.336.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.07.37.481.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.08.12.388.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.08.31.175.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.09.56.438.0 ]--
r 77 
--[ 2019.11.19.15.11.19.207.0 ]--
r 10     private Point min[];
--[ 2019.11.19.15.11.20.106.0 ]--
r 10     private Point kmin[];
--[ 2019.11.19.15.11.24.058.0 ]--
r 75         min = new Point[k];
--[ 2019.11.19.15.11.24.890.0 ]--
r 75         kmin = new Point[k];
--[ 2019.11.19.15.23.04.845.0 ]--
+ 11     
--[ 2019.11.19.15.23.07.136.0 ]--
r 11      
--[ 2019.11.19.15.23.07.186.0 ]--
r 11     
--[ 2019.11.19.15.23.07.336.0 ]--
r 11     p
--[ 2019.11.19.15.23.07.418.0 ]--
r 11     pr
--[ 2019.11.19.15.23.07.498.0 ]--
r 11     pri
--[ 2019.11.19.15.23.07.619.0 ]--
r 11     priv
--[ 2019.11.19.15.23.07.720.0 ]--
r 11     priva
--[ 2019.11.19.15.23.07.826.0 ]--
r 11     privat
--[ 2019.11.19.15.23.07.912.0 ]--
r 11     private
--[ 2019.11.19.15.23.07.959.0 ]--
r 11     private 
--[ 2019.11.19.15.23.08.104.0 ]--
r 11     private m
--[ 2019.11.19.15.23.08.178.0 ]--
r 11     private mi
--[ 2019.11.19.15.23.08.247.0 ]--
r 11     private min
--[ 2019.11.19.15.23.08.581.0 ]--
r 11     private min 
--[ 2019.11.19.15.23.08.626.0 ]--
r 11     private min
--[ 2019.11.19.15.23.09.348.0 ]--
r 11     private mi
--[ 2019.11.19.15.23.09.467.0 ]--
r 11     private m
--[ 2019.11.19.15.23.09.681.0 ]--
r 11     private 
--[ 2019.11.19.15.23.09.887.0 ]--
r 11     private P
--[ 2019.11.19.15.23.10.051.0 ]--
r 11     private Po
--[ 2019.11.19.15.23.10.197.0 ]--
r 11     private Poi
--[ 2019.11.19.15.23.10.234.0 ]--
r 11     private Poin
--[ 2019.11.19.15.23.10.343.0 ]--
r 11     private Point
--[ 2019.11.19.15.23.10.406.0 ]--
r 11     private Point 
--[ 2019.11.19.15.23.14.017.0 ]--
r 11     private Point  
--[ 2019.11.19.15.23.14.065.0 ]--
r 11     private Point 
--[ 2019.11.19.15.23.14.211.0 ]--
r 11     private Point m
--[ 2019.11.19.15.23.14.298.0 ]--
r 11     private Point mi
--[ 2019.11.19.15.23.14.391.0 ]--
r 11     private Point min
--[ 2019.11.19.15.23.14.682.0 ]--
r 11     private Point min 
--[ 2019.11.19.15.23.14.779.0 ]--
r 11     private Point min
--[ 2019.11.19.15.23.15.139.0 ]--
r 11     private Point minP
--[ 2019.11.19.15.23.15.247.0 ]--
r 11     private Point minPo
--[ 2019.11.19.15.23.15.530.0 ]--
r 11     private Point minPoi
--[ 2019.11.19.15.23.15.551.0 ]--
r 11     private Point minPoin
--[ 2019.11.19.15.23.15.911.0 ]--
r 11     private Point minPoi
--[ 2019.11.19.15.23.16.063.0 ]--
r 11     private Point minPo
--[ 2019.11.19.15.23.16.203.0 ]--
r 11     private Point minP
--[ 2019.11.19.15.23.17.242.0 ]--
r 11     private Point minPo
--[ 2019.11.19.15.23.17.405.0 ]--
r 11     private Point minPoi
--[ 2019.11.19.15.23.17.445.0 ]--
r 11     private Point minPoin
--[ 2019.11.19.15.23.17.496.0 ]--
r 11     private Point minPoint
--[ 2019.11.19.15.23.17.623.0 ]--
r 11     private Point minPoint 
--[ 2019.11.19.15.23.17.695.0 ]--
r 11     private Point minPoint
--[ 2019.11.19.15.23.18.032.0 ]--
r 11     private Point minPoint;
--[ 2019.11.19.15.23.18.386.0 ]--
+ 12     
--[ 2019.11.19.15.23.18.573.0 ]--
r 12     p
--[ 2019.11.19.15.23.18.683.0 ]--
r 12     pr
--[ 2019.11.19.15.23.18.756.0 ]--
r 12     pri
--[ 2019.11.19.15.23.18.848.0 ]--
r 12     priv
--[ 2019.11.19.15.23.18.960.0 ]--
r 12     priva
--[ 2019.11.19.15.23.19.066.0 ]--
r 12     privat
--[ 2019.11.19.15.23.19.128.0 ]--
r 12     private
--[ 2019.11.19.15.23.19.688.0 ]--
r 12     private 
--[ 2019.11.19.15.23.20.289.0 ]--
r 12     private P
--[ 2019.11.19.15.23.20.427.0 ]--
r 12     private Po
--[ 2019.11.19.15.23.20.558.0 ]--
r 12     private Poi
--[ 2019.11.19.15.23.20.593.0 ]--
r 12     private Poin
--[ 2019.11.19.15.23.20.780.0 ]--
r 12     private Point
--[ 2019.11.19.15.23.20.792.0 ]--
r 12     private Point 
--[ 2019.11.19.15.23.20.855.0 ]--
r 12     private Point m
--[ 2019.11.19.15.23.20.941.0 ]--
r 12     private Point ma
--[ 2019.11.19.15.23.21.055.0 ]--
r 12     private Point max
--[ 2019.11.19.15.23.21.328.0 ]--
r 12     private Point maxP
--[ 2019.11.19.15.23.21.406.0 ]--
r 12     private Point maxPo
--[ 2019.11.19.15.23.21.548.0 ]--
r 12     private Point maxPoi
--[ 2019.11.19.15.23.21.587.0 ]--
r 12     private Point maxPoin
--[ 2019.11.19.15.23.21.659.0 ]--
r 12     private Point maxPoint
--[ 2019.11.19.15.23.21.782.0 ]--
r 12     private Point maxPoint;
--[ 2019.11.19.15.23.23.980.0 ]--
+ 13     
--[ 2019.11.19.15.23.31.809.0 ]--
+ 21         
--[ 2019.11.19.15.23.33.384.0 ]--
+ 21         
--[ 2019.11.19.15.23.34.552.0 ]--
r 21         i
--[ 2019.11.19.15.23.34.649.0 ]--
r 21         if
--[ 2019.11.19.15.23.35.882.0 ]--
r 21         i
--[ 2019.11.19.15.23.35.979.0 ]--
r 21         
--[ 2019.11.19.15.23.37.814.0 ]--
r 21          
--[ 2019.11.19.15.23.37.879.0 ]--
r 21         
--[ 2019.11.19.15.23.38.343.0 ]--
r 21         ()
--[ 2019.11.19.15.23.38.772.0 ]--
r 21         
--[ 2019.11.19.15.23.39.144.0 ]--
r 21         s
--[ 2019.11.19.15.23.39.206.0 ]--
r 21         si
--[ 2019.11.19.15.23.39.280.0 ]--
r 21         siz
--[ 2019.11.19.15.23.39.466.0 ]--
r 21         size
--[ 2019.11.19.15.23.39.632.0 ]--
r 21         size()
--[ 2019.11.19.15.23.40.055.0 ]--
r 21         size() 
--[ 2019.11.19.15.23.40.612.0 ]--
r 21         size()
--[ 2019.11.19.15.23.40.737.0 ]--
r 21         size(
--[ 2019.11.19.15.23.40.995.0 ]--
r 21         size
--[ 2019.11.19.15.23.41.080.0 ]--
r 21         siz
--[ 2019.11.19.15.23.41.194.0 ]--
r 21         si
--[ 2019.11.19.15.23.41.309.0 ]--
r 21         s
--[ 2019.11.19.15.23.41.422.0 ]--
r 21         
--[ 2019.11.19.15.23.41.789.0 ]--
r 21         i
--[ 2019.11.19.15.23.41.883.0 ]--
r 21         if
--[ 2019.11.19.15.23.42.013.0 ]--
r 21         if()
--[ 2019.11.19.15.23.42.183.0 ]--
r 21         if(s)
--[ 2019.11.19.15.23.42.292.0 ]--
r 21         if(si)
--[ 2019.11.19.15.23.42.361.0 ]--
r 21         if(siz)
--[ 2019.11.19.15.23.42.519.0 ]--
r 21         if(size)
--[ 2019.11.19.15.23.42.712.0 ]--
r 21         if(size())
--[ 2019.11.19.15.23.43.935.0 ]--
r 21         if(size() )
--[ 2019.11.19.15.23.44.363.0 ]--
r 21         if(size() =)
--[ 2019.11.19.15.23.44.462.0 ]--
r 21         if(size() ==)
--[ 2019.11.19.15.23.44.507.0 ]--
r 21         if(size() == )
--[ 2019.11.19.15.23.44.570.0 ]--
r 21         if(size() == 1)
--[ 2019.11.19.15.23.45.494.0 ]--
r 21         if(size() == 1){
--[ 2019.11.19.15.23.45.670.0 ]--
+ 22 
+ 23 }
--[ 2019.11.19.15.23.45.677.0 ]--
r 23         }
--[ 2019.11.19.15.23.45.690.0 ]--
r 22             
--[ 2019.11.19.15.23.47.492.0 ]--
r 22             m
--[ 2019.11.19.15.23.47.563.0 ]--
r 22             mi
--[ 2019.11.19.15.23.47.616.0 ]--
r 22             min
--[ 2019.11.19.15.23.48.182.0 ]--
r 22             minP
--[ 2019.11.19.15.23.48.441.0 ]--
r 22             minPo
--[ 2019.11.19.15.23.48.680.0 ]--
r 22             minPoi
--[ 2019.11.19.15.23.48.703.0 ]--
r 22             minPoin
--[ 2019.11.19.15.23.48.808.0 ]--
r 22             minPoint
--[ 2019.11.19.15.23.49.024.0 ]--
r 22             minPoint 
--[ 2019.11.19.15.23.49.904.0 ]--
r 22             minPoint =
--[ 2019.11.19.15.23.49.966.0 ]--
r 22             minPoint = 
--[ 2019.11.19.15.23.50.030.0 ]--
r 22             minPoint = p
--[ 2019.11.19.15.23.50.326.0 ]--
r 22             minPoint = p;
--[ 2019.11.19.15.23.50.678.0 ]--
+ 23             
--[ 2019.11.19.15.23.50.846.0 ]--
r 23             m
--[ 2019.11.19.15.23.51.143.0 ]--
r 23             ma
--[ 2019.11.19.15.23.51.268.0 ]--
r 23             max
--[ 2019.11.19.15.23.51.525.0 ]--
r 23             maxP
--[ 2019.11.19.15.23.51.666.0 ]--
r 23             maxPo
--[ 2019.11.19.15.23.52.080.0 ]--
r 23             maxPoint
--[ 2019.11.19.15.23.52.382.0 ]--
r 23             maxPoint 
--[ 2019.11.19.15.23.52.464.0 ]--
r 23             maxPoint =
--[ 2019.11.19.15.23.52.623.0 ]--
r 23             maxPoint = 
--[ 2019.11.19.15.23.53.399.0 ]--
r 23             maxPoint = p
--[ 2019.11.19.15.23.53.574.0 ]--
r 23             maxPoint = p;
--[ 2019.11.19.15.23.53.871.0 ]--
r 23             maxPoint = p; 
--[ 2019.11.19.15.23.53.931.0 ]--
r 23             maxPoint = p;
--[ 2019.11.19.15.23.56.208.0 ]--
+ 25         
--[ 2019.11.19.15.24.51.573.0 ]--
r 13 
r 26 
--[ 2019.11.19.15.24.52.817.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.25.53.128.0 ]--
r 72         return m;
--[ 2019.11.19.15.25.53.225.0 ]--
r 72         return mi;
--[ 2019.11.19.15.25.53.308.0 ]--
r 72         return min;
--[ 2019.11.19.15.25.55.429.0 ]--
r 72         return minP;
--[ 2019.11.19.15.25.55.831.0 ]--
r 72         return minPoint;
--[ 2019.11.19.15.25.59.665.0 ]--
r 79         return m;
--[ 2019.11.19.15.25.59.711.0 ]--
r 79         return ma;
--[ 2019.11.19.15.25.59.837.0 ]--
r 79         return max;
--[ 2019.11.19.15.26.00.048.0 ]--
r 79         return maxP;
--[ 2019.11.19.15.26.00.408.0 ]--
r 79         return maxPoint;
--[ 2019.11.19.15.26.01.318.0 ]--
r 79         return maxPoint ;
--[ 2019.11.19.15.26.01.377.0 ]--
r 79         return maxPoint;
--[ 2019.11.19.15.26.03.251.0 ]--
r 25 
--[ 2019.11.19.15.26.04.316.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.27.33.991.0 ]--
- 22
- 22
r 22          
--[ 2019.11.19.15.27.34.763.0 ]--
r 22          }
--[ 2019.11.19.15.27.34.776.0 ]--
r 21         if(size() == 1) {
--[ 2019.11.19.15.27.34.781.0 ]--
r 22         }
--[ 2019.11.19.15.27.38.990.0 ]--
- 11
- 11
r 11     
--[ 2019.11.19.15.27.39.646.0 ]--
+ 11     
--[ 2019.11.19.15.27.42.858.0 ]--
r 11      
--[ 2019.11.19.15.27.42.916.0 ]--
r 11     
--[ 2019.11.19.15.27.45.559.0 ]--
+ 21         
--[ 2019.11.19.15.27.49.082.0 ]--
- 20
- 21
--[ 2019.11.19.15.27.49.263.0 ]--
- 20
--[ 2019.11.19.15.27.50.797.0 ]--
+ 23         
--[ 2019.11.19.15.27.51.093.0 ]--
+ 23         
--[ 2019.11.19.15.27.51.213.0 ]--
+ 24         if(size() == 1) {
+ 26         }
--[ 2019.11.19.15.27.51.220.0 ]--
r 23 
r 25 
--[ 2019.11.19.15.27.52.285.0 ]--
- 20
--[ 2019.11.19.15.27.53.533.0 ]--
- 20
--[ 2019.11.19.15.27.56.402.0 ]--
r 11     p
--[ 2019.11.19.15.27.56.580.0 ]--
r 11     pr
--[ 2019.11.19.15.27.56.645.0 ]--
r 11     pri
--[ 2019.11.19.15.27.56.753.0 ]--
r 11     priv
--[ 2019.11.19.15.27.56.879.0 ]--
r 11     priva
--[ 2019.11.19.15.27.57.012.0 ]--
r 11     privat
--[ 2019.11.19.15.27.57.047.0 ]--
r 11     private
--[ 2019.11.19.15.27.57.794.0 ]--
r 11     private 
--[ 2019.11.19.15.27.59.850.0 ]--
r 11     private  
--[ 2019.11.19.15.27.59.881.0 ]--
r 11     private 
--[ 2019.11.19.15.28.00.002.0 ]--
r 11     private d
--[ 2019.11.19.15.28.00.106.0 ]--
r 11     private do
--[ 2019.11.19.15.28.00.202.0 ]--
r 11     private dou
--[ 2019.11.19.15.28.00.313.0 ]--
r 11     private doub
--[ 2019.11.19.15.28.00.410.0 ]--
r 11     private doubl
--[ 2019.11.19.15.28.00.509.0 ]--
r 11     private double
--[ 2019.11.19.15.28.01.183.0 ]--
r 11     private double 
--[ 2019.11.19.15.28.01.599.0 ]--
r 11     private double M
--[ 2019.11.19.15.28.01.741.0 ]--
r 11     private double Mi
--[ 2019.11.19.15.28.01.800.0 ]--
r 11     private double Min
--[ 2019.11.19.15.28.02.255.0 ]--
r 11     private double Mi
--[ 2019.11.19.15.28.02.360.0 ]--
r 11     private double M
--[ 2019.11.19.15.28.02.426.0 ]--
r 11     private double 
--[ 2019.11.19.15.28.02.569.0 ]--
r 11     private double m
--[ 2019.11.19.15.28.02.641.0 ]--
r 11     private double mi
--[ 2019.11.19.15.28.02.721.0 ]--
r 11     private double min
--[ 2019.11.19.15.28.03.169.0 ]--
r 11     private double minX
--[ 2019.11.19.15.28.03.734.0 ]--
r 11     private double minX;
--[ 2019.11.19.15.28.03.827.0 ]--
+ 12     
--[ 2019.11.19.15.28.04.087.0 ]--
r 12     p
--[ 2019.11.19.15.28.04.181.0 ]--
r 12     pr
--[ 2019.11.19.15.28.04.258.0 ]--
r 12     pri
--[ 2019.11.19.15.28.04.353.0 ]--
r 12     priv
--[ 2019.11.19.15.28.04.433.0 ]--
r 12     priva
--[ 2019.11.19.15.28.04.537.0 ]--
r 12     privat
--[ 2019.11.19.15.28.04.594.0 ]--
r 12     private
--[ 2019.11.19.15.28.05.049.0 ]--
r 12     private 
--[ 2019.11.19.15.28.05.091.0 ]--
r 12     private d
--[ 2019.11.19.15.28.05.177.0 ]--
r 12     private do
--[ 2019.11.19.15.28.05.217.0 ]--
r 12     private dou
--[ 2019.11.19.15.28.05.284.0 ]--
r 12     private doub
--[ 2019.11.19.15.28.05.354.0 ]--
r 12     private doubl
--[ 2019.11.19.15.28.05.449.0 ]--
r 12     private double
--[ 2019.11.19.15.28.05.513.0 ]--
r 12     private double 
--[ 2019.11.19.15.28.05.577.0 ]--
r 12     private double m
--[ 2019.11.19.15.28.05.682.0 ]--
r 12     private double mi
--[ 2019.11.19.15.28.05.756.0 ]--
r 12     private double min
--[ 2019.11.19.15.28.06.132.0 ]--
r 12     private double minY
--[ 2019.11.19.15.28.06.419.0 ]--
r 12     private double minY;l
--[ 2019.11.19.15.28.06.907.0 ]--
r 12     private double minY;
--[ 2019.11.19.15.28.07.086.0 ]--
+ 13     
--[ 2019.11.19.15.28.07.446.0 ]--
r 13     p
--[ 2019.11.19.15.28.07.505.0 ]--
r 13     pr
--[ 2019.11.19.15.28.07.632.0 ]--
r 13     pri
--[ 2019.11.19.15.28.07.685.0 ]--
r 13     priv
--[ 2019.11.19.15.28.07.761.0 ]--
r 13     priva
--[ 2019.11.19.15.28.07.858.0 ]--
r 13     privat
--[ 2019.11.19.15.28.07.922.0 ]--
r 13     private
--[ 2019.11.19.15.28.08.002.0 ]--
r 13     private 
--[ 2019.11.19.15.28.08.169.0 ]--
r 13     private d
--[ 2019.11.19.15.28.08.250.0 ]--
r 13     private do
--[ 2019.11.19.15.28.08.297.0 ]--
r 13     private dou
--[ 2019.11.19.15.28.08.369.0 ]--
r 13     private doub
--[ 2019.11.19.15.28.08.433.0 ]--
r 13     private doubl
--[ 2019.11.19.15.28.08.514.0 ]--
r 13     private double
--[ 2019.11.19.15.28.08.570.0 ]--
r 13     private double 
--[ 2019.11.19.15.28.08.631.0 ]--
r 13     private double m
--[ 2019.11.19.15.28.08.677.0 ]--
r 13     private double mi
--[ 2019.11.19.15.28.08.939.0 ]--
r 13     private double m
--[ 2019.11.19.15.28.09.030.0 ]--
r 13     private double 
--[ 2019.11.19.15.28.09.282.0 ]--
r 13     private double m
--[ 2019.11.19.15.28.09.330.0 ]--
r 13     private double ma
--[ 2019.11.19.15.28.09.425.0 ]--
r 13     private double max
--[ 2019.11.19.15.28.09.823.0 ]--
r 13     private double maxX
--[ 2019.11.19.15.28.10.475.0 ]--
r 13     private double maxXl
--[ 2019.11.19.15.28.10.609.0 ]--
+ 14     
--[ 2019.11.19.15.28.10.620.0 ]--
r 14             
--[ 2019.11.19.15.28.10.957.0 ]--
- 14
--[ 2019.11.19.15.28.11.044.0 ]--
r 13     private double maxX
--[ 2019.11.19.15.28.11.161.0 ]--
r 13     private double max
--[ 2019.11.19.15.28.11.809.0 ]--
r 13     private double maxX
--[ 2019.11.19.15.28.11.904.0 ]--
r 13     private double maxX;
--[ 2019.11.19.15.28.12.048.0 ]--
+ 14     
--[ 2019.11.19.15.28.12.945.0 ]--
r 14     p
--[ 2019.11.19.15.28.13.012.0 ]--
r 14     pr
--[ 2019.11.19.15.28.13.106.0 ]--
r 14     pri
--[ 2019.11.19.15.28.13.194.0 ]--
r 14     priv
--[ 2019.11.19.15.28.13.281.0 ]--
r 14     priva
--[ 2019.11.19.15.28.13.400.0 ]--
r 14     privat
--[ 2019.11.19.15.28.13.444.0 ]--
r 14     private
--[ 2019.11.19.15.28.13.696.0 ]--
r 14     private 
--[ 2019.11.19.15.28.13.760.0 ]--
r 14     private d
--[ 2019.11.19.15.28.13.857.0 ]--
r 14     private do
--[ 2019.11.19.15.28.13.918.0 ]--
r 14     private dou
--[ 2019.11.19.15.28.13.969.0 ]--
r 14     private doub
--[ 2019.11.19.15.28.14.043.0 ]--
r 14     private doubl
--[ 2019.11.19.15.28.14.140.0 ]--
r 14     private double
--[ 2019.11.19.15.28.14.208.0 ]--
r 14     private double 
--[ 2019.11.19.15.28.14.566.0 ]--
r 14     private double m
--[ 2019.11.19.15.28.14.623.0 ]--
r 14     private double mi
--[ 2019.11.19.15.28.14.683.0 ]--
r 14     private double min
--[ 2019.11.19.15.28.15.132.0 ]--
r 14     private double mi
--[ 2019.11.19.15.28.15.230.0 ]--
r 14     private double m
--[ 2019.11.19.15.28.15.627.0 ]--
r 14     private double 
--[ 2019.11.19.15.28.15.743.0 ]--
r 14     private double m
--[ 2019.11.19.15.28.15.795.0 ]--
r 14     private double ma
--[ 2019.11.19.15.28.15.891.0 ]--
r 14     private double max
--[ 2019.11.19.15.28.16.114.0 ]--
r 14     private double maxY
--[ 2019.11.19.15.28.16.364.0 ]--
r 14     private double maxY;
--[ 2019.11.19.15.28.18.986.0 ]--
- 26
--[ 2019.11.19.15.28.19.295.0 ]--
r 25         if(size() == 1) { 
--[ 2019.11.19.15.28.19.325.0 ]--
r 25         if(size() == 1) {
--[ 2019.11.19.15.28.19.515.0 ]--
+ 26             
--[ 2019.11.19.15.28.20.097.0 ]--
r 26             m
--[ 2019.11.19.15.28.20.165.0 ]--
r 26             mi
--[ 2019.11.19.15.28.20.218.0 ]--
r 26             min
--[ 2019.11.19.15.28.22.961.0 ]--
r 26             minX
--[ 2019.11.19.15.28.23.110.0 ]--
r 26             minX 
--[ 2019.11.19.15.28.23.180.0 ]--
r 26             minX =
--[ 2019.11.19.15.28.23.294.0 ]--
r 26             minX = 
--[ 2019.11.19.15.28.23.590.0 ]--
r 26             minX = p
--[ 2019.11.19.15.28.23.955.0 ]--
r 26             minX = p.
--[ 2019.11.19.15.28.24.439.0 ]--
r 26             minX = p.x
--[ 2019.11.19.15.28.24.641.0 ]--
r 26             minX = p.x()
--[ 2019.11.19.15.28.25.037.0 ]--
r 26             minX = p.x();
--[ 2019.11.19.15.28.25.197.0 ]--
+ 27             
--[ 2019.11.19.15.28.25.713.0 ]--
r 27             m
--[ 2019.11.19.15.28.25.783.0 ]--
r 27             mi
--[ 2019.11.19.15.28.25.835.0 ]--
r 27             min
--[ 2019.11.19.15.28.26.964.0 ]--
r 27             minY
--[ 2019.11.19.15.28.27.170.0 ]--
r 27             minY 
--[ 2019.11.19.15.28.27.242.0 ]--
r 27             minY =
--[ 2019.11.19.15.28.27.335.0 ]--
r 27             minY = 
--[ 2019.11.19.15.28.27.846.0 ]--
r 27             minY = p
--[ 2019.11.19.15.28.27.984.0 ]--
r 27             minY = p.
--[ 2019.11.19.15.28.28.091.0 ]--
r 27             minY = p.y
--[ 2019.11.19.15.28.28.408.0 ]--
r 27             minY = p.y*)
--[ 2019.11.19.15.28.28.812.0 ]--
r 27             minY = p.y*
--[ 2019.11.19.15.28.28.943.0 ]--
r 27             minY = p.y
--[ 2019.11.19.15.28.29.111.0 ]--
r 27             minY = p.y()
--[ 2019.11.19.15.28.29.369.0 ]--
r 27             minY = p.y();l
--[ 2019.11.19.15.28.29.481.0 ]--
r 27             minY = p.y();long
--[ 2019.11.19.15.28.29.856.0 ]--
r 27             minY = p.y();lon
--[ 2019.11.19.15.28.29.988.0 ]--
r 27             minY = p.y();lo
--[ 2019.11.19.15.28.30.122.0 ]--
r 27             minY = p.y();l
--[ 2019.11.19.15.28.30.377.0 ]--
r 27             minY = p.y();
--[ 2019.11.19.15.28.30.592.0 ]--
+ 28             
--[ 2019.11.19.15.28.34.490.0 ]--
r 28             m
--[ 2019.11.19.15.28.34.559.0 ]--
r 28             ma
--[ 2019.11.19.15.28.34.657.0 ]--
r 28             max
--[ 2019.11.19.15.28.34.903.0 ]--
r 28             maxX
--[ 2019.11.19.15.28.35.408.0 ]--
r 28             maxX 
--[ 2019.11.19.15.28.35.512.0 ]--
r 28             maxX =
--[ 2019.11.19.15.28.35.629.0 ]--
r 28             maxX = 
--[ 2019.11.19.15.28.37.690.0 ]--
r 28             maxX = p
--[ 2019.11.19.15.28.37.778.0 ]--
r 28             maxX = p.
--[ 2019.11.19.15.28.37.891.0 ]--
r 28             maxX = p.x
--[ 2019.11.19.15.28.38.707.0 ]--
r 28             maxX = p.x()
--[ 2019.11.19.15.28.38.943.0 ]--
r 28             maxX = p.x();
--[ 2019.11.19.15.28.39.108.0 ]--
+ 29             
--[ 2019.11.19.15.28.39.645.0 ]--
r 29              
--[ 2019.11.19.15.28.39.686.0 ]--
r 29             
--[ 2019.11.19.15.28.39.838.0 ]--
r 29             m
--[ 2019.11.19.15.28.39.930.0 ]--
r 29             ma
--[ 2019.11.19.15.28.40.004.0 ]--
r 29             max
--[ 2019.11.19.15.28.40.273.0 ]--
r 29             maxX
--[ 2019.11.19.15.28.40.598.0 ]--
r 29             max
--[ 2019.11.19.15.28.41.224.0 ]--
r 29             maxY
--[ 2019.11.19.15.28.41.646.0 ]--
r 29             maxY 
--[ 2019.11.19.15.28.41.714.0 ]--
r 29             maxY =
--[ 2019.11.19.15.28.41.786.0 ]--
r 29             maxY = 
--[ 2019.11.19.15.28.42.011.0 ]--
r 29             maxY = p
--[ 2019.11.19.15.28.42.514.0 ]--
r 29             maxY = p.
--[ 2019.11.19.15.28.42.957.0 ]--
r 29             maxY = p.y
--[ 2019.11.19.15.28.43.409.0 ]--
r 29             maxY = p.y()
--[ 2019.11.19.15.28.43.816.0 ]--
r 29             maxY = p.y();
--[ 2019.11.19.15.28.44.863.0 ]--
r 29             maxY = p.y(); 
--[ 2019.11.19.15.28.44.906.0 ]--
r 29             maxY = p.y();
--[ 2019.11.19.15.28.45.643.0 ]--
+ 31         
--[ 2019.11.19.15.28.46.455.0 ]--
r 31         e
--[ 2019.11.19.15.28.46.527.0 ]--
r 31         el
--[ 2019.11.19.15.28.46.594.0 ]--
r 31         els
--[ 2019.11.19.15.28.46.730.0 ]--
r 31         else
--[ 2019.11.19.15.28.47.680.0 ]--
r 31         els
--[ 2019.11.19.15.28.47.792.0 ]--
r 31         el
--[ 2019.11.19.15.28.47.896.0 ]--
r 31         e
--[ 2019.11.19.15.28.48.021.0 ]--
r 31         
--[ 2019.11.19.15.28.49.426.0 ]--
r 31         e
--[ 2019.11.19.15.28.49.513.0 ]--
r 31         el
--[ 2019.11.19.15.28.49.561.0 ]--
r 31         els
--[ 2019.11.19.15.28.49.717.0 ]--
r 31         else
--[ 2019.11.19.15.28.49.801.0 ]--
r 31         else 
--[ 2019.11.19.15.28.50.171.0 ]--
r 31         else i
--[ 2019.11.19.15.28.50.290.0 ]--
r 31         else if
--[ 2019.11.19.15.28.50.545.0 ]--
r 31         else if()
--[ 2019.11.19.15.29.00.881.0 ]--
r 31         else if(i)
--[ 2019.11.19.15.29.00.956.0 ]--
r 31         else if(if)
--[ 2019.11.19.15.29.01.483.0 ]--
r 31         else if(i)
--[ 2019.11.19.15.29.01.611.0 ]--
r 31         else if()
--[ 2019.11.19.15.29.02.053.0 ]--
r 31         else if( )
--[ 2019.11.19.15.29.02.102.0 ]--
r 31         else if()
--[ 2019.11.19.15.29.09.034.0 ]--
r 76         return n;
--[ 2019.11.19.15.29.09.113.0 ]--
r 76         return ne;
--[ 2019.11.19.15.29.09.395.0 ]--
r 76         return new;
--[ 2019.11.19.15.29.10.611.0 ]--
r 76         return new ;
--[ 2019.11.19.15.29.11.088.0 ]--
r 76         return new P;
--[ 2019.11.19.15.29.11.271.0 ]--
r 76         return new Po;
--[ 2019.11.19.15.29.11.363.0 ]--
r 76         return new Poi;
--[ 2019.11.19.15.29.11.416.0 ]--
r 76         return new Poin;
--[ 2019.11.19.15.29.11.468.0 ]--
r 76         return new Point;
--[ 2019.11.19.15.29.11.593.0 ]--
r 76         return new Point();
--[ 2019.11.19.15.29.12.401.0 ]--
r 76         return new Point(m);
--[ 2019.11.19.15.29.12.484.0 ]--
r 76         return new Point(mi);
--[ 2019.11.19.15.29.12.539.0 ]--
r 76         return new Point(min);
--[ 2019.11.19.15.29.13.668.0 ]--
r 76         return new Point(minX);
--[ 2019.11.19.15.29.13.877.0 ]--
r 76         return new Point(minX,);
--[ 2019.11.19.15.29.14.032.0 ]--
r 76         return new Point(minX, );
--[ 2019.11.19.15.29.14.213.0 ]--
r 76         return new Point(minX, m);
--[ 2019.11.19.15.29.14.335.0 ]--
r 76         return new Point(minX, mi);
--[ 2019.11.19.15.29.14.382.0 ]--
r 76         return new Point(minX, min);
--[ 2019.11.19.15.29.14.644.0 ]--
r 76         return new Point(minX, minY);
--[ 2019.11.19.15.29.17.588.0 ]--
r 83         return n;
--[ 2019.11.19.15.29.17.647.0 ]--
r 83         return ne;
--[ 2019.11.19.15.29.17.784.0 ]--
r 83         return new;
--[ 2019.11.19.15.29.17.824.0 ]--
r 83         return new ;
--[ 2019.11.19.15.29.17.929.0 ]--
r 83         return new p;
--[ 2019.11.19.15.29.18.213.0 ]--
r 83         return new ;
--[ 2019.11.19.15.29.18.346.0 ]--
r 83         return new P;
--[ 2019.11.19.15.29.18.507.0 ]--
r 83         return new Po;
--[ 2019.11.19.15.29.18.722.0 ]--
r 83         return new Poi;
--[ 2019.11.19.15.29.18.786.0 ]--
r 83         return new Poin;
--[ 2019.11.19.15.29.18.874.0 ]--
r 83         return new Point;
--[ 2019.11.19.15.29.19.011.0 ]--
r 83         return new Point();
--[ 2019.11.19.15.29.19.730.0 ]--
r 83         return new Point(m);
--[ 2019.11.19.15.29.19.805.0 ]--
r 83         return new Point(ma);
--[ 2019.11.19.15.29.19.972.0 ]--
r 83         return new Point(max);
--[ 2019.11.19.15.29.20.311.0 ]--
r 83         return new Point(maxX);
--[ 2019.11.19.15.29.21.104.0 ]--
r 83         return new Point(maxX,);
--[ 2019.11.19.15.29.21.176.0 ]--
r 83         return new Point(maxX, );
--[ 2019.11.19.15.29.21.248.0 ]--
r 83         return new Point(maxX, m);
--[ 2019.11.19.15.29.21.317.0 ]--
r 83         return new Point(maxX, ma);
--[ 2019.11.19.15.29.21.491.0 ]--
r 83         return new Point(maxX, max);
--[ 2019.11.19.15.29.21.788.0 ]--
r 83         return new Point(maxX, maxX);
--[ 2019.11.19.15.29.21.997.0 ]--
r 83         return new Point(maxX, max);
--[ 2019.11.19.15.29.22.142.0 ]--
r 83         return new Point(maxX, maxY);
--[ 2019.11.19.15.29.23.038.0 ]--
r 83         return new Point(maxX, maxY); 
--[ 2019.11.19.15.29.23.092.0 ]--
r 83         return new Point(maxX, maxY);
--[ 2019.11.19.15.31.25.504.0 ]--
r 31         else if
--[ 2019.11.19.15.31.25.609.0 ]--
r 31         else i
--[ 2019.11.19.15.31.25.733.0 ]--
r 31         else 
--[ 2019.11.19.15.31.27.546.0 ]--
- 31
r 31         else }
--[ 2019.11.19.15.31.28.053.0 ]--
+ 31         else 
r 32     }
--[ 2019.11.19.15.31.29.520.0 ]--
r 31         else{ 
--[ 2019.11.19.15.31.29.692.0 ]--
+ 31         else{
+ 32  
r 33 }
--[ 2019.11.19.15.31.29.707.0 ]--
r 32 
r 33         }
--[ 2019.11.19.15.31.29.724.0 ]--
r 32             
--[ 2019.11.19.15.31.30.537.0 ]--
r 32              
--[ 2019.11.19.15.31.30.562.0 ]--
r 32             
--[ 2019.11.19.15.31.34.042.0 ]--
r 32             i
--[ 2019.11.19.15.31.34.148.0 ]--
r 32             if
--[ 2019.11.19.15.31.34.329.0 ]--
r 32             if()
--[ 2019.11.19.15.31.36.897.0 ]--
r 32             if( )
--[ 2019.11.19.15.31.36.945.0 ]--
r 32             if()
--[ 2019.11.19.15.31.38.704.0 ]--
r 32             if(m)
--[ 2019.11.19.15.31.38.785.0 ]--
r 32             if(mi)
--[ 2019.11.19.15.31.38.869.0 ]--
r 32             if(min)
--[ 2019.11.19.15.31.41.458.0 ]--
r 32             if(mi)
--[ 2019.11.19.15.31.41.572.0 ]--
r 32             if(m)
--[ 2019.11.19.15.31.41.677.0 ]--
r 32             if()
--[ 2019.11.19.15.31.41.808.0 ]--
r 32             if
--[ 2019.11.19.15.31.42.543.0 ]--
r 32             if()
--[ 2019.11.19.15.31.43.312.0 ]--
r 32             if(p)
--[ 2019.11.19.15.31.43.459.0 ]--
r 32             if(p.)
--[ 2019.11.19.15.31.43.673.0 ]--
r 32             if(p.y)
--[ 2019.11.19.15.31.44.020.0 ]--
r 32             if(p.y())
--[ 2019.11.19.15.31.44.360.0 ]--
r 32             if(p.y() )
--[ 2019.11.19.15.31.44.557.0 ]--
r 32             if(p.y() <)
--[ 2019.11.19.15.31.44.651.0 ]--
r 32             if(p.y() < )
--[ 2019.11.19.15.31.45.354.0 ]--
r 32             if(p.y() < m)
--[ 2019.11.19.15.31.45.420.0 ]--
r 32             if(p.y() < mi)
--[ 2019.11.19.15.31.45.466.0 ]--
r 32             if(p.y() < min)
--[ 2019.11.19.15.31.45.716.0 ]--
r 32             if(p.y() < minY)
--[ 2019.11.19.15.31.46.996.0 ]--
r 32             if(p.y() < minY){
--[ 2019.11.19.15.31.47.200.0 ]--
+ 33 
+ 34 }
--[ 2019.11.19.15.31.47.206.0 ]--
r 34             }
--[ 2019.11.19.15.31.47.215.0 ]--
r 33                 
--[ 2019.11.19.15.31.49.033.0 ]--
r 33                 m
--[ 2019.11.19.15.31.49.084.0 ]--
r 33                 mi
--[ 2019.11.19.15.31.49.162.0 ]--
r 33                 min
--[ 2019.11.19.15.31.53.495.0 ]--
r 33                 min 
--[ 2019.11.19.15.31.53.570.0 ]--
r 33                 min
--[ 2019.11.19.15.31.53.704.0 ]--
r 33                 mi
--[ 2019.11.19.15.31.53.826.0 ]--
r 33                 m
--[ 2019.11.19.15.31.53.981.0 ]--
r 33                 
--[ 2019.11.19.15.32.03.945.0 ]--
r 32             if(p.y() < minY ){
--[ 2019.11.19.15.32.04.379.0 ]--
r 32             if(p.y() < minY &){
--[ 2019.11.19.15.32.04.464.0 ]--
r 32             if(p.y() < minY &&){
--[ 2019.11.19.15.32.04.853.0 ]--
r 32             if(p.y() < minY && ){
--[ 2019.11.19.15.32.06.392.0 ]--
r 32             if(p.y() < minY && p){
--[ 2019.11.19.15.32.06.466.0 ]--
r 32             if(p.y() < minY && p.){
--[ 2019.11.19.15.32.06.888.0 ]--
r 32             if(p.y() < minY && p. ){
--[ 2019.11.19.15.32.07.053.0 ]--
r 32             if(p.y() < minY && p.){
--[ 2019.11.19.15.32.07.584.0 ]--
r 32             if(p.y() < minY && p){
--[ 2019.11.19.15.32.07.744.0 ]--
r 32             if(p.y() < minY && ){
--[ 2019.11.19.15.32.07.977.0 ]--
r 32             if(p.y() < minY &&){
--[ 2019.11.19.15.32.08.321.0 ]--
r 32             if(p.y() < minY &){
--[ 2019.11.19.15.32.08.437.0 ]--
r 32             if(p.y() < minY ){
--[ 2019.11.19.15.32.08.565.0 ]--
r 32             if(p.y() < minY){
--[ 2019.11.19.15.36.40.558.0 ]--
r 32             if(p.y() < minY ){
--[ 2019.11.19.15.36.40.668.0 ]--
r 32             if(p.y() < minY){
--[ 2019.11.19.15.36.46.502.0 ]--
r 33                  
--[ 2019.11.19.15.36.46.562.0 ]--
r 33                 
--[ 2019.11.19.15.36.47.697.0 ]--
- 33
--[ 2019.11.19.15.36.48.233.0 ]--
+ 33                 
--[ 2019.11.19.15.36.55.480.0 ]--
r 33                 m
--[ 2019.11.19.15.36.55.560.0 ]--
r 33                 mi
--[ 2019.11.19.15.36.55.625.0 ]--
r 33                 min
--[ 2019.11.19.15.36.55.918.0 ]--
r 33                 minY
--[ 2019.11.19.15.36.56.296.0 ]--
r 33                 minY 
--[ 2019.11.19.15.36.56.679.0 ]--
r 33                 minY=
--[ 2019.11.19.15.36.57.354.0 ]--
r 33                 minY
--[ 2019.11.19.15.36.57.507.0 ]--
r 33                 minY 
--[ 2019.11.19.15.36.57.575.0 ]--
r 33                 minY =
--[ 2019.11.19.15.36.57.648.0 ]--
r 33                 minY = 
--[ 2019.11.19.15.36.57.750.0 ]--
r 33                 minY = []
--[ 2019.11.19.15.36.58.234.0 ]--
r 33                 minY = 
--[ 2019.11.19.15.36.58.411.0 ]--
r 33                 minY = p
--[ 2019.11.19.15.36.58.616.0 ]--
r 33                 minY = p.
--[ 2019.11.19.15.36.59.287.0 ]--
r 33                 minY = p.y
--[ 2019.11.19.15.36.59.474.0 ]--
r 33                 minY = p.y*()
--[ 2019.11.19.15.36.59.910.0 ]--
r 33                 minY = p.y*(
--[ 2019.11.19.15.37.00.029.0 ]--
r 33                 minY = p.y*
--[ 2019.11.19.15.37.00.267.0 ]--
r 33                 minY = p.y*()
--[ 2019.11.19.15.37.00.493.0 ]--
r 33                 minY = p.y*(
--[ 2019.11.19.15.37.00.603.0 ]--
r 33                 minY = p.y*
--[ 2019.11.19.15.37.00.713.0 ]--
r 33                 minY = p.y
--[ 2019.11.19.15.37.00.886.0 ]--
r 33                 minY = p.y()
--[ 2019.11.19.15.37.01.711.0 ]--
r 33                 minY = p.y() 
--[ 2019.11.19.15.37.01.734.0 ]--
r 33                 minY = p.y()
--[ 2019.11.19.15.37.03.597.0 ]--
r 34             
--[ 2019.11.19.15.37.04.086.0 ]--
r 34             }
--[ 2019.11.19.15.37.07.054.0 ]--
r 33                 minY = p.y();
--[ 2019.11.19.15.37.19.648.0 ]--
+ 35             
--[ 2019.11.19.15.37.19.838.0 ]--
r 35             e
--[ 2019.11.19.15.37.19.912.0 ]--
r 35             el
--[ 2019.11.19.15.37.20.007.0 ]--
r 35             els
--[ 2019.11.19.15.37.20.154.0 ]--
r 35             else
--[ 2019.11.19.15.37.20.364.0 ]--
r 35             else()
--[ 2019.11.19.15.37.20.497.0 ]--
r 35             else(i)
--[ 2019.11.19.15.37.20.577.0 ]--
r 35             else(if)
--[ 2019.11.19.15.37.21.252.0 ]--
r 35             else(if )
--[ 2019.11.19.15.37.22.364.0 ]--
r 35             else(if)
--[ 2019.11.19.15.37.22.473.0 ]--
r 35             else(i)
--[ 2019.11.19.15.37.22.585.0 ]--
r 35             else()
--[ 2019.11.19.15.37.22.706.0 ]--
r 35             else
--[ 2019.11.19.15.37.23.047.0 ]--
r 35             else 
--[ 2019.11.19.15.37.23.125.0 ]--
r 35             else i
--[ 2019.11.19.15.37.23.215.0 ]--
r 35             else if
--[ 2019.11.19.15.37.23.422.0 ]--
r 35             else if()
--[ 2019.11.19.15.37.23.848.0 ]--
r 35             else if(p)
--[ 2019.11.19.15.37.23.967.0 ]--
r 35             else if(py)
--[ 2019.11.19.15.37.24.076.0 ]--
r 35             else if(py.)
--[ 2019.11.19.15.37.24.561.0 ]--
r 35             else if(py)
--[ 2019.11.19.15.37.24.663.0 ]--
r 35             else if(p)
--[ 2019.11.19.15.37.24.804.0 ]--
r 35             else if(p.)
--[ 2019.11.19.15.37.24.889.0 ]--
r 35             else if(p.y)
--[ 2019.11.19.15.37.25.501.0 ]--
r 35             else if(p.y())
--[ 2019.11.19.15.37.25.869.0 ]--
r 35             else if(p.y() )
--[ 2019.11.19.15.37.26.725.0 ]--
r 35             else if(p.y() >)
--[ 2019.11.19.15.37.26.881.0 ]--
r 35             else if(p.y() > )
--[ 2019.11.19.15.37.27.086.0 ]--
r 35             else if(p.y() > m)
--[ 2019.11.19.15.37.27.153.0 ]--
r 35             else if(p.y() > mi)
--[ 2019.11.19.15.37.27.226.0 ]--
r 35             else if(p.y() > min)
--[ 2019.11.19.15.37.27.483.0 ]--
r 35             else if(p.y() > mi)
--[ 2019.11.19.15.37.27.542.0 ]--
r 35             else if(p.y() > m)
--[ 2019.11.19.15.37.27.672.0 ]--
r 35             else if(p.y() > )
--[ 2019.11.19.15.37.27.832.0 ]--
r 35             else if(p.y() > m)
--[ 2019.11.19.15.37.27.905.0 ]--
r 35             else if(p.y() > ma)
--[ 2019.11.19.15.37.28.067.0 ]--
r 35             else if(p.y() > max)
--[ 2019.11.19.15.37.28.436.0 ]--
r 35             else if(p.y() > maxY)
--[ 2019.11.19.15.37.28.687.0 ]--
r 35             else if(p.y() > maxY )
--[ 2019.11.19.15.37.28.777.0 ]--
r 35             else if(p.y() > maxY)
--[ 2019.11.19.15.37.30.231.0 ]--
r 35             else if(p.y() > maxY){
--[ 2019.11.19.15.37.30.413.0 ]--
+ 36 
+ 37 }
--[ 2019.11.19.15.37.30.420.0 ]--
r 37             }
--[ 2019.11.19.15.37.30.438.0 ]--
r 36                 
--[ 2019.11.19.15.37.31.334.0 ]--
r 36                 m
--[ 2019.11.19.15.37.31.406.0 ]--
r 36                 ma
--[ 2019.11.19.15.37.31.537.0 ]--
r 36                 max
--[ 2019.11.19.15.37.31.773.0 ]--
r 36                 maxY
--[ 2019.11.19.15.37.32.158.0 ]--
r 36                 maxY 
--[ 2019.11.19.15.37.32.298.0 ]--
r 36                 maxY =
--[ 2019.11.19.15.37.32.367.0 ]--
r 36                 maxY = 
--[ 2019.11.19.15.37.32.892.0 ]--
r 36                 maxY = p
--[ 2019.11.19.15.37.32.991.0 ]--
r 36                 maxY = py
--[ 2019.11.19.15.37.33.064.0 ]--
r 36                 maxY = py.
--[ 2019.11.19.15.37.33.504.0 ]--
r 36                 maxY = py
--[ 2019.11.19.15.37.33.601.0 ]--
r 36                 maxY = p
--[ 2019.11.19.15.37.33.840.0 ]--
r 36                 maxY = p.
--[ 2019.11.19.15.37.33.909.0 ]--
r 36                 maxY = p.y
--[ 2019.11.19.15.37.34.134.0 ]--
r 36                 maxY = p.y()
--[ 2019.11.19.15.37.35.502.0 ]--
r 36                 maxY = p.y();
--[ 2019.11.19.15.37.36.819.0 ]--
+ 38             
--[ 2019.11.19.15.37.37.032.0 ]--
r 38             e
--[ 2019.11.19.15.37.37.109.0 ]--
r 38             el
--[ 2019.11.19.15.37.37.182.0 ]--
r 38             els
--[ 2019.11.19.15.37.37.329.0 ]--
r 38             else
--[ 2019.11.19.15.37.37.786.0 ]--
r 38             else 
--[ 2019.11.19.15.37.37.870.0 ]--
r 38             else i
--[ 2019.11.19.15.37.37.944.0 ]--
r 38             else if
--[ 2019.11.19.15.37.38.118.0 ]--
r 38             else if()
--[ 2019.11.19.15.37.40.325.0 ]--
r 38             else if(p)
--[ 2019.11.19.15.37.40.374.0 ]--
r 38             else if(p.)
--[ 2019.11.19.15.37.40.527.0 ]--
r 38             else if(p.x)
--[ 2019.11.19.15.37.46.733.0 ]--
r 38             else if(p.x
--[ 2019.11.19.15.37.46.981.0 ]--
r 38             else if(p.x()
--[ 2019.11.19.15.37.47.022.0 ]--
r 38             else if(p.x())
--[ 2019.11.19.15.37.47.145.0 ]--
r 38             else if(p.x() )
--[ 2019.11.19.15.37.47.528.0 ]--
r 38             else if(p.x() M)
--[ 2019.11.19.15.37.48.304.0 ]--
r 38             else if(p.x() )
--[ 2019.11.19.15.37.48.501.0 ]--
r 38             else if(p.x() <)
--[ 2019.11.19.15.37.48.612.0 ]--
r 38             else if(p.x() < )
--[ 2019.11.19.15.37.50.621.0 ]--
r 38             else if(p.x() <  )
--[ 2019.11.19.15.37.50.670.0 ]--
r 38             else if(p.x() < )
--[ 2019.11.19.15.37.50.950.0 ]--
r 38             else if(p.x() < m)
--[ 2019.11.19.15.37.51.026.0 ]--
r 38             else if(p.x() < mi)
--[ 2019.11.19.15.37.51.108.0 ]--
r 38             else if(p.x() < min)
--[ 2019.11.19.15.37.51.567.0 ]--
r 38             else if(p.x() < minX)
--[ 2019.11.19.15.37.54.216.0 ]--
r 38             else if(p.x() < minX){
--[ 2019.11.19.15.37.54.385.0 ]--
+ 39 
+ 40 }
--[ 2019.11.19.15.37.54.404.0 ]--
r 40             }
--[ 2019.11.19.15.37.54.428.0 ]--
r 39                 
--[ 2019.11.19.15.37.55.231.0 ]--
r 39                 m
--[ 2019.11.19.15.37.55.349.0 ]--
r 39                 mi
--[ 2019.11.19.15.37.55.401.0 ]--
r 39                 min
--[ 2019.11.19.15.37.56.083.0 ]--
r 39                 minX
--[ 2019.11.19.15.37.56.306.0 ]--
r 39                 minX 
--[ 2019.11.19.15.37.56.445.0 ]--
r 39                 minX =
--[ 2019.11.19.15.37.56.578.0 ]--
r 39                 minX = 
--[ 2019.11.19.15.37.57.391.0 ]--
r 39                 minX = p
--[ 2019.11.19.15.37.57.437.0 ]--
r 39                 minX = p.
--[ 2019.11.19.15.37.57.683.0 ]--
r 39                 minX = p.x
--[ 2019.11.19.15.37.57.935.0 ]--
r 39                 minX = p.x()
--[ 2019.11.19.15.37.58.926.0 ]--
r 39                 minX = p.x();
--[ 2019.11.19.15.37.59.552.0 ]--
+ 41             
--[ 2019.11.19.15.37.59.706.0 ]--
r 41             e
--[ 2019.11.19.15.37.59.806.0 ]--
r 41             el
--[ 2019.11.19.15.37.59.846.0 ]--
r 41             els
--[ 2019.11.19.15.38.00.042.0 ]--
r 41             else
--[ 2019.11.19.15.38.00.338.0 ]--
r 41             else()
--[ 2019.11.19.15.38.00.810.0 ]--
r 41             else
--[ 2019.11.19.15.38.01.582.0 ]--
r 41             else 
--[ 2019.11.19.15.38.01.730.0 ]--
r 41             else i
--[ 2019.11.19.15.38.01.873.0 ]--
r 41             else if
--[ 2019.11.19.15.38.02.077.0 ]--
r 41             else if()
--[ 2019.11.19.15.38.02.325.0 ]--
r 41             else if(p)
--[ 2019.11.19.15.38.02.752.0 ]--
r 41             else if(p.)
--[ 2019.11.19.15.38.03.111.0 ]--
r 41             else if(p.x)
--[ 2019.11.19.15.38.03.366.0 ]--
r 41             else if(p.x())
--[ 2019.11.19.15.38.03.754.0 ]--
r 41             else if(p.x() )
--[ 2019.11.19.15.38.03.948.0 ]--
r 41             else if(p.x() >)
--[ 2019.11.19.15.38.04.078.0 ]--
r 41             else if(p.x() > )
--[ 2019.11.19.15.38.04.435.0 ]--
r 41             else if(p.x() > m)
--[ 2019.11.19.15.38.04.515.0 ]--
r 41             else if(p.x() > mi)
--[ 2019.11.19.15.38.04.566.0 ]--
r 41             else if(p.x() > min)
--[ 2019.11.19.15.38.04.830.0 ]--
r 41             else if(p.x() > minX)
--[ 2019.11.19.15.38.05.148.0 ]--
r 41             else if(p.x() > minX())
--[ 2019.11.19.15.38.06.077.0 ]--
r 41             else if(p.x() > minX()
--[ 2019.11.19.15.38.06.185.0 ]--
r 41             else if(p.x() > minX)
--[ 2019.11.19.15.38.06.888.0 ]--
r 41             else if(p.x() > minX){
--[ 2019.11.19.15.38.06.912.0 ]--
r 41             else if(p.x() > minX){P
--[ 2019.11.19.15.38.07.444.0 ]--
r 41             else if(p.x() > minX){
--[ 2019.11.19.15.38.07.900.0 ]--
+ 42 
+ 43 }
--[ 2019.11.19.15.38.07.906.0 ]--
r 43             }
--[ 2019.11.19.15.38.07.920.0 ]--
r 42                 
--[ 2019.11.19.15.38.11.789.0 ]--
r 42                 m
--[ 2019.11.19.15.38.11.854.0 ]--
r 42                 mi
--[ 2019.11.19.15.38.11.943.0 ]--
r 42                 min
--[ 2019.11.19.15.38.12.144.0 ]--
r 42                 mi
--[ 2019.11.19.15.38.12.237.0 ]--
r 42                 m
--[ 2019.11.19.15.38.12.341.0 ]--
r 42                 
--[ 2019.11.19.15.38.12.492.0 ]--
r 42                 m
--[ 2019.11.19.15.38.12.571.0 ]--
r 42                 ma
--[ 2019.11.19.15.38.12.715.0 ]--
r 42                 max
--[ 2019.11.19.15.38.12.981.0 ]--
r 42                 maxX
--[ 2019.11.19.15.38.14.093.0 ]--
r 42                 maxX 
--[ 2019.11.19.15.38.14.145.0 ]--
r 42                 maxX =
--[ 2019.11.19.15.38.14.257.0 ]--
r 42                 maxX = 
--[ 2019.11.19.15.38.14.316.0 ]--
r 42                 maxX = p
--[ 2019.11.19.15.38.15.719.0 ]--
r 42                 maxX = p.
--[ 2019.11.19.15.38.15.809.0 ]--
r 42                 maxX = p.x
--[ 2019.11.19.15.38.15.965.0 ]--
r 42                 maxX = p.x()
--[ 2019.11.19.15.38.16.225.0 ]--
r 42                 maxX = p.x();
--[ 2019.11.19.15.38.16.473.0 ]--
r 42                 maxX = p.x(); 
--[ 2019.11.19.15.38.16.556.0 ]--
r 42                 maxX = p.x();
--[ 2019.11.19.15.38.25.197.0 ]--
r 38             if(p.x() < minX){
--[ 2019.11.19.15.38.46.425.0 ]--
+ 96         
--[ 2019.11.19.15.38.51.421.0 ]--
r 96          
--[ 2019.11.19.15.38.51.448.0 ]--
r 96         
--[ 2019.11.19.15.38.51.617.0 ]--
r 96         P
--[ 2019.11.19.15.38.51.766.0 ]--
r 96         Po
--[ 2019.11.19.15.38.51.921.0 ]--
r 96         Poi
--[ 2019.11.19.15.38.51.953.0 ]--
r 96         Poin
--[ 2019.11.19.15.38.52.070.0 ]--
r 96         Point
--[ 2019.11.19.15.38.52.277.0 ]--
r 96         Point()
--[ 2019.11.19.15.38.53.028.0 ]--
r 96         Point( )
--[ 2019.11.19.15.38.53.093.0 ]--
r 96         Point()
--[ 2019.11.19.15.38.53.255.0 ]--
r 96         Point
--[ 2019.11.19.15.38.53.604.0 ]--
r 96         
--[ 2019.11.19.15.38.54.434.0 ]--
r 96         t
--[ 2019.11.19.15.38.54.487.0 ]--
r 96         te
--[ 2019.11.19.15.38.54.624.0 ]--
r 96         tes
--[ 2019.11.19.15.38.54.694.0 ]--
r 96         test
--[ 2019.11.19.15.38.55.054.0 ]--
r 96         test 
--[ 2019.11.19.15.38.55.064.0 ]--
r 96         test = 
--[ 2019.11.19.15.38.56.164.0 ]--
r 96         test 
--[ 2019.11.19.15.38.56.282.0 ]--
r 96         
--[ 2019.11.19.15.38.57.327.0 ]--
r 96         n
--[ 2019.11.19.15.38.57.380.0 ]--
r 96         ne
--[ 2019.11.19.15.38.57.514.0 ]--
r 96         new
--[ 2019.11.19.15.38.57.601.0 ]--
r 96         new 
--[ 2019.11.19.15.38.57.715.0 ]--
r 96         new P
--[ 2019.11.19.15.38.57.852.0 ]--
r 96         new Po
--[ 2019.11.19.15.38.57.991.0 ]--
r 96         new Poi
--[ 2019.11.19.15.38.58.046.0 ]--
r 96         new Poin
--[ 2019.11.19.15.38.58.090.0 ]--
r 96         new Point
--[ 2019.11.19.15.38.58.134.0 ]--
r 96         new Point 
--[ 2019.11.19.15.38.58.254.0 ]--
r 96         new Point t
--[ 2019.11.19.15.38.58.331.0 ]--
r 96         new Point te
--[ 2019.11.19.15.38.58.429.0 ]--
r 96         new Point tes
--[ 2019.11.19.15.38.58.542.0 ]--
r 96         new Point test
--[ 2019.11.19.15.38.58.594.0 ]--
r 96         new Point test 
--[ 2019.11.19.15.38.58.679.0 ]--
r 96         new Point test =
--[ 2019.11.19.15.38.58.772.0 ]--
r 96         new Point test = 
--[ 2019.11.19.15.38.59.225.0 ]--
r 96         new Point test 
--[ 2019.11.19.15.38.59.338.0 ]--
r 96         new Point 
--[ 2019.11.19.15.38.59.461.0 ]--
r 96         new 
--[ 2019.11.19.15.39.01.336.0 ]--
r 96         new P
--[ 2019.11.19.15.39.01.599.0 ]--
r 96         new Po
--[ 2019.11.19.15.39.01.782.0 ]--
r 96         new Poi
--[ 2019.11.19.15.39.01.818.0 ]--
r 96         new Poin
--[ 2019.11.19.15.39.01.975.0 ]--
r 96         new Point
--[ 2019.11.19.15.39.02.386.0 ]--
r 96         new Point 
--[ 2019.11.19.15.39.03.255.0 ]--
r 96         new 
--[ 2019.11.19.15.39.03.418.0 ]--
r 96         new t
--[ 2019.11.19.15.39.03.475.0 ]--
r 96         new te
--[ 2019.11.19.15.39.03.597.0 ]--
r 96         new tes
--[ 2019.11.19.15.39.03.727.0 ]--
r 96         new test
--[ 2019.11.19.15.39.03.785.0 ]--
r 96         new test 
--[ 2019.11.19.15.39.04.130.0 ]--
r 96         new 
--[ 2019.11.19.15.39.04.239.0 ]--
r 96         
--[ 2019.11.19.15.39.04.523.0 ]--
r 96         t
--[ 2019.11.19.15.39.04.808.0 ]--
r 96         
--[ 2019.11.19.15.39.05.314.0 ]--
r 96         P
--[ 2019.11.19.15.39.05.452.0 ]--
r 96         Po
--[ 2019.11.19.15.39.05.576.0 ]--
r 96         Poi
--[ 2019.11.19.15.39.05.658.0 ]--
r 96         Poin
--[ 2019.11.19.15.39.05.743.0 ]--
r 96         Point
--[ 2019.11.19.15.39.05.763.0 ]--
r 96         Point 
--[ 2019.11.19.15.39.05.821.0 ]--
r 96         Point t
--[ 2019.11.19.15.39.05.921.0 ]--
r 96         Point te
--[ 2019.11.19.15.39.06.321.0 ]--
r 96         Point tes
--[ 2019.11.19.15.39.06.408.0 ]--
r 96         Point test
--[ 2019.11.19.15.39.06.464.0 ]--
r 96         Point test 
--[ 2019.11.19.15.39.06.576.0 ]--
r 96         Point test =
--[ 2019.11.19.15.39.06.640.0 ]--
r 96         Point test = 
--[ 2019.11.19.15.39.06.710.0 ]--
r 96         Point test = n
--[ 2019.11.19.15.39.06.796.0 ]--
r 96         Point test = ne
--[ 2019.11.19.15.39.06.947.0 ]--
r 96         Point test = new
--[ 2019.11.19.15.39.07.005.0 ]--
r 96         Point test = new 
--[ 2019.11.19.15.39.07.123.0 ]--
r 96         Point test = new P
--[ 2019.11.19.15.39.07.263.0 ]--
r 96         Point test = new Po
--[ 2019.11.19.15.39.07.392.0 ]--
r 96         Point test = new Poi
--[ 2019.11.19.15.39.07.459.0 ]--
r 96         Point test = new Poin
--[ 2019.11.19.15.39.07.551.0 ]--
r 96         Point test = new Point
--[ 2019.11.19.15.39.07.740.0 ]--
r 96         Point test = new Point()
--[ 2019.11.19.15.39.09.197.0 ]--
r 96         Point test = new Point(m)
--[ 2019.11.19.15.39.09.267.0 ]--
r 96         Point test = new Point(ma)
--[ 2019.11.19.15.39.09.375.0 ]--
r 96         Point test = new Point(max)
--[ 2019.11.19.15.39.09.754.0 ]--
r 96         Point test = new Point(maxX)
--[ 2019.11.19.15.39.10.701.0 ]--
r 96         Point test = new Point(maxX,)
--[ 2019.11.19.15.39.10.749.0 ]--
r 96         Point test = new Point(maxX, )
--[ 2019.11.19.15.39.10.845.0 ]--
r 96         Point test = new Point(maxX, m)
--[ 2019.11.19.15.39.10.893.0 ]--
r 96         Point test = new Point(maxX, ma)
--[ 2019.11.19.15.39.11.006.0 ]--
r 96         Point test = new Point(maxX, max)
--[ 2019.11.19.15.39.11.549.0 ]--
r 96         Point test = new Point(maxX, maxY)
--[ 2019.11.19.15.39.12.409.0 ]--
r 96         Point test = new Point(maxX, maxY);
--[ 2019.11.19.15.39.12.600.0 ]--
+ 97         
--[ 2019.11.19.15.39.13.502.0 ]--
+ 97         
--[ 2019.11.19.15.39.13.710.0 ]--
r 98         c
--[ 2019.11.19.15.39.13.744.0 ]--
r 98         co
--[ 2019.11.19.15.39.13.817.0 ]--
r 98         con
--[ 2019.11.19.15.39.13.860.0 ]--
r 98         cons
--[ 2019.11.19.15.39.13.952.0 ]--
r 98         conso
--[ 2019.11.19.15.39.14.064.0 ]--
r 98         consol
--[ 2019.11.19.15.39.14.152.0 ]--
r 98         console
--[ 2019.11.19.15.39.14.243.0 ]--
r 98         console.
--[ 2019.11.19.15.39.14.610.0 ]--
r 98         console
--[ 2019.11.19.15.39.14.723.0 ]--
r 98         
--[ 2019.11.19.15.39.15.330.0 ]--
r 98         S
--[ 2019.11.19.15.39.15.728.0 ]--
r 98         Sy
--[ 2019.11.19.15.39.15.878.0 ]--
r 98         Sys
--[ 2019.11.19.15.39.15.959.0 ]--
r 98         Syst
--[ 2019.11.19.15.39.16.113.0 ]--
r 98         Syste
--[ 2019.11.19.15.39.16.898.0 ]--
r 98         Syst
--[ 2019.11.19.15.39.17.011.0 ]--
r 98         Sys
--[ 2019.11.19.15.39.17.117.0 ]--
r 98         Sy
--[ 2019.11.19.15.39.17.557.0 ]--
r 98         S
--[ 2019.11.19.15.39.17.607.0 ]--
r 98         St
--[ 2019.11.19.15.39.17.753.0 ]--
r 98         Std
--[ 2019.11.19.15.39.18.184.0 ]--
r 98         StdOut
--[ 2019.11.19.15.39.18.633.0 ]--
r 98         StdOut.
--[ 2019.11.19.15.39.19.219.0 ]--
r 98         StdOut.println
--[ 2019.11.19.15.39.19.225.0 ]--
r 98         StdOut.println()
--[ 2019.11.19.15.39.19.230.0 ]--
r 98         StdOut.println();
--[ 2019.11.19.15.39.20.749.0 ]--
r 98         StdOut.println(t);
--[ 2019.11.19.15.39.20.934.0 ]--
r 98         StdOut.println(ts);
--[ 2019.11.19.15.39.21.189.0 ]--
r 98         StdOut.println(t);
--[ 2019.11.19.15.39.21.242.0 ]--
r 98         StdOut.println(te);
--[ 2019.11.19.15.39.21.390.0 ]--
r 98         StdOut.println(tes);
--[ 2019.11.19.15.39.21.462.0 ]--
r 98         StdOut.println(test);
--[ 2019.11.19.15.39.21.565.0 ]--
r 98         StdOut.println(test.);
--[ 2019.11.19.15.39.21.839.0 ]--
r 98         StdOut.println(test.x);
--[ 2019.11.19.15.39.22.260.0 ]--
r 98         StdOut.println(test.x());
--[ 2019.11.19.15.39.23.270.0 ]--
+ 99         
--[ 2019.11.19.15.39.23.776.0 ]--
r 99         S
--[ 2019.11.19.15.39.23.892.0 ]--
r 99         St
--[ 2019.11.19.15.39.24.038.0 ]--
r 99         Std
--[ 2019.11.19.15.39.24.494.0 ]--
r 99         StdOut
--[ 2019.11.19.15.39.24.593.0 ]--
r 99         StdOut.
--[ 2019.11.19.15.39.25.096.0 ]--
r 99         StdOut.o
--[ 2019.11.19.15.39.25.682.0 ]--
r 99         StdOut.
--[ 2019.11.19.15.39.26.470.0 ]--
r 99         StdOut.p
--[ 2019.11.19.15.39.26.670.0 ]--
r 99         StdOut.println
--[ 2019.11.19.15.39.26.683.0 ]--
r 99         StdOut.println()
--[ 2019.11.19.15.39.26.694.0 ]--
r 99         StdOut.println();
--[ 2019.11.19.15.39.27.564.0 ]--
r 99         StdOut.println(t);
--[ 2019.11.19.15.39.27.621.0 ]--
r 99         StdOut.println(te);
--[ 2019.11.19.15.39.27.749.0 ]--
r 99         StdOut.println(tes);
--[ 2019.11.19.15.39.27.841.0 ]--
r 99         StdOut.println(test);
--[ 2019.11.19.15.39.27.952.0 ]--
r 99         StdOut.println(test.);
--[ 2019.11.19.15.39.28.421.0 ]--
r 99         StdOut.println(test.y);
--[ 2019.11.19.15.39.28.611.0 ]--
r 99         StdOut.println(test.y*);
--[ 2019.11.19.15.39.28.637.0 ]--
r 99         StdOut.println(test.y*());
--[ 2019.11.19.15.39.29.059.0 ]--
r 99         StdOut.println(test.y*);
--[ 2019.11.19.15.39.29.180.0 ]--
r 99         StdOut.println(test.y);
--[ 2019.11.19.15.39.29.569.0 ]--
r 99         StdOut.println(test.);
--[ 2019.11.19.15.39.29.813.0 ]--
r 99         StdOut.println(test.());
--[ 2019.11.19.15.39.31.442.0 ]--
r 99         StdOut.println(testy.());
--[ 2019.11.19.15.39.32.018.0 ]--
r 99         StdOut.println(test.());
--[ 2019.11.19.15.39.32.357.0 ]--
r 99         StdOut.println(test.y());
--[ 2019.11.19.15.39.44.970.0 ]--
- 98
- 98
--[ 2019.11.19.15.39.45.250.0 ]--
- 97
--[ 2019.11.19.15.39.45.499.0 ]--
r 96         Point test = new Point(maxX, maxY); 
--[ 2019.11.19.15.39.45.571.0 ]--
r 96         Point test = new Point(maxX, maxY);
--[ 2019.11.19.15.39.54.781.0 ]--
+ 45         
--[ 2019.11.19.15.39.55.866.0 ]--
+ 46         StdOut.println(test.x());
+ 47         StdOut.println(test.y());
--[ 2019.11.19.15.39.55.877.0 ]--
r 45 
--[ 2019.11.19.15.39.58.859.0 ]--
r 46         StdOut.println(p.x());
--[ 2019.11.19.15.40.00.714.0 ]--
r 47         StdOut.println(.y());
--[ 2019.11.19.15.40.00.780.0 ]--
r 47         StdOut.println(p.y());
--[ 2019.11.19.15.40.07.009.0 ]--
- 46
- 46
--[ 2019.11.19.15.40.07.352.0 ]--
- 45
--[ 2019.11.19.15.40.07.608.0 ]--
r 44         } 
--[ 2019.11.19.15.40.07.662.0 ]--
r 44         }
--[ 2019.11.19.15.40.50.205.0 ]--
r 15 
--[ 2019.11.19.15.40.51.394.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.41.13.777.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.41.35.978.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.42.29.503.0 ]--
r 32             if(p.y() <= minY){
--[ 2019.11.19.15.42.31.192.0 ]--
r 35             else if(p.y() => maxY){
--[ 2019.11.19.15.42.32.484.0 ]--
r 38             if(p.x() <= minX){
--[ 2019.11.19.15.42.33.612.0 ]--
r 41             else if(p.x() >= minX){
--[ 2019.11.19.15.42.34.236.0 ]--
r 41             else if(p.x() > minX){
--[ 2019.11.19.15.42.34.553.0 ]--
r 41             else if(p.x() => minX){
--[ 2019.11.19.15.42.36.247.0 ]--
r 41             else if(p.x() > minX){
--[ 2019.11.19.15.42.36.772.0 ]--
r 41             else if(p.x() >- minX){
--[ 2019.11.19.15.42.38.047.0 ]--
r 41             else if(p.x() > minX){
--[ 2019.11.19.15.42.38.156.0 ]--
r 41             else if(p.x() >= minX){
--[ 2019.11.19.15.42.39.604.0 ]--
r 35             else if(p.y() > maxY){
--[ 2019.11.19.15.42.40.160.0 ]--
r 35             else if(p.y() >= maxY){
--[ 2019.11.19.15.42.42.270.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.43.36.358.0 ]--
r 96         
--[ 2019.11.19.15.43.36.866.0 ]--
- 96
--[ 2019.11.19.15.46.18.399.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.46.50.718.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.47.25.191.0 ]--
r 41             else if(p.x() >= miX){
--[ 2019.11.19.15.47.25.287.0 ]--
r 41             else if(p.x() >= mX){
--[ 2019.11.19.15.47.25.686.0 ]--
r 41             else if(p.x() >= maX){
--[ 2019.11.19.15.47.25.848.0 ]--
r 41             else if(p.x() >= maxX){
--[ 2019.11.19.15.47.31.178.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.49.25.581.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.49.43.618.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.15.53.03.294.0 ]--
DisposeComponent
--[ 2019.11.19.16.08.43.967.0 ]--
DisposeComponent
--[ 2019.11.19.16.08.56.813.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.19.16.08.56.875.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.19.16.08.56.876.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.19.16.08.56.876.1 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.19.16.08.56.877.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.19.16.08.56.877.1 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.19.16.08.56.877.2 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.19.16.08.56.878.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.19.16.08.56.878.1 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.19.16.08.56.878.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.19.16.08.56.878.3 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        //Doesn't work properly, but at least gives something to be visualized
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        kmin = new Point[k];


        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.19.16.08.56.879.0 ]--
InitFile: /.cos265


--[ 2019.11.19.16.08.56.879.1 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.19.16.08.56.879.2 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.19.16.08.56.880.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.19.16.09.25.886.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.16.09.48.780.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.19.16.23.02.876.0 ]--
DisposeComponent
--[ 2019.11.19.19.22.32.200.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.19.19.22.32.354.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.19.19.22.32.365.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.19.19.22.32.366.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.19.19.22.32.366.1 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.19.19.22.32.367.0 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.19.19.22.32.367.1 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.19.19.22.32.368.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.19.19.22.32.368.1 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.19.19.22.32.368.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.19.19.22.32.369.0 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        //Doesn't work properly, but at least gives something to be visualized
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        kmin = new Point[k];


        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.19.19.22.32.369.1 ]--
InitFile: /.cos265


--[ 2019.11.19.19.22.32.369.2 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.19.19.22.32.370.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.19.19.22.32.370.1 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.19.19.22.52.436.0 ]--
:/src/PSBruteForce.java
r 96         return new Point(maxX, maxY);lp
--[ 2019.11.19.19.23.06.672.0 ]--
r 96         return new Point(maxX, maxY);
--[ 2019.11.19.19.23.19.050.0 ]--
r 67         
--[ 2019.11.19.19.23.19.496.0 ]--
- 67
--[ 2019.11.19.19.23.25.633.0 ]--
- 101
r 101         
--[ 2019.11.19.19.23.26.401.0 ]--
+ 101         
+ 102         
--[ 2019.11.19.19.23.29.763.0 ]--
r 102         /
--[ 2019.11.19.19.23.29.894.0 ]--
r 102         /*
--[ 2019.11.19.19.23.31.130.0 ]--
r 102         /*P
--[ 2019.11.19.19.23.31.386.0 ]--
r 102         /*
--[ 2019.11.19.19.23.31.605.0 ]--
r 102         /* 
--[ 2019.11.19.19.23.31.682.0 ]--
r 102         /* P
--[ 2019.11.19.19.23.31.971.0 ]--
r 102         /* Ps
--[ 2019.11.19.19.23.32.075.0 ]--
r 102         /* Pse
--[ 2019.11.19.19.23.32.270.0 ]--
r 102         /* Pseud
--[ 2019.11.19.19.23.32.387.0 ]--
r 102         /* Pseudo
--[ 2019.11.19.19.23.32.536.0 ]--
r 102         /* Pseudo 
--[ 2019.11.19.19.23.32.953.0 ]--
r 102         /* Pseudo c
--[ 2019.11.19.19.23.33.102.0 ]--
r 102         /* Pseudo cod
--[ 2019.11.19.19.23.33.175.0 ]--
r 102         /* Pseudo code
--[ 2019.11.19.19.23.34.571.0 ]--
+ 103         
+ 104          */
--[ 2019.11.19.19.23.36.848.0 ]--
+ 103         
--[ 2019.11.19.19.23.37.706.0 ]--
r 103             
--[ 2019.11.19.19.23.38.225.0 ]--
r 103            
--[ 2019.11.19.19.23.38.848.0 ]--
r 103           
--[ 2019.11.19.19.23.38.907.0 ]--
r 103          
--[ 2019.11.19.19.23.39.065.0 ]--
r 103         
--[ 2019.11.19.19.23.42.727.0 ]--
r 103          
--[ 2019.11.19.19.23.42.781.0 ]--
r 103         
--[ 2019.11.19.19.23.42.924.0 ]--
r 103         f
--[ 2019.11.19.19.23.43.123.0 ]--
r 103         fr
--[ 2019.11.19.19.23.43.207.0 ]--
r 103         fr 
--[ 2019.11.19.19.23.43.651.0 ]--
r 103         f
--[ 2019.11.19.19.23.44.075.0 ]--
r 103         fo
--[ 2019.11.19.19.23.44.139.0 ]--
r 103         for
--[ 2019.11.19.19.23.44.199.0 ]--
r 103         for 
--[ 2019.11.19.19.23.44.305.0 ]--
r 103         for i
--[ 2019.11.19.19.23.44.555.0 ]--
r 103         for i 
--[ 2019.11.19.19.23.44.637.0 ]--
r 103         for i in
--[ 2019.11.19.19.23.44.691.0 ]--
r 103         for i in 
--[ 2019.11.19.19.23.44.906.0 ]--
r 103         for i in k
--[ 2019.11.19.19.23.45.274.0 ]--
r 103         for i in k:
--[ 2019.11.19.19.23.45.761.0 ]--
r 103         for i in k
--[ 2019.11.19.19.23.46.471.0 ]--
r 103         for i in k{
--[ 2019.11.19.19.23.46.623.0 ]--
+ 104         
--[ 2019.11.19.19.23.47.406.0 ]--
+ 104         
--[ 2019.11.19.19.23.47.765.0 ]--
r 105         }
--[ 2019.11.19.19.23.49.367.0 ]--
r 104             
--[ 2019.11.19.19.23.53.666.0 ]--
r 104             a
--[ 2019.11.19.19.23.53.811.0 ]--
r 104             ad
--[ 2019.11.19.19.23.53.924.0 ]--
r 104             add
--[ 2019.11.19.19.23.54.343.0 ]--
r 104             add 
--[ 2019.11.19.19.23.55.230.0 ]--
r 104             add
--[ 2019.11.19.19.23.55.337.0 ]--
r 104             ad
--[ 2019.11.19.19.23.55.458.0 ]--
r 104             a
--[ 2019.11.19.19.23.56.191.0 ]--
r 104             
--[ 2019.11.19.19.23.58.721.0 ]--
+ 103         
--[ 2019.11.19.19.23.59.162.0 ]--
r 103         n
--[ 2019.11.19.19.23.59.255.0 ]--
r 103         ne
--[ 2019.11.19.19.23.59.372.0 ]--
r 103         new
--[ 2019.11.19.19.23.59.586.0 ]--
r 103         new 
--[ 2019.11.19.19.24.00.495.0 ]--
r 103         new  
--[ 2019.11.19.19.24.00.545.0 ]--
r 103         new 
--[ 2019.11.19.19.24.02.074.0 ]--
r 103         new m
--[ 2019.11.19.19.24.02.148.0 ]--
r 103         new ma
--[ 2019.11.19.19.24.02.597.0 ]--
r 103         new m
--[ 2019.11.19.19.24.02.677.0 ]--
r 103         new 
--[ 2019.11.19.19.24.03.034.0 ]--
r 103         new m
--[ 2019.11.19.19.24.03.095.0 ]--
r 103         new ma
--[ 2019.11.19.19.24.03.251.0 ]--
r 103         new max
--[ 2019.11.19.19.24.03.415.0 ]--
r 103         new maxP
--[ 2019.11.19.19.24.03.535.0 ]--
r 103         new maxPQ
--[ 2019.11.19.19.24.03.703.0 ]--
r 103         new maxPQ 
--[ 2019.11.19.19.24.03.805.0 ]--
r 103         new maxPQ
--[ 2019.11.19.19.24.05.337.0 ]--
r 105             a
--[ 2019.11.19.19.24.05.409.0 ]--
r 105             ad
--[ 2019.11.19.19.24.05.892.0 ]--
r 105             add
--[ 2019.11.19.19.24.06.086.0 ]--
r 105             add 
--[ 2019.11.19.19.24.11.257.0 ]--
r 105             add p
--[ 2019.11.19.19.24.11.413.0 ]--
r 105             add p 
--[ 2019.11.19.19.24.11.606.0 ]--
r 105             add p t
--[ 2019.11.19.19.24.11.658.0 ]--
r 105             add p to
--[ 2019.11.19.19.24.11.757.0 ]--
r 105             add p to 
--[ 2019.11.19.19.24.12.211.0 ]--
r 105             add p to m
--[ 2019.11.19.19.24.12.303.0 ]--
r 105             add p to ma
--[ 2019.11.19.19.24.12.424.0 ]--
r 105             add p to max
--[ 2019.11.19.19.24.12.668.0 ]--
r 105             add p to maxP
--[ 2019.11.19.19.24.12.802.0 ]--
r 105             add p to maxPQ
--[ 2019.11.19.19.24.13.714.0 ]--
r 105             add p to maxPQ 
--[ 2019.11.19.19.24.13.750.0 ]--
r 105             add p to maxPQ
--[ 2019.11.19.19.24.15.119.0 ]--
+ 107         
--[ 2019.11.19.19.24.15.840.0 ]--
r 107        
--[ 2019.11.19.19.24.16.530.0 ]--
r 107       
--[ 2019.11.19.19.24.16.831.0 ]--
r 107      
--[ 2019.11.19.19.24.17.126.0 ]--
r 107     
--[ 2019.11.19.19.24.17.324.0 ]--
r 107    
--[ 2019.11.19.19.24.17.591.0 ]--
r 107   
--[ 2019.11.19.19.24.17.832.0 ]--
r 107  
--[ 2019.11.19.19.24.18.132.0 ]--
r 107 
--[ 2019.11.19.19.24.18.461.0 ]--
- 107
--[ 2019.11.19.19.24.20.639.0 ]--
+ 106             
--[ 2019.11.19.19.24.21.533.0 ]--
r 106             i
--[ 2019.11.19.19.24.21.583.0 ]--
r 106             if
--[ 2019.11.19.19.24.21.701.0 ]--
r 106             if 
--[ 2019.11.19.19.24.21.807.0 ]--
r 106             if m
--[ 2019.11.19.19.24.21.920.0 ]--
r 106             if ma
--[ 2019.11.19.19.24.22.038.0 ]--
r 106             if max
--[ 2019.11.19.19.24.22.338.0 ]--
r 106             if maxP
--[ 2019.11.19.19.24.22.434.0 ]--
r 106             if maxPQ
--[ 2019.11.19.19.24.23.031.0 ]--
r 106             if maxPQ.
--[ 2019.11.19.19.24.23.133.0 ]--
r 106             if maxPQ.s
--[ 2019.11.19.19.24.23.210.0 ]--
r 106             if maxPQ.si
--[ 2019.11.19.19.24.23.276.0 ]--
r 106             if maxPQ.siz
--[ 2019.11.19.19.24.23.461.0 ]--
r 106             if maxPQ.size
--[ 2019.11.19.19.24.23.891.0 ]--
r 106             if maxPQ.size(
--[ 2019.11.19.19.24.23.952.0 ]--
r 106             if maxPQ.size()
--[ 2019.11.19.19.24.24.102.0 ]--
r 106             if maxPQ.size() 
--[ 2019.11.19.19.24.24.679.0 ]--
r 106             if maxPQ.size() >
--[ 2019.11.19.19.24.24.800.0 ]--
r 106             if maxPQ.size() > 
--[ 2019.11.19.19.24.24.922.0 ]--
r 106             if maxPQ.size() > 0
--[ 2019.11.19.19.24.27.152.0 ]--
r 106             if (maxPQ.size() > 0
--[ 2019.11.19.19.24.28.359.0 ]--
r 106             if(maxPQ.size() > 0
--[ 2019.11.19.19.24.30.436.0 ]--
r 106             if(maxPQ.size() > 
--[ 2019.11.19.19.24.30.597.0 ]--
r 106             if(maxPQ.size() > k
--[ 2019.11.19.19.24.30.804.0 ]--
r 106             if(maxPQ.size() > k)
--[ 2019.11.19.19.24.30.995.0 ]--
r 106             if(maxPQ.size() > k){
--[ 2019.11.19.19.24.31.383.0 ]--
+ 107             
--[ 2019.11.19.19.24.32.150.0 ]--
+ 107             
--[ 2019.11.19.19.24.32.431.0 ]--
r 108             }
--[ 2019.11.19.19.24.33.314.0 ]--
r 107                 
--[ 2019.11.19.19.24.34.311.0 ]--
r 107                 r
--[ 2019.11.19.19.24.34.446.0 ]--
r 107                 re
--[ 2019.11.19.19.24.34.570.0 ]--
r 107                 rem
--[ 2019.11.19.19.24.34.753.0 ]--
r 107                 remo
--[ 2019.11.19.19.24.34.865.0 ]--
r 107                 remov
--[ 2019.11.19.19.24.34.918.0 ]--
r 107                 remove
--[ 2019.11.19.19.24.35.060.0 ]--
r 107                 remove 
--[ 2019.11.19.19.24.36.374.0 ]--
r 107                 remove t
--[ 2019.11.19.19.24.36.499.0 ]--
r 107                 remove th
--[ 2019.11.19.19.24.36.562.0 ]--
r 107                 remove the
--[ 2019.11.19.19.24.36.672.0 ]--
r 107                 remove the 
--[ 2019.11.19.19.24.36.736.0 ]--
r 107                 remove the m
--[ 2019.11.19.19.24.36.804.0 ]--
r 107                 remove the ma
--[ 2019.11.19.19.24.36.924.0 ]--
r 107                 remove the max
--[ 2019.11.19.19.24.37.094.0 ]--
r 107                 remove the max 
--[ 2019.11.19.19.24.37.158.0 ]--
r 107                 remove the max f
--[ 2019.11.19.19.24.37.257.0 ]--
r 107                 remove the max fr
--[ 2019.11.19.19.24.37.354.0 ]--
r 107                 remove the max fro
--[ 2019.11.19.19.24.37.396.0 ]--
r 107                 remove the max from
--[ 2019.11.19.19.24.37.463.0 ]--
r 107                 remove the max from 
--[ 2019.11.19.19.24.37.526.0 ]--
r 107                 remove the max from t
--[ 2019.11.19.19.24.37.600.0 ]--
r 107                 remove the max from th
--[ 2019.11.19.19.24.37.686.0 ]--
r 107                 remove the max from the
--[ 2019.11.19.19.24.37.730.0 ]--
r 107                 remove the max from the 
--[ 2019.11.19.19.24.37.811.0 ]--
r 107                 remove the max from the l
--[ 2019.11.19.19.24.37.922.0 ]--
r 107                 remove the max from the li
--[ 2019.11.19.19.24.37.955.0 ]--
r 107                 remove the max from the lis
--[ 2019.11.19.19.24.38.032.0 ]--
r 107                 remove the max from the list
--[ 2019.11.19.19.24.38.691.0 ]--
r 107                 remove the max from the list 
--[ 2019.11.19.19.24.38.739.0 ]--
r 107                 remove the max from the list
--[ 2019.11.19.19.25.14.932.0 ]--
r 101 
r 110 
r 112 
--[ 2019.11.19.19.25.16.533.0 ]--
DisposeComponent
--[ 2019.11.20.10.02.45.823.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.20.10.02.46.168.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.20.10.02.46.169.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.20.10.02.46.169.1 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.20.10.02.46.170.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.20.10.02.46.170.1 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.20.10.02.46.170.2 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.20.10.02.46.170.3 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.20.10.02.46.171.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.20.10.02.46.171.1 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.20.10.02.46.171.2 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        kmin = new Point[k];

        /* Pseudo code
        new maxPQ
        for i in k{
            add p to maxPQ
            if(maxPQ.size() > k){
                remove the max from the list
            }
        }

         */

        return null;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.20.10.02.46.171.3 ]--
InitFile: /.cos265


--[ 2019.11.20.10.02.46.172.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.20.10.02.46.172.1 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.20.10.02.46.172.2 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.20.10.06.53.490.0 ]--
:/src/PSBruteForce.java
+ 110         
--[ 2019.11.20.10.06.53.521.0 ]--
+ 110         
--[ 2019.11.20.10.06.53.580.0 ]--
+ 110         
--[ 2019.11.20.10.06.54.858.0 ]--
r 112        
--[ 2019.11.20.10.06.55.678.0 ]--
r 112       
--[ 2019.11.20.10.06.56.146.0 ]--
r 112      
--[ 2019.11.20.10.06.56.390.0 ]--
r 112     
--[ 2019.11.20.10.06.56.548.0 ]--
r 112    
--[ 2019.11.20.10.06.56.757.0 ]--
r 112   
--[ 2019.11.20.10.06.56.975.0 ]--
r 112  
--[ 2019.11.20.10.06.57.146.0 ]--
r 112 
--[ 2019.11.20.10.06.57.401.0 ]--
- 112
--[ 2019.11.20.10.06.57.714.0 ]--
r 111        
--[ 2019.11.20.10.06.58.056.0 ]--
r 111       
--[ 2019.11.20.10.06.58.172.0 ]--
r 111      
--[ 2019.11.20.10.06.58.531.0 ]--
r 111     
--[ 2019.11.20.10.06.58.556.0 ]--
r 111    
--[ 2019.11.20.10.06.58.591.0 ]--
r 111   
--[ 2019.11.20.10.06.58.658.0 ]--
r 111  
--[ 2019.11.20.10.06.58.802.0 ]--
r 111 
--[ 2019.11.20.10.06.58.896.0 ]--
- 111
--[ 2019.11.20.10.06.59.068.0 ]--
r 110        
--[ 2019.11.20.10.06.59.176.0 ]--
r 110       
--[ 2019.11.20.10.06.59.259.0 ]--
r 110      
--[ 2019.11.20.10.06.59.370.0 ]--
r 110     
--[ 2019.11.20.10.06.59.630.0 ]--
r 110    
--[ 2019.11.20.10.06.59.798.0 ]--
r 110   
--[ 2019.11.20.10.07.00.010.0 ]--
r 110  
--[ 2019.11.20.10.07.00.162.0 ]--
r 110 
--[ 2019.11.20.10.07.00.473.0 ]--
- 110
--[ 2019.11.20.10.07.00.875.0 ]--
r 109         } 
--[ 2019.11.20.10.07.00.894.0 ]--
r 109         }
--[ 2019.11.20.10.07.02.283.0 ]--
+ 112          
--[ 2019.11.20.10.07.02.317.0 ]--
r 112         
--[ 2019.11.20.10.07.09.032.0 ]--
r 112         ma
--[ 2019.11.20.10.07.09.052.0 ]--
r 112         max
--[ 2019.11.20.10.07.09.367.0 ]--
r 112         maxP
--[ 2019.11.20.10.07.09.771.0 ]--
r 112         max
--[ 2019.11.20.10.07.09.947.0 ]--
r 112         ma
--[ 2019.11.20.10.07.10.053.0 ]--
r 112         m
--[ 2019.11.20.10.07.10.235.0 ]--
r 112         
--[ 2019.11.20.10.07.11.404.0 ]--
r 112          
--[ 2019.11.20.10.07.11.452.0 ]--
r 112         
--[ 2019.11.20.10.07.11.598.0 ]--
r 112         m
--[ 2019.11.20.10.07.11.677.0 ]--
r 112         ma
--[ 2019.11.20.10.07.11.989.0 ]--
r 112         max
--[ 2019.11.20.10.07.12.810.0 ]--
r 112         maxi
--[ 2019.11.20.10.07.12.950.0 ]--
r 112         maxim
--[ 2019.11.20.10.07.13.421.0 ]--
r 112         maxim 
--[ 2019.11.20.10.07.13.475.0 ]--
r 112         maxim
--[ 2019.11.20.10.07.13.647.0 ]--
r 112         
--[ 2019.11.20.10.07.31.475.0 ]--
r 112         M
--[ 2019.11.20.10.07.32.451.0 ]--
r 112         Ma
--[ 2019.11.20.10.07.32.571.0 ]--
r 112         Max
--[ 2019.11.20.10.07.33.412.0 ]--
r 112         MaxP
--[ 2019.11.20.10.07.33.498.0 ]--
r 112         MaxPQ
--[ 2019.11.20.10.07.34.478.0 ]--
r 112         MaxPQ 
--[ 2019.11.20.10.07.37.344.0 ]--
r 112         MaxPQ  
--[ 2019.11.20.10.07.37.393.0 ]--
r 112         MaxPQ 
--[ 2019.11.20.10.07.37.576.0 ]--
r 112         MaxPQ p
--[ 2019.11.20.10.07.38.097.0 ]--
r 112         MaxPQ po
--[ 2019.11.20.10.07.38.285.0 ]--
r 112         MaxPQ poi
--[ 2019.11.20.10.07.38.351.0 ]--
r 112         MaxPQ poin
--[ 2019.11.20.10.07.38.418.0 ]--
r 112         MaxPQ point
--[ 2019.11.20.10.07.38.482.0 ]--
r 112         MaxPQ points
--[ 2019.11.20.10.07.39.037.0 ]--
r 112         MaxPQ points 
--[ 2019.11.20.10.07.39.113.0 ]--
r 112         MaxPQ points =
--[ 2019.11.20.10.07.39.219.0 ]--
r 112         MaxPQ points = 
--[ 2019.11.20.10.07.39.813.0 ]--
r 112         MaxPQ points = n
--[ 2019.11.20.10.07.39.895.0 ]--
r 112         MaxPQ points = ne
--[ 2019.11.20.10.07.39.990.0 ]--
r 112         MaxPQ points = new
--[ 2019.11.20.10.07.40.144.0 ]--
r 112         MaxPQ points = new 
--[ 2019.11.20.10.07.40.840.0 ]--
r 112         MaxPQ points = new A
--[ 2019.11.20.10.07.41.040.0 ]--
r 112         MaxPQ points = new 
--[ 2019.11.20.10.07.41.297.0 ]--
r 112         MaxPQ points = new M
--[ 2019.11.20.10.07.41.337.0 ]--
r 112         MaxPQ points = new MA
--[ 2019.11.20.10.07.41.519.0 ]--
r 112         MaxPQ points = new MAX
--[ 2019.11.20.10.07.41.972.0 ]--
r 112         MaxPQ points = new MA
--[ 2019.11.20.10.07.42.282.0 ]--
r 112         MaxPQ points = new MAa
--[ 2019.11.20.10.07.42.532.0 ]--
r 112         MaxPQ points = new MA
--[ 2019.11.20.10.07.42.629.0 ]--
r 112         MaxPQ points = new M
--[ 2019.11.20.10.07.42.723.0 ]--
r 112         MaxPQ points = new Ma
--[ 2019.11.20.10.07.42.839.0 ]--
r 112         MaxPQ points = new Max
--[ 2019.11.20.10.07.43.504.0 ]--
r 112         MaxPQ points = new MaxP
--[ 2019.11.20.10.07.43.941.0 ]--
r 112         MaxPQ points = new MaxPQ
--[ 2019.11.20.10.07.43.976.0 ]--
r 112         MaxPQ points = new MaxPQ()
--[ 2019.11.20.10.07.45.430.0 ]--
r 112         MaxPQ points = new MaxPQ();
--[ 2019.11.20.10.07.53.968.0 ]--
r 112         points = new MaxPQ();
--[ 2019.11.20.10.08.02.236.0 ]--
r 112         MaxPQ points = new MaxPQ();
--[ 2019.11.20.10.08.04.693.0 ]--
r 112         MaxPQ points = new MaxPQ(); 
--[ 2019.11.20.10.08.04.720.0 ]--
r 112         MaxPQ points = new MaxPQ();
--[ 2019.11.20.10.08.04.908.0 ]--
+ 113         
--[ 2019.11.20.10.08.05.854.0 ]--
r 113         f
--[ 2019.11.20.10.08.05.951.0 ]--
r 113         fo
--[ 2019.11.20.10.08.06.024.0 ]--
r 113         for
--[ 2019.11.20.10.08.06.213.0 ]--
r 113         for 
--[ 2019.11.20.10.08.06.645.0 ]--
r 113         for
--[ 2019.11.20.10.08.06.845.0 ]--
r 113         for()
--[ 2019.11.20.10.08.07.568.0 ]--
r 113         for(i)
--[ 2019.11.20.10.08.07.696.0 ]--
r 113         for(in)
--[ 2019.11.20.10.08.07.786.0 ]--
r 113         for(int)
--[ 2019.11.20.10.08.07.905.0 ]--
r 113         for(int )
--[ 2019.11.20.10.08.08.005.0 ]--
r 113         for(int i)
--[ 2019.11.20.10.08.08.142.0 ]--
r 113         for(int i )
--[ 2019.11.20.10.08.08.251.0 ]--
r 113         for(int i =)
--[ 2019.11.20.10.08.08.650.0 ]--
r 113         for(int i =0)
--[ 2019.11.20.10.08.08.768.0 ]--
r 113         for(int i =0 )
--[ 2019.11.20.10.08.08.869.0 ]--
r 113         for(int i =0)
--[ 2019.11.20.10.08.09.016.0 ]--
r 113         for(int i =)
--[ 2019.11.20.10.08.09.103.0 ]--
r 113         for(int i = )
--[ 2019.11.20.10.08.09.192.0 ]--
r 113         for(int i = 0)
--[ 2019.11.20.10.08.09.328.0 ]--
r 113         for(int i = 0 )
--[ 2019.11.20.10.08.09.663.0 ]--
r 113         for(int i = 0)
--[ 2019.11.20.10.08.10.047.0 ]--
r 113         for(int i = 0;)
--[ 2019.11.20.10.08.10.118.0 ]--
r 113         for(int i = 0; )
--[ 2019.11.20.10.08.10.542.0 ]--
r 113         for(int i = 0; i)
--[ 2019.11.20.10.08.10.657.0 ]--
r 113         for(int i = 0; i )
--[ 2019.11.20.10.08.10.728.0 ]--
r 113         for(int i = 0; i <)
--[ 2019.11.20.10.08.10.825.0 ]--
r 113         for(int i = 0; i < )
--[ 2019.11.20.10.08.10.998.0 ]--
r 113         for(int i = 0; i < k)
--[ 2019.11.20.10.08.12.423.0 ]--
r 113         for(int i = 0; i < k;)
--[ 2019.11.20.10.08.12.508.0 ]--
r 113         for(int i = 0; i < k; )
--[ 2019.11.20.10.08.12.650.0 ]--
r 113         for(int i = 0; i < k; i)
--[ 2019.11.20.10.08.12.949.0 ]--
r 113         for(int i = 0; i < k; i+)
--[ 2019.11.20.10.08.13.059.0 ]--
r 113         for(int i = 0; i < k; i++)
--[ 2019.11.20.10.08.14.578.0 ]--
r 113         for(int i = 0; i < k; i++){
--[ 2019.11.20.10.08.15.059.0 ]--
+ 114 
+ 115 }
--[ 2019.11.20.10.08.15.086.0 ]--
r 115         }
--[ 2019.11.20.10.08.15.111.0 ]--
r 114             
--[ 2019.11.20.10.08.31.562.0 ]--
r 114              
--[ 2019.11.20.10.08.31.575.0 ]--
r 114             
--[ 2019.11.20.10.08.31.741.0 ]--
r 114             p
--[ 2019.11.20.10.08.31.940.0 ]--
r 114             po
--[ 2019.11.20.10.08.32.405.0 ]--
r 114             poi
--[ 2019.11.20.10.08.32.455.0 ]--
r 114             poin
--[ 2019.11.20.10.08.32.543.0 ]--
r 114             point
--[ 2019.11.20.10.08.32.624.0 ]--
r 114             points
--[ 2019.11.20.10.08.32.899.0 ]--
r 114             points()
--[ 2019.11.20.10.08.33.937.0 ]--
r 114             points()[]
--[ 2019.11.20.10.08.34.659.0 ]--
r 114             points()[i]
--[ 2019.11.20.10.08.35.289.0 ]--
r 114             points()[i]l
--[ 2019.11.20.10.08.35.449.0 ]--
r 114             points()[i]l 
--[ 2019.11.20.10.08.35.819.0 ]--
r 114             points()[i]l
--[ 2019.11.20.10.08.35.930.0 ]--
r 114             points()[i]
--[ 2019.11.20.10.08.36.043.0 ]--
r 114             points()[i];
--[ 2019.11.20.10.08.42.765.0 ]--
r 114             
--[ 2019.11.20.10.08.47.563.0 ]--
- 113
- 113
r 113         
--[ 2019.11.20.10.08.47.774.0 ]--
- 113
--[ 2019.11.20.10.08.48.304.0 ]--
+ 113         
--[ 2019.11.20.10.12.19.508.0 ]--
r 113         f
--[ 2019.11.20.10.12.19.590.0 ]--
r 113         fo
--[ 2019.11.20.10.12.19.646.0 ]--
r 113         for
--[ 2019.11.20.10.12.23.626.0 ]--
r 113         for()
--[ 2019.11.20.10.12.24.886.0 ]--
r 113         for(P)
--[ 2019.11.20.10.12.25.334.0 ]--
r 113         for(Po)
--[ 2019.11.20.10.12.25.478.0 ]--
r 113         for(Poi)
--[ 2019.11.20.10.12.25.535.0 ]--
r 113         for(Poin)
--[ 2019.11.20.10.12.25.576.0 ]--
r 113         for(Point)
--[ 2019.11.20.10.12.25.663.0 ]--
r 113         for(Point )
--[ 2019.11.20.10.12.25.720.0 ]--
r 113         for(Point q)
--[ 2019.11.20.10.12.26.041.0 ]--
r 113         for(Point q:)
--[ 2019.11.20.10.12.26.272.0 ]--
r 113         for(Point q)
--[ 2019.11.20.10.12.26.368.0 ]--
r 113         for(Point q )
--[ 2019.11.20.10.12.26.438.0 ]--
r 113         for(Point q :)
--[ 2019.11.20.10.12.26.542.0 ]--
r 113         for(Point q : )
--[ 2019.11.20.10.12.27.364.0 ]--
r 113         for(Point q : p)
--[ 2019.11.20.10.12.27.490.0 ]--
r 113         for(Point q : po)
--[ 2019.11.20.10.12.27.620.0 ]--
r 113         for(Point q : poi)
--[ 2019.11.20.10.12.27.695.0 ]--
r 113         for(Point q : poin)
--[ 2019.11.20.10.12.27.733.0 ]--
r 113         for(Point q : point)
--[ 2019.11.20.10.12.27.849.0 ]--
r 113         for(Point q : points)
--[ 2019.11.20.10.12.28.085.0 ]--
r 113         for(Point q : points())
--[ 2019.11.20.10.12.28.771.0 ]--
r 113         for(Point q : points() )
--[ 2019.11.20.10.12.28.835.0 ]--
r 113         for(Point q : points())
--[ 2019.11.20.10.12.29.410.0 ]--
r 113         for(Point q : points()){
--[ 2019.11.20.10.12.29.820.0 ]--
+ 114 
+ 115 }
--[ 2019.11.20.10.12.29.836.0 ]--
r 115         }
--[ 2019.11.20.10.12.29.863.0 ]--
r 114             
--[ 2019.11.20.10.12.33.040.0 ]--
r 114             p
--[ 2019.11.20.10.12.33.273.0 ]--
r 114             po
--[ 2019.11.20.10.12.33.391.0 ]--
r 114             poi
--[ 2019.11.20.10.12.33.461.0 ]--
r 114             poin
--[ 2019.11.20.10.12.33.519.0 ]--
r 114             point
--[ 2019.11.20.10.12.33.586.0 ]--
r 114             points
--[ 2019.11.20.10.12.33.797.0 ]--
r 114             points.
--[ 2019.11.20.10.12.34.505.0 ]--
r 114             points.a
--[ 2019.11.20.10.12.35.304.0 ]--
r 114             points.
--[ 2019.11.20.10.12.35.585.0 ]--
r 114             points.i
--[ 2019.11.20.10.12.35.650.0 ]--
r 114             points.in
--[ 2019.11.20.10.12.36.432.0 ]--
r 114             points.insert
--[ 2019.11.20.10.12.36.440.0 ]--
r 114             points.insert()
--[ 2019.11.20.10.12.36.446.0 ]--
r 114             points.insert();
--[ 2019.11.20.10.12.37.262.0 ]--
r 114             points.insert(p);
--[ 2019.11.20.10.12.38.548.0 ]--
r 114             points.insert(p); 
--[ 2019.11.20.10.12.38.589.0 ]--
r 114             points.insert(p);
--[ 2019.11.20.10.12.41.305.0 ]--
+ 114             
--[ 2019.11.20.10.12.41.977.0 ]--
r 114             i
--[ 2019.11.20.10.12.42.057.0 ]--
r 114             if
--[ 2019.11.20.10.12.42.365.0 ]--
r 114             ifP
--[ 2019.11.20.10.12.42.866.0 ]--
r 114             if
--[ 2019.11.20.10.12.43.280.0 ]--
r 114             if{
--[ 2019.11.20.10.12.44.517.0 ]--
r 114             if{ 
--[ 2019.11.20.10.12.44.596.0 ]--
r 114             if{
--[ 2019.11.20.10.12.45.157.0 ]--
r 114             if
--[ 2019.11.20.10.12.45.383.0 ]--
r 114             if()
--[ 2019.11.20.10.12.47.408.0 ]--
r 114             if(p)
--[ 2019.11.20.10.12.47.533.0 ]--
r 114             if(po)
--[ 2019.11.20.10.12.47.664.0 ]--
r 114             if(poi)
--[ 2019.11.20.10.12.47.717.0 ]--
r 114             if(poin)
--[ 2019.11.20.10.12.47.762.0 ]--
r 114             if(point)
--[ 2019.11.20.10.12.47.842.0 ]--
r 114             if(points)
--[ 2019.11.20.10.12.47.941.0 ]--
r 114             if(points.)
--[ 2019.11.20.10.12.48.065.0 ]--
r 114             if(points.s)
--[ 2019.11.20.10.12.48.150.0 ]--
r 114             if(points.si)
--[ 2019.11.20.10.12.48.224.0 ]--
r 114             if(points.siz)
--[ 2019.11.20.10.12.48.375.0 ]--
r 114             if(points.size)
--[ 2019.11.20.10.12.48.633.0 ]--
r 114             if(points.size())
--[ 2019.11.20.10.12.48.909.0 ]--
r 114             if(points.size() )
--[ 2019.11.20.10.12.49.054.0 ]--
r 114             if(points.size() <)
--[ 2019.11.20.10.12.49.157.0 ]--
r 114             if(points.size() < )
--[ 2019.11.20.10.12.49.515.0 ]--
r 114             if(points.size() < k)
--[ 2019.11.20.10.12.50.658.0 ]--
r 114             if(points.size() < k){
--[ 2019.11.20.10.12.50.914.0 ]--
+ 115 
+ 116 }
--[ 2019.11.20.10.12.50.935.0 ]--
r 116             }
--[ 2019.11.20.10.12.50.960.0 ]--
r 115                 
--[ 2019.11.20.10.12.51.908.0 ]--
r 116             points.insert(p);
r 117             }
--[ 2019.11.20.10.12.51.919.0 ]--
r 115 
r 116                 points.insert(p);
--[ 2019.11.20.10.12.52.266.0 ]--
r 115                 points.insert(p);
r 116 
--[ 2019.11.20.10.12.53.234.0 ]--
+ 118             
--[ 2019.11.20.10.12.53.362.0 ]--
r 118             e
--[ 2019.11.20.10.12.53.476.0 ]--
r 118             el
--[ 2019.11.20.10.12.53.515.0 ]--
r 118             els
--[ 2019.11.20.10.12.53.643.0 ]--
r 118             else
--[ 2019.11.20.10.12.53.747.0 ]--
r 118             else{
--[ 2019.11.20.10.12.54.122.0 ]--
r 118             else{ 
--[ 2019.11.20.10.12.54.177.0 ]--
r 118             else{
--[ 2019.11.20.10.12.54.329.0 ]--
+ 119 
+ 120 }
--[ 2019.11.20.10.12.54.348.0 ]--
r 120             }
--[ 2019.11.20.10.12.54.372.0 ]--
r 119                 
--[ 2019.11.20.10.13.21.054.0 ]--
r 119                 i
--[ 2019.11.20.10.13.21.201.0 ]--
r 119                 if
--[ 2019.11.20.10.13.23.067.0 ]--
r 119                 i
--[ 2019.11.20.10.13.23.193.0 ]--
r 119                 
--[ 2019.11.20.10.13.23.822.0 ]--
r 119                 i
--[ 2019.11.20.10.13.23.984.0 ]--
r 119                 if
--[ 2019.11.20.10.13.24.377.0 ]--
r 119                 if()
--[ 2019.11.20.10.13.24.943.0 ]--
r 119                 if
--[ 2019.11.20.10.13.25.053.0 ]--
r 119                 i
--[ 2019.11.20.10.13.29.032.0 ]--
r 123         return p;
--[ 2019.11.20.10.13.29.202.0 ]--
r 123         return po;
--[ 2019.11.20.10.13.29.346.0 ]--
r 123         return poi;
--[ 2019.11.20.10.13.29.453.0 ]--
r 123         return poin;
--[ 2019.11.20.10.13.29.505.0 ]--
r 123         return point;
--[ 2019.11.20.10.13.29.575.0 ]--
r 123         return points;
--[ 2019.11.20.10.13.37.849.0 ]--
r 119                 i 
--[ 2019.11.20.10.13.37.867.0 ]--
r 119                 i
--[ 2019.11.20.10.13.38.616.0 ]--
r 119                 
--[ 2019.11.20.10.13.40.925.0 ]--
- 117
- 117
- 117
--[ 2019.11.20.10.13.46.215.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.14.53.734.0 ]--
- 113
- 113
- 113
- 113
- 113
r 113         
--[ 2019.11.20.10.14.54.038.0 ]--
- 113
--[ 2019.11.20.10.14.55.179.0 ]--
r 112         MaxPQ points = new MaxPQ(); 
--[ 2019.11.20.10.14.55.228.0 ]--
r 112         MaxPQ points = new MaxPQ();
--[ 2019.11.20.10.14.55.370.0 ]--
+ 113         
--[ 2019.11.20.10.15.01.106.0 ]--
r 113         f
--[ 2019.11.20.10.15.01.188.0 ]--
r 113         fp
--[ 2019.11.20.10.15.01.253.0 ]--
r 113         fpr
--[ 2019.11.20.10.15.01.716.0 ]--
r 113         fp
--[ 2019.11.20.10.15.01.819.0 ]--
r 113         f
--[ 2019.11.20.10.15.02.022.0 ]--
r 113         fo
--[ 2019.11.20.10.15.02.102.0 ]--
r 113         for
--[ 2019.11.20.10.15.02.426.0 ]--
r 113         for()
--[ 2019.11.20.10.15.03.261.0 ]--
r 113         for(P)
--[ 2019.11.20.10.15.03.409.0 ]--
r 113         for(Po)
--[ 2019.11.20.10.15.03.623.0 ]--
r 113         for(Poi)
--[ 2019.11.20.10.15.03.662.0 ]--
r 113         for(Poin)
--[ 2019.11.20.10.15.03.738.0 ]--
r 113         for(Point)
--[ 2019.11.20.10.15.04.365.0 ]--
r 113         for(Point )
--[ 2019.11.20.10.15.04.713.0 ]--
r 113         for(Point q)
--[ 2019.11.20.10.15.04.861.0 ]--
r 113         for(Point q )
--[ 2019.11.20.10.15.05.413.0 ]--
r 113         for(Point q :)
--[ 2019.11.20.10.15.05.598.0 ]--
r 113         for(Point q : )
--[ 2019.11.20.10.15.05.772.0 ]--
r 113         for(Point q : p)
--[ 2019.11.20.10.15.06.243.0 ]--
r 113         for(Point q : po)
--[ 2019.11.20.10.15.06.395.0 ]--
r 113         for(Point q : poi)
--[ 2019.11.20.10.15.06.454.0 ]--
r 113         for(Point q : poin)
--[ 2019.11.20.10.15.06.534.0 ]--
r 113         for(Point q : point)
--[ 2019.11.20.10.15.06.602.0 ]--
r 113         for(Point q : points)
--[ 2019.11.20.10.15.06.880.0 ]--
r 113         for(Point q : points())
--[ 2019.11.20.10.15.07.579.0 ]--
r 113         for(Point q : points()){
--[ 2019.11.20.10.15.07.848.0 ]--
+ 114 
+ 115 }
--[ 2019.11.20.10.15.07.886.0 ]--
r 115         }
--[ 2019.11.20.10.15.07.906.0 ]--
r 114             
--[ 2019.11.20.10.15.08.276.0 ]--
r 114             p
--[ 2019.11.20.10.15.08.802.0 ]--
r 114             po
--[ 2019.11.20.10.15.08.917.0 ]--
r 114             poi
--[ 2019.11.20.10.15.08.971.0 ]--
r 114             poin
--[ 2019.11.20.10.15.09.042.0 ]--
r 114             point
--[ 2019.11.20.10.15.09.101.0 ]--
r 114             points
--[ 2019.11.20.10.15.09.200.0 ]--
r 114             points.
--[ 2019.11.20.10.15.09.409.0 ]--
r 114             points.i
--[ 2019.11.20.10.15.09.467.0 ]--
r 114             points.in
--[ 2019.11.20.10.15.09.538.0 ]--
r 114             points.ins
--[ 2019.11.20.10.15.09.924.0 ]--
r 114             points.insert
--[ 2019.11.20.10.15.09.948.0 ]--
r 114             points.insert()
--[ 2019.11.20.10.15.09.970.0 ]--
r 114             points.insert();
--[ 2019.11.20.10.15.10.297.0 ]--
r 114             points.insert(());
--[ 2019.11.20.10.15.10.604.0 ]--
r 114             points.insert();
--[ 2019.11.20.10.15.10.696.0 ]--
r 114             points.insert(q);
--[ 2019.11.20.10.15.13.369.0 ]--
r 114             points.insert(q); 
--[ 2019.11.20.10.15.13.421.0 ]--
r 114             points.insert(q);
--[ 2019.11.20.10.15.17.418.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.15.40.022.0 ]--
+ 114             
--[ 2019.11.20.10.15.40.402.0 ]--
r 114             i
--[ 2019.11.20.10.15.40.442.0 ]--
r 114             if
--[ 2019.11.20.10.15.40.860.0 ]--
r 114             if()
--[ 2019.11.20.10.15.43.170.0 ]--
r 114             if(m)
--[ 2019.11.20.10.15.43.776.0 ]--
r 114             if()
--[ 2019.11.20.10.15.43.880.0 ]--
r 114             if(p)
--[ 2019.11.20.10.15.44.049.0 ]--
r 114             if(po)
--[ 2019.11.20.10.15.44.195.0 ]--
r 114             if(poi)
--[ 2019.11.20.10.15.44.266.0 ]--
r 114             if(poin)
--[ 2019.11.20.10.15.44.324.0 ]--
r 114             if(point)
--[ 2019.11.20.10.15.44.371.0 ]--
r 114             if(points)
--[ 2019.11.20.10.15.44.475.0 ]--
r 114             if(points.)
--[ 2019.11.20.10.15.44.640.0 ]--
r 114             if(points.s)
--[ 2019.11.20.10.15.44.706.0 ]--
r 114             if(points.si)
--[ 2019.11.20.10.15.44.756.0 ]--
r 114             if(points.siz)
--[ 2019.11.20.10.15.44.909.0 ]--
r 114             if(points.size)
--[ 2019.11.20.10.15.45.042.0 ]--
r 114             if(points.size())
--[ 2019.11.20.10.15.45.234.0 ]--
r 114             if(points.size() )
--[ 2019.11.20.10.15.45.406.0 ]--
r 114             if(points.size() <)
--[ 2019.11.20.10.15.45.535.0 ]--
r 114             if(points.size() < )
--[ 2019.11.20.10.15.45.698.0 ]--
r 114             if(points.size() < k)
--[ 2019.11.20.10.15.46.439.0 ]--
r 114             if(points.size() < k){
--[ 2019.11.20.10.15.46.806.0 ]--
+ 115 
+ 116 }
--[ 2019.11.20.10.15.46.847.0 ]--
r 116             }
--[ 2019.11.20.10.15.46.867.0 ]--
r 115                 
--[ 2019.11.20.10.15.49.092.0 ]--
r 116             points.insert(q);
r 117             }
--[ 2019.11.20.10.15.49.117.0 ]--
r 115 
r 116                 points.insert(q);
--[ 2019.11.20.10.15.49.438.0 ]--
r 115                 points.insert(q);
r 116 
--[ 2019.11.20.10.15.52.594.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.16.58.159.0 ]--
- 116
--[ 2019.11.20.10.16.59.549.0 ]--
+ 117             
--[ 2019.11.20.10.17.00.621.0 ]--
r 117             e
--[ 2019.11.20.10.17.00.713.0 ]--
r 117             el
--[ 2019.11.20.10.17.00.757.0 ]--
r 117             els
--[ 2019.11.20.10.17.00.894.0 ]--
r 117             else
--[ 2019.11.20.10.17.01.011.0 ]--
r 117             else{
--[ 2019.11.20.10.17.01.831.0 ]--
r 117             else{ 
--[ 2019.11.20.10.17.01.880.0 ]--
r 117             else{
--[ 2019.11.20.10.17.02.037.0 ]--
+ 118 
+ 119 }
--[ 2019.11.20.10.17.02.051.0 ]--
r 119             }
--[ 2019.11.20.10.17.02.070.0 ]--
r 118                 
--[ 2019.11.20.10.17.08.614.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.17.37.083.0 ]--
r 118                 i
--[ 2019.11.20.10.17.37.202.0 ]--
r 118                 if
--[ 2019.11.20.10.17.37.346.0 ]--
r 118                 if()
--[ 2019.11.20.10.17.37.654.0 ]--
r 118                 if(q)
--[ 2019.11.20.10.17.37.783.0 ]--
r 118                 if(q.)
--[ 2019.11.20.10.17.39.215.0 ]--
r 118                 if(q. )
--[ 2019.11.20.10.17.39.257.0 ]--
r 118                 if(q.)
--[ 2019.11.20.10.17.51.696.0 ]--
r 118                 if(q)
--[ 2019.11.20.10.17.51.786.0 ]--
r 118                 if()
--[ 2019.11.20.10.17.51.979.0 ]--
r 118                 if(n)
--[ 2019.11.20.10.17.52.074.0 ]--
r 118                 if(ne)
--[ 2019.11.20.10.17.52.185.0 ]--
r 118                 if(new)
--[ 2019.11.20.10.17.53.263.0 ]--
r 118                 if(new )
--[ 2019.11.20.10.17.53.432.0 ]--
r 118                 if(new P)
--[ 2019.11.20.10.17.53.866.0 ]--
r 118                 if(new Po)
--[ 2019.11.20.10.17.54.035.0 ]--
r 118                 if(new Poi)
--[ 2019.11.20.10.17.54.116.0 ]--
r 118                 if(new Poin)
--[ 2019.11.20.10.17.55.363.0 ]--
r 118                 if(new PointDist)
--[ 2019.11.20.10.17.55.409.0 ]--
r 118                 if(new PointDist())
--[ 2019.11.20.10.18.03.132.0 ]--
r 118                 
--[ 2019.11.20.10.18.43.244.0 ]--
r 118                 q
--[ 2019.11.20.10.18.43.356.0 ]--
r 118                 q.
--[ 2019.11.20.10.18.43.685.0 ]--
r 118                 q.d
--[ 2019.11.20.10.18.43.724.0 ]--
r 118                 q.di
--[ 2019.11.20.10.18.43.808.0 ]--
r 118                 q.dis
--[ 2019.11.20.10.18.44.036.0 ]--
r 118                 q.dis()
--[ 2019.11.20.10.18.44.559.0 ]--
r 118                 q.dis(p)
--[ 2019.11.20.10.18.46.509.0 ]--
r 118                 q.dist(p)
--[ 2019.11.20.10.18.47.594.0 ]--
r 118                 q.dist(p) 
--[ 2019.11.20.10.18.47.728.0 ]--
r 118                 q.dist(p) >
--[ 2019.11.20.10.18.47.814.0 ]--
r 118                 q.dist(p) > 
--[ 2019.11.20.10.18.48.687.0 ]--
r 118                 q.dist(p) >
--[ 2019.11.20.10.18.48.850.0 ]--
r 118                 q.dist(p) 
--[ 2019.11.20.10.18.49.208.0 ]--
r 118                 q.dist(p) <
--[ 2019.11.20.10.18.49.297.0 ]--
r 118                 q.dist(p) < 
--[ 2019.11.20.10.18.54.355.0 ]--
r 81     // The min-max pair will form a boundingbox for all Points.
--[ 2019.11.20.10.18.55.312.0 ]--
r 81     // The min-max pair will form a bounding box for all Points.
--[ 2019.11.20.10.19.00.168.0 ]--
r 118                 q.dist(p) <  
--[ 2019.11.20.10.19.00.217.0 ]--
r 118                 q.dist(p) < 
--[ 2019.11.20.10.19.04.644.0 ]--
r 118                 q.dist(p) < q
--[ 2019.11.20.10.19.04.719.0 ]--
r 118                 q.dist(p) < q.
--[ 2019.11.20.10.19.05.428.0 ]--
r 118                 q.dist(p) < q. 
--[ 2019.11.20.10.19.05.456.0 ]--
r 118                 q.dist(p) < q.
--[ 2019.11.20.10.19.06.052.0 ]--
r 118                 q.dist(p) < q
--[ 2019.11.20.10.19.06.183.0 ]--
r 118                 q.dist(p) < 
--[ 2019.11.20.10.19.06.911.0 ]--
r 118                 q.dist(p) < p
--[ 2019.11.20.10.19.07.495.0 ]--
r 118                 q.dist(p) < po
--[ 2019.11.20.10.19.07.729.0 ]--
r 118                 q.dist(p) < poi
--[ 2019.11.20.10.19.07.810.0 ]--
r 118                 q.dist(p) < poin
--[ 2019.11.20.10.19.07.886.0 ]--
r 118                 q.dist(p) < point
--[ 2019.11.20.10.19.08.587.0 ]--
r 118                 q.dist(p) < poin
--[ 2019.11.20.10.19.08.695.0 ]--
r 118                 q.dist(p) < poi
--[ 2019.11.20.10.19.08.785.0 ]--
r 118                 q.dist(p) < po
--[ 2019.11.20.10.19.08.893.0 ]--
r 118                 q.dist(p) < p
--[ 2019.11.20.10.19.09.357.0 ]--
r 118                 q.dist(p) < 
--[ 2019.11.20.10.19.10.231.0 ]--
r 118                 q.dist(p) < n
--[ 2019.11.20.10.19.10.296.0 ]--
r 118                 q.dist(p) < ne
--[ 2019.11.20.10.19.10.490.0 ]--
r 118                 q.dist(p) < new
--[ 2019.11.20.10.19.11.568.0 ]--
r 118                 q.dist(p) < new 
--[ 2019.11.20.10.19.11.638.0 ]--
r 118                 q.dist(p) < new
--[ 2019.11.20.10.19.14.129.0 ]--
r 118                 iq.dist(p) < new
--[ 2019.11.20.10.19.14.230.0 ]--
r 118                 ifq.dist(p) < new
--[ 2019.11.20.10.19.14.345.0 ]--
r 118                 if(q.dist(p) < new
--[ 2019.11.20.10.19.16.303.0 ]--
r 118                 if(q.dist(p) < new 
--[ 2019.11.20.10.19.16.465.0 ]--
r 118                 if(q.dist(p) < new P
--[ 2019.11.20.10.19.16.641.0 ]--
r 118                 if(q.dist(p) < new Po
--[ 2019.11.20.10.19.16.786.0 ]--
r 118                 if(q.dist(p) < new Poi
--[ 2019.11.20.10.19.16.835.0 ]--
r 118                 if(q.dist(p) < new Poin
--[ 2019.11.20.10.19.16.941.0 ]--
r 118                 if(q.dist(p) < new Point
--[ 2019.11.20.10.19.17.564.0 ]--
r 118                 if(q.dist(p) < new PointD
--[ 2019.11.20.10.19.18.207.0 ]--
r 118                 if(q.dist(p) < new PointDist
--[ 2019.11.20.10.19.18.235.0 ]--
r 118                 if(q.dist(p) < new PointDist()
--[ 2019.11.20.10.19.19.948.0 ]--
r 118                 if(q.dist(p) < new PointDist(p)
--[ 2019.11.20.10.19.20.141.0 ]--
r 118                 if(q.dist(p) < new PointDist(p,)
--[ 2019.11.20.10.19.20.352.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, )
--[ 2019.11.20.10.19.22.809.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, m)
--[ 2019.11.20.10.19.22.907.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, mi)
--[ 2019.11.20.10.19.22.983.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min)
--[ 2019.11.20.10.19.23.807.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min )
--[ 2019.11.20.10.19.23.844.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min)
--[ 2019.11.20.10.19.26.496.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min) 
--[ 2019.11.20.10.19.26.604.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min)
--[ 2019.11.20.10.19.28.283.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min).
--[ 2019.11.20.10.19.30.021.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min).compareTo
--[ 2019.11.20.10.19.30.028.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min).compareTo()
--[ 2019.11.20.10.19.31.134.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min).compareTo(p)
--[ 2019.11.20.10.19.32.165.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min).compareTo(p))
--[ 2019.11.20.10.19.32.652.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, min).compareTo(p)){
--[ 2019.11.20.10.19.32.909.0 ]--
+ 119 
+ 120 }
--[ 2019.11.20.10.19.32.976.0 ]--
r 120                 }
--[ 2019.11.20.10.19.33.001.0 ]--
r 119                     
--[ 2019.11.20.10.19.38.621.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, mi).compareTo(p)){
--[ 2019.11.20.10.19.38.875.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, m).compareTo(p)){
--[ 2019.11.20.10.19.39.025.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, ).compareTo(p)){
--[ 2019.11.20.10.19.39.190.0 ]--
r 118                 if(q.dist(p) < new PointDist(p, 0).compareTo(p)){
--[ 2019.11.20.10.19.55.009.0 ]--
- 118
- 118
- 118
--[ 2019.11.20.10.19.55.651.0 ]--
+ 118                 
--[ 2019.11.20.10.21.52.997.0 ]--
r 118                 i
--[ 2019.11.20.10.21.53.086.0 ]--
r 118                 if
--[ 2019.11.20.10.21.53.868.0 ]--
r 118                 if()
--[ 2019.11.20.10.21.55.021.0 ]--
r 118                 if( )
--[ 2019.11.20.10.21.55.076.0 ]--
r 118                 if()
--[ 2019.11.20.10.22.13.340.0 ]--
r 118                 if( )
--[ 2019.11.20.10.22.13.374.0 ]--
r 118                 if()
--[ 2019.11.20.10.22.27.636.0 ]--
- 117
- 117
r 117             
--[ 2019.11.20.10.22.28.003.0 ]--
- 117
--[ 2019.11.20.10.22.32.583.0 ]--
r 114             
--[ 2019.11.20.10.22.32.852.0 ]--
- 114
--[ 2019.11.20.10.22.34.312.0 ]--
r 115             
--[ 2019.11.20.10.22.36.838.0 ]--
r 114             points.insert(q);
--[ 2019.11.20.10.22.38.602.0 ]--
+ 115             
--[ 2019.11.20.10.22.39.091.0 ]--
r 115             o
--[ 2019.11.20.10.22.39.182.0 ]--
r 115             of
--[ 2019.11.20.10.22.39.336.0 ]--
r 115             of()
--[ 2019.11.20.10.22.39.746.0 ]--
r 115             of
--[ 2019.11.20.10.22.39.860.0 ]--
r 115             o
--[ 2019.11.20.10.22.39.978.0 ]--
r 115             
--[ 2019.11.20.10.22.40.126.0 ]--
r 115             i
--[ 2019.11.20.10.22.40.228.0 ]--
r 115             if
--[ 2019.11.20.10.22.40.549.0 ]--
r 115             if()
--[ 2019.11.20.10.22.41.080.0 ]--
r 115             if( )
--[ 2019.11.20.10.22.41.114.0 ]--
r 115             if()
--[ 2019.11.20.10.22.41.482.0 ]--
r 115             if(p)
--[ 2019.11.20.10.22.41.640.0 ]--
r 115             if(po)
--[ 2019.11.20.10.22.41.813.0 ]--
r 115             if(poi)
--[ 2019.11.20.10.22.41.877.0 ]--
r 115             if(poin)
--[ 2019.11.20.10.22.41.920.0 ]--
r 115             if(point)
--[ 2019.11.20.10.22.41.957.0 ]--
r 115             if(points)
--[ 2019.11.20.10.22.42.374.0 ]--
r 115             if(points )
--[ 2019.11.20.10.22.42.434.0 ]--
r 115             if(points)
--[ 2019.11.20.10.22.43.182.0 ]--
r 115             if()
--[ 2019.11.20.10.22.44.113.0 ]--
r 115             if(p)
--[ 2019.11.20.10.22.44.263.0 ]--
r 115             if(po)
--[ 2019.11.20.10.22.44.408.0 ]--
r 115             if(poi)
--[ 2019.11.20.10.22.44.450.0 ]--
r 115             if(poin)
--[ 2019.11.20.10.22.44.515.0 ]--
r 115             if(point)
--[ 2019.11.20.10.22.44.571.0 ]--
r 115             if(points)
--[ 2019.11.20.10.22.44.681.0 ]--
r 115             if(points.)
--[ 2019.11.20.10.22.44.830.0 ]--
r 115             if(points.s)
--[ 2019.11.20.10.22.44.931.0 ]--
r 115             if(points.si)
--[ 2019.11.20.10.22.45.015.0 ]--
r 115             if(points.siz)
--[ 2019.11.20.10.22.45.146.0 ]--
r 115             if(points.size)
--[ 2019.11.20.10.22.45.368.0 ]--
r 115             if(points.size())
--[ 2019.11.20.10.22.45.568.0 ]--
r 115             if(points.size() )
--[ 2019.11.20.10.22.45.986.0 ]--
r 115             if(points.size() >)
--[ 2019.11.20.10.22.46.106.0 ]--
r 115             if(points.size() > )
--[ 2019.11.20.10.22.46.975.0 ]--
r 115             if(points.size() > k)
--[ 2019.11.20.10.22.47.482.0 ]--
r 115             if(points.size() > k )
--[ 2019.11.20.10.22.47.519.0 ]--
r 115             if(points.size() > k)
--[ 2019.11.20.10.22.48.261.0 ]--
r 115             if(points.size() > k){}
--[ 2019.11.20.10.22.48.294.0 ]--
+ 115             if (points.size() > k) {
r 116             }
--[ 2019.11.20.10.22.48.312.0 ]--
+ 116                 
--[ 2019.11.20.10.22.48.324.0 ]--
+ 116                 
--[ 2019.11.20.10.22.49.558.0 ]--
- 116
--[ 2019.11.20.10.22.51.642.0 ]--
r 116                 i
--[ 2019.11.20.10.22.51.723.0 ]--
r 116                 if
--[ 2019.11.20.10.22.51.915.0 ]--
r 116                 if()
--[ 2019.11.20.10.22.54.588.0 ]--
r 116                 if(p)
--[ 2019.11.20.10.22.54.759.0 ]--
r 116                 if(po)
--[ 2019.11.20.10.22.54.863.0 ]--
r 116                 if(poi)
--[ 2019.11.20.10.22.54.924.0 ]--
r 116                 if(poin)
--[ 2019.11.20.10.22.54.964.0 ]--
r 116                 if(point)
--[ 2019.11.20.10.22.55.014.0 ]--
r 116                 if(points)
--[ 2019.11.20.10.22.55.136.0 ]--
r 116                 if(points.)
--[ 2019.11.20.10.22.55.368.0 ]--
r 116                 if(points.m)
--[ 2019.11.20.10.22.55.570.0 ]--
r 116                 if(points.ma)
--[ 2019.11.20.10.22.55.974.0 ]--
r 116                 if(points.max)
--[ 2019.11.20.10.22.56.161.0 ]--
r 116                 if(points.max())
--[ 2019.11.20.10.22.57.513.0 ]--
r 116                 if(points.max() )
--[ 2019.11.20.10.22.58.688.0 ]--
r 116                 if(points.max() >)
--[ 2019.11.20.10.22.58.884.0 ]--
r 116                 if(points.max() > )
--[ 2019.11.20.10.23.00.209.0 ]--
r 116                 if(points.max() > n)
--[ 2019.11.20.10.23.00.304.0 ]--
r 116                 if(points.max() > ne)
--[ 2019.11.20.10.23.00.443.0 ]--
r 116                 if(points.max() > new)
--[ 2019.11.20.10.23.00.703.0 ]--
r 116                 if(points.max() > new )
--[ 2019.11.20.10.23.01.120.0 ]--
r 116                 if(points.max() > new)
--[ 2019.11.20.10.23.01.600.0 ]--
r 116                 if(points.max() > new )
--[ 2019.11.20.10.23.02.117.0 ]--
r 116                 if(points.max() > new p)
--[ 2019.11.20.10.23.02.300.0 ]--
r 116                 if(points.max() > new po)
--[ 2019.11.20.10.23.02.904.0 ]--
r 116                 if(points.max() > new p)
--[ 2019.11.20.10.23.03.290.0 ]--
r 116                 if(points.max() > new )
--[ 2019.11.20.10.23.03.475.0 ]--
r 116                 if(points.max() > new P)
--[ 2019.11.20.10.23.03.640.0 ]--
r 116                 if(points.max() > new Po)
--[ 2019.11.20.10.23.03.772.0 ]--
r 116                 if(points.max() > new Poi)
--[ 2019.11.20.10.23.03.842.0 ]--
r 116                 if(points.max() > new Poin)
--[ 2019.11.20.10.23.03.951.0 ]--
r 116                 if(points.max() > new Point)
--[ 2019.11.20.10.23.04.568.0 ]--
r 116                 if(points.max() > new PointD)
--[ 2019.11.20.10.23.05.129.0 ]--
r 116                 if(points.max() > new PointDist)
--[ 2019.11.20.10.23.05.170.0 ]--
r 116                 if(points.max() > new PointDist())
--[ 2019.11.20.10.23.07.854.0 ]--
r 116                 if(points.max() > new PointDist(p))
--[ 2019.11.20.10.23.07.937.0 ]--
r 116                 if(points.max() > new PointDist(p,))
--[ 2019.11.20.10.23.08.007.0 ]--
r 116                 if(points.max() > new PointDist(p, ))
--[ 2019.11.20.10.23.08.065.0 ]--
r 116                 if(points.max() > new PointDist(p, 0))
--[ 2019.11.20.10.23.10.407.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).)
--[ 2019.11.20.10.23.13.625.0 ]--
r 116                 if(points.max() > new PointDist(p, ).)
--[ 2019.11.20.10.23.13.684.0 ]--
r 116                 if(points.max() > new PointDist(p, q).)
--[ 2019.11.20.10.23.15.968.0 ]--
r 116                 if(points.max() > new PointDist(p, ).)
--[ 2019.11.20.10.23.16.031.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).)
--[ 2019.11.20.10.23.17.796.0 ]--
r 116                 if(points.max() > new PointDist(p, 0))
--[ 2019.11.20.10.23.18.197.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).)
--[ 2019.11.20.10.23.19.500.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo)
--[ 2019.11.20.10.23.19.510.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo())
--[ 2019.11.20.10.23.29.899.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(n))
--[ 2019.11.20.10.23.29.999.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(ne))
--[ 2019.11.20.10.23.30.146.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new))
--[ 2019.11.20.10.23.30.693.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(newP))
--[ 2019.11.20.10.23.31.163.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new))
--[ 2019.11.20.10.23.31.320.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new ))
--[ 2019.11.20.10.23.31.424.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new P))
--[ 2019.11.20.10.23.31.660.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Po))
--[ 2019.11.20.10.23.31.775.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Poi))
--[ 2019.11.20.10.23.31.851.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Poin))
--[ 2019.11.20.10.23.32.025.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Point))
--[ 2019.11.20.10.23.32.301.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Point()))
--[ 2019.11.20.10.23.32.828.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Point))
--[ 2019.11.20.10.23.32.932.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Poin))
--[ 2019.11.20.10.23.33.844.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new Point))
--[ 2019.11.20.10.23.34.172.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new PointD))
--[ 2019.11.20.10.23.34.632.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new PointDist))
--[ 2019.11.20.10.23.34.652.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new PointDist()))
--[ 2019.11.20.10.23.35.356.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new PointDist(q)))
--[ 2019.11.20.10.23.35.540.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new PointDist(q,)))
--[ 2019.11.20.10.23.35.776.0 ]--
r 116                 if(points.max() > new PointDist(p, 0).compareTo(new PointDist(q,0)))
--[ 2019.11.20.10.23.48.498.0 ]--
- 116
- 116
--[ 2019.11.20.10.23.49.905.0 ]--
+ 116 
+ 117 }
--[ 2019.11.20.10.23.49.916.0 ]--
r 117             }
--[ 2019.11.20.10.23.49.928.0 ]--
r 116                 
--[ 2019.11.20.10.23.50.842.0 ]--
r 116                 r
--[ 2019.11.20.10.23.50.894.0 ]--
r 116                 re
--[ 2019.11.20.10.23.50.986.0 ]--
r 116                 rem
--[ 2019.11.20.10.23.51.048.0 ]--
r 116                 remo
--[ 2019.11.20.10.23.51.125.0 ]--
r 116                 remov
--[ 2019.11.20.10.23.51.175.0 ]--
r 116                 remove
--[ 2019.11.20.10.23.51.574.0 ]--
r 116                 remove 
--[ 2019.11.20.10.23.51.589.0 ]--
r 116                 remove
--[ 2019.11.20.10.23.51.714.0 ]--
r 116                 remov
--[ 2019.11.20.10.23.51.844.0 ]--
r 116                 remo
--[ 2019.11.20.10.23.51.974.0 ]--
r 116                 rem
--[ 2019.11.20.10.23.52.060.0 ]--
r 116                 re
--[ 2019.11.20.10.23.52.321.0 ]--
r 116                 r
--[ 2019.11.20.10.23.52.462.0 ]--
r 116                 
--[ 2019.11.20.10.23.53.427.0 ]--
r 116                 p
--[ 2019.11.20.10.23.53.547.0 ]--
r 116                 po
--[ 2019.11.20.10.23.53.698.0 ]--
r 116                 poi
--[ 2019.11.20.10.23.53.803.0 ]--
r 116                 poin
--[ 2019.11.20.10.23.53.837.0 ]--
r 116                 point
--[ 2019.11.20.10.23.53.875.0 ]--
r 116                 points
--[ 2019.11.20.10.23.53.997.0 ]--
r 116                 points.
--[ 2019.11.20.10.23.54.904.0 ]--
r 116                 points.d
--[ 2019.11.20.10.23.54.952.0 ]--
r 116                 points.de
--[ 2019.11.20.10.23.55.061.0 ]--
r 116                 points.del
--[ 2019.11.20.10.23.55.513.0 ]--
r 116                 points.delMax
--[ 2019.11.20.10.23.55.533.0 ]--
r 116                 points.delMax()
--[ 2019.11.20.10.23.57.828.0 ]--
r 118 
--[ 2019.11.20.10.23.59.021.0 ]--
r 116                 points.delMax();
--[ 2019.11.20.10.23.59.021.1 ]--
UpdateTree (AD): 0 1
- /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.23.59.023.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.23.59.504.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.24.03.317.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.24.03.317.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.24.53.022.0 ]--
+ 118             
--[ 2019.11.20.10.24.58.139.0 ]--
- 118
--[ 2019.11.20.10.29.24.764.0 ]--
+ 116                 
--[ 2019.11.20.10.29.25.005.0 ]--
r 116                  
--[ 2019.11.20.10.29.25.091.0 ]--
r 116                 
--[ 2019.11.20.10.29.29.535.0 ]--
r 116                 i
--[ 2019.11.20.10.29.29.644.0 ]--
r 116                 if
--[ 2019.11.20.10.29.29.788.0 ]--
r 116                 ifq
--[ 2019.11.20.10.29.29.915.0 ]--
r 116                 ifq.
--[ 2019.11.20.10.29.30.145.0 ]--
r 116                 ifq.d
--[ 2019.11.20.10.29.30.258.0 ]--
r 116                 ifq.di
--[ 2019.11.20.10.29.30.390.0 ]--
r 116                 ifq.dis
--[ 2019.11.20.10.29.30.658.0 ]--
r 116                 ifq.di
--[ 2019.11.20.10.29.30.777.0 ]--
r 116                 ifq.d
--[ 2019.11.20.10.29.30.884.0 ]--
r 116                 ifq.
--[ 2019.11.20.10.29.31.009.0 ]--
r 116                 ifq
--[ 2019.11.20.10.29.31.250.0 ]--
r 116                 if
--[ 2019.11.20.10.29.31.577.0 ]--
r 116                 if()
--[ 2019.11.20.10.29.32.027.0 ]--
r 116                 if(q)
--[ 2019.11.20.10.29.32.115.0 ]--
r 116                 if(q.)
--[ 2019.11.20.10.29.32.423.0 ]--
r 116                 if(q.d)
--[ 2019.11.20.10.29.32.461.0 ]--
r 116                 if(q.di)
--[ 2019.11.20.10.29.32.516.0 ]--
r 116                 if(q.dis)
--[ 2019.11.20.10.29.33.835.0 ]--
r 116                 if(q.dist)
--[ 2019.11.20.10.29.34.087.0 ]--
r 116                 if(q.dist())
--[ 2019.11.20.10.29.34.271.0 ]--
r 116                 if(q.dist(p))
--[ 2019.11.20.10.29.35.110.0 ]--
r 116                 if(q.dist(p ))
--[ 2019.11.20.10.29.35.164.0 ]--
r 116                 if(q.dist(p))
--[ 2019.11.20.10.29.37.122.0 ]--
r 116                 if(q.dist(p) )
--[ 2019.11.20.10.29.40.146.0 ]--
r 116                 if(q.dist(p) M)
--[ 2019.11.20.10.29.40.551.0 ]--
r 116                 if(q.dist(p) M )
--[ 2019.11.20.10.29.40.729.0 ]--
r 116                 if(q.dist(p) M)
--[ 2019.11.20.10.29.40.861.0 ]--
r 116                 if(q.dist(p) )
--[ 2019.11.20.10.29.41.023.0 ]--
r 116                 if(q.dist(p) <)
--[ 2019.11.20.10.29.41.194.0 ]--
r 116                 if(q.dist(p) < )
--[ 2019.11.20.10.29.41.781.0 ]--
r 116                 if(q.dist(p) < p)
--[ 2019.11.20.10.29.41.916.0 ]--
r 116                 if(q.dist(p) < po)
--[ 2019.11.20.10.29.42.081.0 ]--
r 116                 if(q.dist(p) < poi)
--[ 2019.11.20.10.29.42.128.0 ]--
r 116                 if(q.dist(p) < poin)
--[ 2019.11.20.10.29.42.155.0 ]--
r 116                 if(q.dist(p) < point)
--[ 2019.11.20.10.29.42.218.0 ]--
r 116                 if(q.dist(p) < points)
--[ 2019.11.20.10.29.42.851.0 ]--
r 116                 if(q.dist(p) < points.)
--[ 2019.11.20.10.29.42.967.0 ]--
r 116                 if(q.dist(p) < points.d)
--[ 2019.11.20.10.29.43.021.0 ]--
r 116                 if(q.dist(p) < points.de)
--[ 2019.11.20.10.29.43.660.0 ]--
r 116                 if(q.dist(p) < points.delMax)
--[ 2019.11.20.10.29.43.665.0 ]--
r 116                 if(q.dist(p) < points.delMax())
--[ 2019.11.20.10.29.44.088.0 ]--
r 116                 if(q.dist(p) < points.delMax().)
--[ 2019.11.20.10.29.50.967.0 ]--
r 116                 if(q.dist(p) < points.delMax().d)
--[ 2019.11.20.10.29.51.085.0 ]--
r 116                 if(q.dist(p) < points.delMax().di)
--[ 2019.11.20.10.29.51.231.0 ]--
r 116                 if(q.dist(p) < points.delMax().dis)
--[ 2019.11.20.10.29.51.414.0 ]--
r 116                 if(q.dist(p) < points.delMax().dist)
--[ 2019.11.20.10.29.51.708.0 ]--
r 116                 if(q.dist(p) < points.delMax().dis)
--[ 2019.11.20.10.29.51.821.0 ]--
r 116                 if(q.dist(p) < points.delMax().di)
--[ 2019.11.20.10.29.51.957.0 ]--
r 116                 if(q.dist(p) < points.delMax().d)
--[ 2019.11.20.10.29.52.067.0 ]--
r 116                 if(q.dist(p) < points.delMax().)
--[ 2019.11.20.10.29.52.328.0 ]--
r 116                 if(q.dist(p) < points.delMax().d)
--[ 2019.11.20.10.29.52.749.0 ]--
r 116                 if(q.dist(p) < points.delMax().di)
--[ 2019.11.20.10.29.52.921.0 ]--
r 116                 if(q.dist(p) < points.delMax().dis)
--[ 2019.11.20.10.29.53.061.0 ]--
r 116                 if(q.dist(p) < points.delMax().dist)
--[ 2019.11.20.10.29.53.350.0 ]--
r 116                 if(q.dist(p) < points.delMax().dist())
--[ 2019.11.20.10.29.53.623.0 ]--
r 116                 if(q.dist(p) < points.delMax().dist(p))
--[ 2019.11.20.10.30.02.089.0 ]--
r 116                 if(q.dist(p) < )
--[ 2019.11.20.10.30.05.979.0 ]--
r 118             
--[ 2019.11.20.10.30.06.232.0 ]--
- 118
--[ 2019.11.20.10.30.09.546.0 ]--
r 116                 
--[ 2019.11.20.10.30.09.777.0 ]--
- 116
--[ 2019.11.20.10.30.10.052.0 ]--
r 115             if (points.size() > k) 
--[ 2019.11.20.10.30.10.577.0 ]--
+ 115             if (points.size() > k) {
r 116                 if(q.dist(p) < )
--[ 2019.11.20.10.30.11.275.0 ]--
r 116                 
--[ 2019.11.20.10.30.11.744.0 ]--
- 116
--[ 2019.11.20.10.30.16.174.0 ]--
- 116
r 116                 points.delMax();\
--[ 2019.11.20.10.30.16.716.0 ]--
r 116                 points.delMax();
--[ 2019.11.20.10.30.40.928.0 ]--
UpdateTree (AD): 0 1
- /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.40.928.1 ]--
CompilationStatus (AEW): 0 12 0
[Ljava.lang.String;@69c52f74
--[ 2019.11.20.10.30.48.428.0 ]--
r 116                 points.delMax();\
--[ 2019.11.20.10.30.48.430.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.48.439.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.48.664.0 ]--
r 116                 points.delMax();
--[ 2019.11.20.10.30.48.664.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.48.667.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.48.892.0 ]--
+ 117 
--[ 2019.11.20.10.30.48.892.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.48.897.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.49.588.0 ]--
+ 116                 if(q.dist(p) < )
--[ 2019.11.20.10.30.49.589.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.49.594.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.364.0 ]--
+ 118             }
--[ 2019.11.20.10.30.51.364.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.367.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.369.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.371.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.373.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.375.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.377.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.379.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.381.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.383.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.385.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.388.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.769.0 ]--
r 116                 if(q.dist(p) < points.delMax().dist(p))
--[ 2019.11.20.10.30.51.769.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.771.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.51.774.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.056.0 ]--
r 116                 if(q.dist(p) < points.delMax().)
--[ 2019.11.20.10.30.52.056.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.058.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.207.0 ]--
r 116                 if(q.dist(p) < points.delMax().dist)
--[ 2019.11.20.10.30.52.207.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.210.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.332.0 ]--
r 116                 if(q.dist(p) < points.delMax())
--[ 2019.11.20.10.30.52.332.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.334.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.473.0 ]--
r 116                 if(q.dist(p) < points.de)
--[ 2019.11.20.10.30.52.474.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.476.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.614.0 ]--
r 116                 if(q.dist(p) )
--[ 2019.11.20.10.30.52.615.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.618.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.620.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.736.0 ]--
r 116                 if(q.dist(p) M )
--[ 2019.11.20.10.30.52.737.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.739.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.741.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.743.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.747.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.750.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.753.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.756.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.908.0 ]--
r 116                 if(q.dist(p))
--[ 2019.11.20.10.30.52.910.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.919.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.927.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.935.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.943.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.952.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.961.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.52.970.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.369.0 ]--
r 116                 if(q.dist(p ))
--[ 2019.11.20.10.30.53.369.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.373.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.497.0 ]--
r 116                 if
--[ 2019.11.20.10.30.53.497.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.499.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.501.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.503.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.918.0 ]--
r 116                 ifq.dis
--[ 2019.11.20.10.30.53.918.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.920.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.922.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.924.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.926.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.53.927.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.106.0 ]--
r 116                 
--[ 2019.11.20.10.30.54.107.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.117.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.126.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.135.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.145.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.272.0 ]--
r 116                  
--[ 2019.11.20.10.30.54.273.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.279.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.368.0 ]--
r 116                 
--[ 2019.11.20.10.30.54.368.1 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.370.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.557.0 ]--
- 116
--[ 2019.11.20.10.30.54.558.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.566.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.784.0 ]--
+ 118             
--[ 2019.11.20.10.30.54.785.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.54.793.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.55.543.0 ]--
- 118
--[ 2019.11.20.10.30.55.544.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.30.55.554.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.31.01.075.0 ]--
UpdateTree (AD): 1 0
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.20.10.31.01.076.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.32.13.699.0 ]--
r 100         
--[ 2019.11.20.10.32.13.917.0 ]--
- 100
--[ 2019.11.20.10.39.37.146.0 ]--
- 112
- 112
- 112
- 112
- 112
- 112
r 112         
--[ 2019.11.20.10.39.37.311.0 ]--
- 112
--[ 2019.11.20.10.39.37.779.0 ]--
r 111         MaxPQ points = new MaxPQ(); 
--[ 2019.11.20.10.39.37.826.0 ]--
r 111         MaxPQ points = new MaxPQ();
--[ 2019.11.20.10.39.43.010.0 ]--
r 111         MaxPQ<> points = new MaxPQ();
--[ 2019.11.20.10.39.44.393.0 ]--
r 111         MaxPQ<P> points = new MaxPQ();
--[ 2019.11.20.10.39.44.585.0 ]--
r 111         MaxPQ<Po> points = new MaxPQ();
--[ 2019.11.20.10.39.44.974.0 ]--
r 111         MaxPQ<Poi> points = new MaxPQ();
--[ 2019.11.20.10.39.45.134.0 ]--
r 111         MaxPQ<Poin> points = new MaxPQ();
--[ 2019.11.20.10.39.45.451.0 ]--
r 111         MaxPQ<Point> points = new MaxPQ();
--[ 2019.11.20.10.39.45.681.0 ]--
r 111         MaxPQ<PointD> points = new MaxPQ();
--[ 2019.11.20.10.39.45.826.0 ]--
r 111         MaxPQ<PointDi> points = new MaxPQ();
--[ 2019.11.20.10.39.45.926.0 ]--
r 111         MaxPQ<PointDis> points = new MaxPQ();
--[ 2019.11.20.10.39.46.048.0 ]--
r 111         MaxPQ<PointDist> points = new MaxPQ();
--[ 2019.11.20.10.39.46.342.0 ]--
r 111         MaxPQ<PointDist > points = new MaxPQ();
--[ 2019.11.20.10.39.46.411.0 ]--
r 111         MaxPQ<PointDist> points = new MaxPQ();
--[ 2019.11.20.10.39.48.263.0 ]--
r 111         MaxPQ<PointDist> points = new MaxPQ<>();
--[ 2019.11.20.10.39.58.937.0 ]--
r 113         return n;
--[ 2019.11.20.10.39.58.982.0 ]--
r 113         return nu;
--[ 2019.11.20.10.39.59.185.0 ]--
r 113         return nul;
--[ 2019.11.20.10.39.59.307.0 ]--
r 113         return null;
--[ 2019.11.20.10.40.03.558.0 ]--
+ 112         
--[ 2019.11.20.10.40.21.430.0 ]--
r 104             add np to maxPQ
--[ 2019.11.20.10.40.21.592.0 ]--
r 104             add nap to maxPQ
--[ 2019.11.20.10.40.22.019.0 ]--
r 104             add np to maxPQ
--[ 2019.11.20.10.40.22.100.0 ]--
r 104             add nep to maxPQ
--[ 2019.11.20.10.40.22.192.0 ]--
r 104             add neap to maxPQ
--[ 2019.11.20.10.40.22.229.0 ]--
r 104             add nearp to maxPQ
--[ 2019.11.20.10.40.22.344.0 ]--
r 104             add nearep to maxPQ
--[ 2019.11.20.10.40.22.509.0 ]--
r 104             add nearesp to maxPQ
--[ 2019.11.20.10.40.22.624.0 ]--
r 104             add nearestp to maxPQ
--[ 2019.11.20.10.40.22.685.0 ]--
r 104             add nearest p to maxPQ
--[ 2019.11.20.10.40.23.522.0 ]--
r 104             add nearest po to maxPQ
--[ 2019.11.20.10.40.23.685.0 ]--
r 104             add nearest poi to maxPQ
--[ 2019.11.20.10.40.23.750.0 ]--
r 104             add nearest poin to maxPQ
--[ 2019.11.20.10.40.23.805.0 ]--
r 104             add nearest point to maxPQ
--[ 2019.11.20.10.40.23.886.0 ]--
r 104             add nearest points to maxPQ
--[ 2019.11.20.10.40.24.793.0 ]--
r 104             add nearest points  to maxPQ
--[ 2019.11.20.10.40.24.837.0 ]--
r 104             add nearest points to maxPQ
--[ 2019.11.20.10.40.27.877.0 ]--
r 112 
--[ 2019.11.20.10.40.47.280.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.10.49.28.772.0 ]--
+ 112         
--[ 2019.11.20.10.49.29.836.0 ]--
r 112         f
--[ 2019.11.20.10.49.30.098.0 ]--
r 112         fr
--[ 2019.11.20.10.49.30.483.0 ]--
r 112         f
--[ 2019.11.20.10.49.30.722.0 ]--
r 112         fo
--[ 2019.11.20.10.49.30.811.0 ]--
r 112         for
--[ 2019.11.20.10.49.30.966.0 ]--
r 112         for()
--[ 2019.11.20.10.49.31.169.0 ]--
r 112         for(p)
--[ 2019.11.20.10.49.31.450.0 ]--
r 112         for()
--[ 2019.11.20.10.49.32.376.0 ]--
r 112         for(P)
--[ 2019.11.20.10.49.32.570.0 ]--
r 112         for(Po)
--[ 2019.11.20.10.49.32.691.0 ]--
r 112         for(Poi)
--[ 2019.11.20.10.49.32.742.0 ]--
r 112         for(Poin)
--[ 2019.11.20.10.49.32.840.0 ]--
r 112         for(Point)
--[ 2019.11.20.10.49.32.906.0 ]--
r 112         for(Point )
--[ 2019.11.20.10.49.32.968.0 ]--
r 112         for(Point q)
--[ 2019.11.20.10.49.33.334.0 ]--
r 112         for(Point q )
--[ 2019.11.20.10.49.33.479.0 ]--
r 112         for(Point q :)
--[ 2019.11.20.10.49.33.662.0 ]--
r 112         for(Point q : )
--[ 2019.11.20.10.49.34.593.0 ]--
r 112         for(Point q : p)
--[ 2019.11.20.10.49.34.734.0 ]--
r 112         for(Point q : po)
--[ 2019.11.20.10.49.34.875.0 ]--
r 112         for(Point q : poi)
--[ 2019.11.20.10.49.34.926.0 ]--
r 112         for(Point q : poin)
--[ 2019.11.20.10.49.34.991.0 ]--
r 112         for(Point q : point)
--[ 2019.11.20.10.49.35.301.0 ]--
r 112         for(Point q : point())
--[ 2019.11.20.10.49.35.739.0 ]--
r 112         for(Point q : point() )
--[ 2019.11.20.10.49.35.810.0 ]--
r 112         for(Point q : point())
--[ 2019.11.20.10.49.36.354.0 ]--
r 112         for(Point q : point()
--[ 2019.11.20.10.49.36.438.0 ]--
r 112         for(Point q : point)
--[ 2019.11.20.10.49.36.539.0 ]--
r 112         for(Point q : points)
--[ 2019.11.20.10.49.36.765.0 ]--
r 112         for(Point q : points())
--[ 2019.11.20.10.49.38.740.0 ]--
r 112         for(Point q : points()){
--[ 2019.11.20.10.49.38.934.0 ]--
+ 113 
+ 114 }
--[ 2019.11.20.10.49.38.957.0 ]--
r 114         }
--[ 2019.11.20.10.49.38.973.0 ]--
r 113             
--[ 2019.11.20.10.49.50.658.0 ]--
r 113             b
--[ 2019.11.20.10.49.50.882.0 ]--
r 113             br
--[ 2019.11.20.10.49.50.961.0 ]--
r 113             bre
--[ 2019.11.20.10.49.50.987.0 ]--
r 113             brea
--[ 2019.11.20.10.49.51.026.0 ]--
r 113             break
--[ 2019.11.20.10.49.51.406.0 ]--
r 113             break;
--[ 2019.11.20.10.49.55.541.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.12.52.04.510.0 ]--
+ 112         
--[ 2019.11.20.12.52.05.232.0 ]--
r 112          
--[ 2019.11.20.12.52.05.260.0 ]--
r 112         
--[ 2019.11.20.12.52.05.981.0 ]--
r 112         n
--[ 2019.11.20.12.52.06.017.0 ]--
r 112         ne
--[ 2019.11.20.12.52.06.140.0 ]--
r 112         new
--[ 2019.11.20.12.52.06.306.0 ]--
r 112         new 
--[ 2019.11.20.12.52.06.683.0 ]--
r 112         new S
--[ 2019.11.20.12.52.06.789.0 ]--
r 112         new St
--[ 2019.11.20.12.52.07.506.0 ]--
r 112         new St 
--[ 2019.11.20.12.52.07.566.0 ]--
r 112         new St
--[ 2019.11.20.12.52.07.623.0 ]--
r 112         new Sta
--[ 2019.11.20.12.52.07.743.0 ]--
r 112         new Stac
--[ 2019.11.20.12.52.07.839.0 ]--
r 112         new Stack
--[ 2019.11.20.12.52.08.369.0 ]--
r 112         new Stack 
--[ 2019.11.20.12.52.08.415.0 ]--
r 112         new Stack
--[ 2019.11.20.12.52.08.590.0 ]--
r 112         new 
--[ 2019.11.20.12.52.09.522.0 ]--
r 112         new
--[ 2019.11.20.12.52.09.622.0 ]--
r 112         ne
--[ 2019.11.20.12.52.09.732.0 ]--
r 112         n
--[ 2019.11.20.12.52.09.897.0 ]--
r 112         
--[ 2019.11.20.12.52.10.203.0 ]--
r 112         S
--[ 2019.11.20.12.52.10.387.0 ]--
r 112         St
--[ 2019.11.20.12.52.10.442.0 ]--
r 112         Sta
--[ 2019.11.20.12.52.10.569.0 ]--
r 112         Stac
--[ 2019.11.20.12.52.10.700.0 ]--
r 112         Stack
--[ 2019.11.20.12.52.10.897.0 ]--
r 112         Stack<>
--[ 2019.11.20.12.52.11.163.0 ]--
r 112         Stack<P>
--[ 2019.11.20.12.52.11.462.0 ]--
r 112         Stack<>
--[ 2019.11.20.12.52.11.754.0 ]--
r 112         Stack<P>
--[ 2019.11.20.12.52.11.954.0 ]--
r 112         Stack<Po>
--[ 2019.11.20.12.52.12.071.0 ]--
r 112         Stack<Poi>
--[ 2019.11.20.12.52.12.125.0 ]--
r 112         Stack<Poin>
--[ 2019.11.20.12.52.12.180.0 ]--
r 112         Stack<Point>
--[ 2019.11.20.12.52.12.304.0 ]--
r 112         Stack<Points>
--[ 2019.11.20.12.52.13.024.0 ]--
r 112         Stack<Points> 
--[ 2019.11.20.12.52.13.678.0 ]--
r 112         Stack<Points>
--[ 2019.11.20.12.52.14.505.0 ]--
r 112         Stack<Point>
--[ 2019.11.20.12.52.15.201.0 ]--
r 112         Stack<Point> 
--[ 2019.11.20.12.52.19.426.0 ]--
r 112         Stack<Point> s
--[ 2019.11.20.12.52.19.536.0 ]--
r 112         Stack<Point> st
--[ 2019.11.20.12.52.19.592.0 ]--
r 112         Stack<Point> sta
--[ 2019.11.20.12.52.19.958.0 ]--
r 112         Stack<Point> st
--[ 2019.11.20.12.52.20.051.0 ]--
r 112         Stack<Point> s
--[ 2019.11.20.12.52.20.558.0 ]--
r 112         Stack<Point> s 
--[ 2019.11.20.12.52.20.623.0 ]--
r 112         Stack<Point> s =
--[ 2019.11.20.12.52.20.757.0 ]--
r 112         Stack<Point> s = 
--[ 2019.11.20.12.52.22.969.0 ]--
r 112         Stack<Point> s =  
--[ 2019.11.20.12.52.23.060.0 ]--
r 112         Stack<Point> s = 
--[ 2019.11.20.12.52.23.267.0 ]--
r 112         Stack<Point> s = n
--[ 2019.11.20.12.52.23.345.0 ]--
r 112         Stack<Point> s = ne
--[ 2019.11.20.12.52.23.511.0 ]--
r 112         Stack<Point> s = new
--[ 2019.11.20.12.52.23.908.0 ]--
r 112         Stack<Point> s = new 
--[ 2019.11.20.12.52.24.327.0 ]--
r 112         Stack<Point> s = new S
--[ 2019.11.20.12.52.24.381.0 ]--
r 112         Stack<Point> s = new St
--[ 2019.11.20.12.52.24.422.0 ]--
r 112         Stack<Point> s = new Sta
--[ 2019.11.20.12.52.24.549.0 ]--
r 112         Stack<Point> s = new Stac
--[ 2019.11.20.12.52.24.661.0 ]--
r 112         Stack<Point> s = new Stacl
--[ 2019.11.20.12.52.24.833.0 ]--
r 112         Stack<Point> s = new Stacl<>
--[ 2019.11.20.12.52.25.244.0 ]--
r 112         Stack<Point> s = new Stacl<
--[ 2019.11.20.12.52.25.384.0 ]--
r 112         Stack<Point> s = new Stacl
--[ 2019.11.20.12.52.25.446.0 ]--
r 112         Stack<Point> s = new Stac
--[ 2019.11.20.12.52.25.899.0 ]--
r 112         Stack<Point> s = new Stack
--[ 2019.11.20.12.52.26.077.0 ]--
r 112         Stack<Point> s = new Stack<>
--[ 2019.11.20.12.52.26.586.0 ]--
r 112         Stack<Point> s = new Stack<
--[ 2019.11.20.12.52.26.948.0 ]--
r 112         Stack<Point> s = new Stack
--[ 2019.11.20.12.52.27.534.0 ]--
r 112         Stack<Point> s = new Stack<>
--[ 2019.11.20.12.52.27.846.0 ]--
r 112         Stack<Point> s = new Stack<>()
--[ 2019.11.20.12.52.28.047.0 ]--
r 112         Stack<Point> s = new Stack<>();
--[ 2019.11.20.12.52.33.456.0 ]--
+ 114             
--[ 2019.11.20.12.52.35.585.0 ]--
r 114              
--[ 2019.11.20.12.52.35.622.0 ]--
r 114             
--[ 2019.11.20.12.52.37.273.0 ]--
r 114              
--[ 2019.11.20.12.52.37.319.0 ]--
r 114             
--[ 2019.11.20.12.52.50.359.0 ]--
- 114
--[ 2019.11.20.12.52.55.260.0 ]--
r 112         
--[ 2019.11.20.12.52.55.596.0 ]--
- 112
--[ 2019.11.20.12.56.37.930.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.14.55.43.802.0 ]--
r 113             break
--[ 2019.11.20.14.55.44.001.0 ]--
r 113             
--[ 2019.11.20.14.55.51.810.0 ]--
r 113             p
--[ 2019.11.20.14.55.52.134.0 ]--
r 113             pi
--[ 2019.11.20.14.55.52.171.0 ]--
r 113             pin
--[ 2019.11.20.14.55.52.424.0 ]--
r 113             pi
--[ 2019.11.20.14.55.52.518.0 ]--
r 113             p
--[ 2019.11.20.14.55.52.700.0 ]--
r 113             po
--[ 2019.11.20.14.55.52.830.0 ]--
r 113             poi
--[ 2019.11.20.14.55.52.880.0 ]--
r 113             poin
--[ 2019.11.20.14.55.52.905.0 ]--
r 113             point
--[ 2019.11.20.14.55.52.955.0 ]--
r 113             points
--[ 2019.11.20.14.55.53.076.0 ]--
r 113             points.
--[ 2019.11.20.14.55.54.589.0 ]--
r 113             points. 
--[ 2019.11.20.14.55.54.631.0 ]--
r 113             points.
--[ 2019.11.20.14.55.54.770.0 ]--
r 113             points.i
--[ 2019.11.20.14.55.54.806.0 ]--
r 113             points.in
--[ 2019.11.20.14.55.54.915.0 ]--
r 113             points.ins
--[ 2019.11.20.14.55.55.065.0 ]--
r 113             points.inse
--[ 2019.11.20.14.55.55.121.0 ]--
r 113             points.inser
--[ 2019.11.20.14.55.55.704.0 ]--
r 113             points.insert
--[ 2019.11.20.14.55.55.715.0 ]--
r 113             points.insert()
--[ 2019.11.20.14.55.55.721.0 ]--
r 113             points.insert();
--[ 2019.11.20.14.55.56.702.0 ]--
r 113             points.insert(q);
--[ 2019.11.20.14.55.58.596.0 ]--
+ 114             
--[ 2019.11.20.14.55.59.935.0 ]--
- 114
--[ 2019.11.20.14.56.01.698.0 ]--
r 113             points.insert(q );
--[ 2019.11.20.14.56.01.773.0 ]--
r 113             points.insert(q);
--[ 2019.11.20.14.56.03.615.0 ]--
r 113             points.insert();
--[ 2019.11.20.14.56.31.853.0 ]--
r 113             points.insert(n);
--[ 2019.11.20.14.56.31.946.0 ]--
r 113             points.insert(ne);
--[ 2019.11.20.14.56.32.049.0 ]--
r 113             points.insert(new);
--[ 2019.11.20.14.56.32.688.0 ]--
r 113             points.insert(new );
--[ 2019.11.20.14.56.32.738.0 ]--
r 113             points.insert(new);
--[ 2019.11.20.14.56.34.597.0 ]--
r 113             points.insert(new );
--[ 2019.11.20.14.56.35.073.0 ]--
r 113             points.insert(new P);
--[ 2019.11.20.14.56.35.224.0 ]--
r 113             points.insert(new Po);
--[ 2019.11.20.14.56.35.361.0 ]--
r 113             points.insert(new Poi);
--[ 2019.11.20.14.56.35.402.0 ]--
r 113             points.insert(new Poin);
--[ 2019.11.20.14.56.35.491.0 ]--
r 113             points.insert(new Point);
--[ 2019.11.20.14.56.35.677.0 ]--
r 113             points.insert(new PointD);
--[ 2019.11.20.14.56.35.977.0 ]--
r 113             points.insert(new PointDist);
--[ 2019.11.20.14.56.35.986.0 ]--
r 113             points.insert(new PointDist());
--[ 2019.11.20.14.56.37.114.0 ]--
r 113             points.insert(new PointDist(q));
--[ 2019.11.20.14.56.40.190.0 ]--
r 113             points.insert(new PointDist(q,));
--[ 2019.11.20.14.56.40.324.0 ]--
r 113             points.insert(new PointDist(q, ));
--[ 2019.11.20.14.56.41.759.0 ]--
r 113             points.insert(new PointDist(q, p));
--[ 2019.11.20.14.56.41.913.0 ]--
r 113             points.insert(new PointDist(q, po));
--[ 2019.11.20.14.56.42.092.0 ]--
r 113             points.insert(new PointDist(q, poi));
--[ 2019.11.20.14.56.42.138.0 ]--
r 113             points.insert(new PointDist(q, poin));
--[ 2019.11.20.14.56.42.229.0 ]--
r 113             points.insert(new PointDist(q, point));
--[ 2019.11.20.14.56.44.026.0 ]--
r 113             points.insert(new PointDist(q, poin));
--[ 2019.11.20.14.56.44.182.0 ]--
r 113             points.insert(new PointDist(q, poi));
--[ 2019.11.20.14.56.44.358.0 ]--
r 113             points.insert(new PointDist(q, po));
--[ 2019.11.20.14.56.44.526.0 ]--
r 113             points.insert(new PointDist(q, p));
--[ 2019.11.20.14.56.44.879.0 ]--
r 113             points.insert(new PointDist(q, ));
--[ 2019.11.20.14.56.45.294.0 ]--
r 113             points.insert(new PointDist(q, p));
--[ 2019.11.20.14.56.45.575.0 ]--
r 113             points.insert(new PointDist(q, p.));
--[ 2019.11.20.14.56.46.706.0 ]--
r 113             points.insert(new PointDist(q, p.d));
--[ 2019.11.20.14.56.46.774.0 ]--
r 113             points.insert(new PointDist(q, p.di));
--[ 2019.11.20.14.56.46.838.0 ]--
r 113             points.insert(new PointDist(q, p.dis));
--[ 2019.11.20.14.56.46.998.0 ]--
r 113             points.insert(new PointDist(q, p.dist));
--[ 2019.11.20.14.56.47.610.0 ]--
r 113             points.insert(new PointDist(q, p.dist()));
--[ 2019.11.20.14.56.48.161.0 ]--
r 113             points.insert(new PointDist(q, p.dist(p)));
--[ 2019.11.20.14.56.48.941.0 ]--
r 113             points.insert(new PointDist(q, p.dist()));
--[ 2019.11.20.14.56.50.791.0 ]--
r 113             points.insert(new PointDist(q, .dist()));
--[ 2019.11.20.14.56.50.857.0 ]--
r 113             points.insert(new PointDist(q, q.dist()));
--[ 2019.11.20.14.56.52.104.0 ]--
r 113             points.insert(new PointDist(q, q.dist(p)));
--[ 2019.11.20.14.56.53.652.0 ]--
r 113             points.insert(new PointDist(q, q.dist(p))); 
--[ 2019.11.20.14.56.53.672.0 ]--
r 113             points.insert(new PointDist(q, q.dist(p)));
--[ 2019.11.20.14.56.58.611.0 ]--
r 113             points.insert(new PointDist(q, q.dist(p))); 
--[ 2019.11.20.14.56.58.663.0 ]--
r 113             points.insert(new PointDist(q, q.dist(p)));
--[ 2019.11.20.14.56.58.959.0 ]--
+ 114             
--[ 2019.11.20.14.56.59.385.0 ]--
r 114             i
--[ 2019.11.20.14.56.59.460.0 ]--
r 114             if
--[ 2019.11.20.14.56.59.906.0 ]--
r 114             if()
--[ 2019.11.20.14.57.00.761.0 ]--
r 114             if( )
--[ 2019.11.20.14.57.00.817.0 ]--
r 114             if()
--[ 2019.11.20.14.57.03.475.0 ]--
r 114             if( )
--[ 2019.11.20.14.57.03.516.0 ]--
r 114             if()
--[ 2019.11.20.14.57.06.856.0 ]--
r 114             if(p)
--[ 2019.11.20.14.57.06.992.0 ]--
r 114             if(po)
--[ 2019.11.20.14.57.07.137.0 ]--
r 114             if(poi)
--[ 2019.11.20.14.57.07.170.0 ]--
r 114             if(poin)
--[ 2019.11.20.14.57.07.208.0 ]--
r 114             if(point)
--[ 2019.11.20.14.57.07.295.0 ]--
r 114             if(points)
--[ 2019.11.20.14.57.07.357.0 ]--
r 114             if(points.)
--[ 2019.11.20.14.57.07.473.0 ]--
r 114             if(points.s)
--[ 2019.11.20.14.57.07.557.0 ]--
r 114             if(points.si)
--[ 2019.11.20.14.57.07.602.0 ]--
r 114             if(points.siz)
--[ 2019.11.20.14.57.07.774.0 ]--
r 114             if(points.size)
--[ 2019.11.20.14.57.07.888.0 ]--
r 114             if(points.size())
--[ 2019.11.20.14.57.08.036.0 ]--
r 114             if(points.size() )
--[ 2019.11.20.14.57.08.235.0 ]--
r 114             if(points.size() >)
--[ 2019.11.20.14.57.08.299.0 ]--
r 114             if(points.size() > )
--[ 2019.11.20.14.57.09.262.0 ]--
r 114             if(points.size() > k)
--[ 2019.11.20.14.57.09.668.0 ]--
r 114             if(points.size() > k){
--[ 2019.11.20.14.57.10.131.0 ]--
+ 115 
+ 116 }
--[ 2019.11.20.14.57.10.143.0 ]--
r 116             }
--[ 2019.11.20.14.57.10.156.0 ]--
r 115                 
--[ 2019.11.20.14.57.15.230.0 ]--
r 115                 d
--[ 2019.11.20.14.57.15.280.0 ]--
r 115                 de
--[ 2019.11.20.14.57.15.351.0 ]--
r 115                 del
--[ 2019.11.20.14.57.15.914.0 ]--
r 115                 delM
--[ 2019.11.20.14.57.16.254.0 ]--
r 115                 del
--[ 2019.11.20.14.57.16.326.0 ]--
r 115                 de
--[ 2019.11.20.14.57.16.451.0 ]--
r 115                 d
--[ 2019.11.20.14.57.16.583.0 ]--
r 115                 
--[ 2019.11.20.14.57.17.135.0 ]--
r 115                 p
--[ 2019.11.20.14.57.17.300.0 ]--
r 115                 po
--[ 2019.11.20.14.57.17.409.0 ]--
r 115                 poi
--[ 2019.11.20.14.57.17.452.0 ]--
r 115                 poin
--[ 2019.11.20.14.57.17.514.0 ]--
r 115                 point
--[ 2019.11.20.14.57.17.566.0 ]--
r 115                 points
--[ 2019.11.20.14.57.17.650.0 ]--
r 115                 points.
--[ 2019.11.20.14.57.17.799.0 ]--
r 115                 points.d
--[ 2019.11.20.14.57.17.849.0 ]--
r 115                 points.de
--[ 2019.11.20.14.57.17.951.0 ]--
r 115                 points.del
--[ 2019.11.20.14.57.18.225.0 ]--
r 115                 points.delMax
--[ 2019.11.20.14.57.18.234.0 ]--
r 115                 points.delMax()
--[ 2019.11.20.14.57.18.802.0 ]--
r 115                 points.delMax();
--[ 2019.11.20.14.57.27.597.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.14.57.43.414.0 ]--
+ 118         
--[ 2019.11.20.14.57.44.844.0 ]--
+ 118         
--[ 2019.11.20.14.57.45.287.0 ]--
r 119         f
--[ 2019.11.20.14.57.45.393.0 ]--
r 119         fo
--[ 2019.11.20.14.57.45.468.0 ]--
r 119         for
--[ 2019.11.20.14.57.45.809.0 ]--
r 119         for()
--[ 2019.11.20.14.57.46.907.0 ]--
r 119         for(i)
--[ 2019.11.20.14.57.46.980.0 ]--
r 119         for(in)
--[ 2019.11.20.14.57.47.003.0 ]--
r 119         for(int)
--[ 2019.11.20.14.57.47.058.0 ]--
r 119         for(int )
--[ 2019.11.20.14.57.47.129.0 ]--
r 119         for(int i)
--[ 2019.11.20.14.57.47.261.0 ]--
r 119         for(int i )
--[ 2019.11.20.14.57.47.849.0 ]--
r 119         for(int i =)
--[ 2019.11.20.14.57.47.960.0 ]--
r 119         for(int i = )
--[ 2019.11.20.14.57.48.005.0 ]--
r 119         for(int i = 0)
--[ 2019.11.20.14.57.48.937.0 ]--
r 119         for(int i = 0;)
--[ 2019.11.20.14.57.49.024.0 ]--
r 119         for(int i = 0; )
--[ 2019.11.20.14.57.49.795.0 ]--
r 119         for(int i = 0; i)
--[ 2019.11.20.14.57.49.856.0 ]--
r 119         for(int i = 0; i )
--[ 2019.11.20.14.57.49.983.0 ]--
r 119         for(int i = 0; i <)
--[ 2019.11.20.14.57.50.056.0 ]--
r 119         for(int i = 0; i < )
--[ 2019.11.20.14.57.51.495.0 ]--
r 119         for(int i = 0; i < p)
--[ 2019.11.20.14.57.51.636.0 ]--
r 119         for(int i = 0; i < po)
--[ 2019.11.20.14.57.51.762.0 ]--
r 119         for(int i = 0; i < poi)
--[ 2019.11.20.14.57.51.822.0 ]--
r 119         for(int i = 0; i < poin)
--[ 2019.11.20.14.57.51.925.0 ]--
r 119         for(int i = 0; i < point)
--[ 2019.11.20.14.57.52.140.0 ]--
r 119         for(int i = 0; i < points)
--[ 2019.11.20.14.57.52.230.0 ]--
r 119         for(int i = 0; i < points.)
--[ 2019.11.20.14.57.53.223.0 ]--
r 119         for(int i = 0; i < points.s)
--[ 2019.11.20.14.57.53.262.0 ]--
r 119         for(int i = 0; i < points.si)
--[ 2019.11.20.14.57.53.335.0 ]--
r 119         for(int i = 0; i < points.siz)
--[ 2019.11.20.14.57.53.528.0 ]--
r 119         for(int i = 0; i < points.size)
--[ 2019.11.20.14.57.53.628.0 ]--
r 119         for(int i = 0; i < points.size())
--[ 2019.11.20.14.57.54.734.0 ]--
r 119         for(int i = 0; i < points.size();)
--[ 2019.11.20.14.57.54.856.0 ]--
r 119         for(int i = 0; i < points.size(); )
--[ 2019.11.20.14.57.55.586.0 ]--
r 119         for(int i = 0; i < points.size(); i)
--[ 2019.11.20.14.57.56.025.0 ]--
r 119         for(int i = 0; i < points.size(); i+)
--[ 2019.11.20.14.57.56.124.0 ]--
r 119         for(int i = 0; i < points.size(); i++)
--[ 2019.11.20.14.57.56.630.0 ]--
r 119         for(int i = 0; i < points.size(); i++){
--[ 2019.11.20.14.57.57.267.0 ]--
+ 120 
+ 121 }
--[ 2019.11.20.14.57.57.321.0 ]--
r 121         }
--[ 2019.11.20.14.57.57.349.0 ]--
r 120             
--[ 2019.11.20.14.57.59.914.0 ]--
r 120             p
--[ 2019.11.20.14.58.00.039.0 ]--
r 120             po
--[ 2019.11.20.14.58.00.222.0 ]--
r 120             poi
--[ 2019.11.20.14.58.00.253.0 ]--
r 120             poin
--[ 2019.11.20.14.58.00.312.0 ]--
r 120             point
--[ 2019.11.20.14.58.00.415.0 ]--
r 120             points
--[ 2019.11.20.14.58.01.251.0 ]--
r 120             
--[ 2019.11.20.14.58.02.515.0 ]--
r 120              
--[ 2019.11.20.14.58.02.570.0 ]--
r 120             
--[ 2019.11.20.14.58.06.127.0 ]--
+ 111          
--[ 2019.11.20.14.58.06.171.0 ]--
r 111         
--[ 2019.11.20.14.58.08.692.0 ]--
- 121
--[ 2019.11.20.14.58.08.902.0 ]--
+ 121             
--[ 2019.11.20.14.58.19.934.0 ]--
r 121             p
--[ 2019.11.20.14.58.20.104.0 ]--
r 121             po
--[ 2019.11.20.14.58.20.285.0 ]--
r 121             poi
--[ 2019.11.20.14.58.20.315.0 ]--
r 121             poin
--[ 2019.11.20.14.58.20.395.0 ]--
r 121             point
--[ 2019.11.20.14.58.20.446.0 ]--
r 121             points
--[ 2019.11.20.14.58.21.187.0 ]--
r 121             points 
--[ 2019.11.20.14.58.21.234.0 ]--
r 121             points
--[ 2019.11.20.14.58.21.398.0 ]--
r 121             
--[ 2019.11.20.14.58.23.091.0 ]--
r 121             p
--[ 2019.11.20.14.58.23.208.0 ]--
r 121             po
--[ 2019.11.20.14.58.23.377.0 ]--
r 121             poi
--[ 2019.11.20.14.58.23.396.0 ]--
r 121             poin
--[ 2019.11.20.14.58.23.447.0 ]--
r 121             point
--[ 2019.11.20.14.58.23.494.0 ]--
r 121             points
--[ 2019.11.20.14.58.23.582.0 ]--
r 121             points.
--[ 2019.11.20.14.58.23.761.0 ]--
r 121             points.p
--[ 2019.11.20.14.58.24.395.0 ]--
r 121             points.po
--[ 2019.11.20.14.58.24.655.0 ]--
r 121             points.po 
--[ 2019.11.20.14.58.24.786.0 ]--
r 121             points.po
--[ 2019.11.20.14.58.24.958.0 ]--
r 121             points.
--[ 2019.11.20.14.58.25.150.0 ]--
r 121             points
--[ 2019.11.20.14.58.25.529.0 ]--
r 121             
--[ 2019.11.20.14.58.42.225.0 ]--
r 121             p
--[ 2019.11.20.14.58.42.388.0 ]--
r 121             po
--[ 2019.11.20.14.58.42.527.0 ]--
r 121             poi
--[ 2019.11.20.14.58.42.554.0 ]--
r 121             poin
--[ 2019.11.20.14.58.42.612.0 ]--
r 121             point
--[ 2019.11.20.14.58.42.704.0 ]--
r 121             points
--[ 2019.11.20.14.58.42.799.0 ]--
r 121             pointsp
--[ 2019.11.20.14.58.43.105.0 ]--
r 121             pointspi
--[ 2019.11.20.14.58.43.294.0 ]--
r 121             pointsp
--[ 2019.11.20.14.58.43.490.0 ]--
r 121             points
--[ 2019.11.20.14.58.43.561.0 ]--
r 121             points[]
--[ 2019.11.20.14.58.43.885.0 ]--
r 121             points[i]
--[ 2019.11.20.14.58.44.641.0 ]--
r 121             points[i].
--[ 2019.11.20.14.58.45.508.0 ]--
r 121             points[i]. 
--[ 2019.11.20.14.58.45.564.0 ]--
r 121             points[i].
--[ 2019.11.20.14.58.45.755.0 ]--
r 121             points[i]
--[ 2019.11.20.14.58.45.880.0 ]--
r 121             points[i
--[ 2019.11.20.14.58.46.142.0 ]--
r 121             points[
--[ 2019.11.20.14.58.46.434.0 ]--
r 121             points
--[ 2019.11.20.14.58.46.810.0 ]--
r 121             
--[ 2019.11.20.14.59.56.803.0 ]--
r 121              
--[ 2019.11.20.14.59.56.877.0 ]--
r 121             
--[ 2019.11.20.15.00.06.631.0 ]--
r 121              
--[ 2019.11.20.15.00.06.683.0 ]--
r 121             
--[ 2019.11.20.15.00.07.784.0 ]--
r 121             b
--[ 2019.11.20.15.00.07.971.0 ]--
r 121             br
--[ 2019.11.20.15.00.08.002.0 ]--
r 121             bre
--[ 2019.11.20.15.00.08.022.0 ]--
r 121             brea
--[ 2019.11.20.15.00.08.067.0 ]--
r 121             break
--[ 2019.11.20.15.00.08.236.0 ]--
r 121             break 
--[ 2019.11.20.15.00.08.295.0 ]--
r 121             break
--[ 2019.11.20.15.00.09.450.0 ]--
r 121             break;
--[ 2019.11.20.15.00.10.429.0 ]--
r 111 
r 119 
--[ 2019.11.20.15.50.42.266.0 ]--
- 120
- 120
- 120
--[ 2019.11.20.15.50.42.646.0 ]--
- 119
--[ 2019.11.20.15.51.24.052.0 ]--
+ 119         
--[ 2019.11.20.15.51.24.935.0 ]--
r 119          
--[ 2019.11.20.15.51.24.995.0 ]--
r 119         
--[ 2019.11.20.15.51.25.224.0 ]--
+ 119         
--[ 2019.11.20.15.51.25.949.0 ]--
- 119
--[ 2019.11.20.15.51.27.394.0 ]--
r 119          
--[ 2019.11.20.15.51.27.449.0 ]--
r 119         
--[ 2019.11.20.15.51.27.795.0 ]--
+ 119         
--[ 2019.11.20.15.51.28.345.0 ]--
r 120         p
--[ 2019.11.20.15.51.29.186.0 ]--
r 120         p 
--[ 2019.11.20.15.51.29.214.0 ]--
r 120         p
--[ 2019.11.20.15.51.29.325.0 ]--
r 120         po
--[ 2019.11.20.15.51.29.543.0 ]--
r 120         poi
--[ 2019.11.20.15.51.29.609.0 ]--
r 120         poin
--[ 2019.11.20.15.51.29.633.0 ]--
r 120         point
--[ 2019.11.20.15.51.29.680.0 ]--
r 120         points
--[ 2019.11.20.15.51.29.802.0 ]--
r 120         points.
--[ 2019.11.20.15.51.30.860.0 ]--
r 120         points
--[ 2019.11.20.15.51.31.277.0 ]--
r 120         
--[ 2019.11.20.15.51.32.652.0 ]--
- 119
--[ 2019.11.20.15.51.34.916.0 ]--
+ 119         
--[ 2019.11.20.15.51.36.233.0 ]--
r 120          
--[ 2019.11.20.15.51.36.324.0 ]--
r 120         
--[ 2019.11.20.15.51.38.180.0 ]--
- 119
--[ 2019.11.20.15.51.39.652.0 ]--
+ 119         
--[ 2019.11.20.15.51.40.784.0 ]--
r 120         p
--[ 2019.11.20.15.51.41.317.0 ]--
r 120         po
--[ 2019.11.20.15.51.41.436.0 ]--
r 120         poi
--[ 2019.11.20.15.51.41.500.0 ]--
r 120         poin
--[ 2019.11.20.15.51.41.556.0 ]--
r 120         point
--[ 2019.11.20.15.51.41.603.0 ]--
r 120         points
--[ 2019.11.20.15.51.42.052.0 ]--
r 120         points.
--[ 2019.11.20.15.51.46.876.0 ]--
r 120         points
--[ 2019.11.20.15.51.47.043.0 ]--
r 120         
--[ 2019.11.20.15.51.47.255.0 ]--
r 120 
--[ 2019.11.20.15.51.47.777.0 ]--
r 120         points.
--[ 2019.11.20.15.51.48.269.0 ]--
r 120         points
--[ 2019.11.20.15.51.48.521.0 ]--
r 120         
--[ 2019.11.20.15.52.15.879.0 ]--
r 119            
--[ 2019.11.20.15.52.16.003.0 ]--
r 119                
--[ 2019.11.20.15.52.16.729.0 ]--
+ 119         
r 120         
--[ 2019.11.20.15.52.16.907.0 ]--
r 120         n
--[ 2019.11.20.15.52.16.972.0 ]--
r 120         ne
--[ 2019.11.20.15.52.17.132.0 ]--
r 120         new
--[ 2019.11.20.15.52.18.061.0 ]--
r 120         ne
--[ 2019.11.20.15.52.18.165.0 ]--
r 120         n
--[ 2019.11.20.15.52.18.304.0 ]--
r 120         
--[ 2019.11.20.15.52.19.053.0 ]--
r 120         S
--[ 2019.11.20.15.52.19.222.0 ]--
r 120         St
--[ 2019.11.20.15.52.19.301.0 ]--
r 120         Sta
--[ 2019.11.20.15.52.19.419.0 ]--
r 120         Stac
--[ 2019.11.20.15.52.20.011.0 ]--
r 120         Stack
--[ 2019.11.20.15.52.20.476.0 ]--
r 120         Stack<>
--[ 2019.11.20.15.52.20.678.0 ]--
r 120         Stack<p>
--[ 2019.11.20.15.52.20.817.0 ]--
r 120         Stack<po>
--[ 2019.11.20.15.52.20.956.0 ]--
r 120         Stack<poi>
--[ 2019.11.20.15.52.21.266.0 ]--
r 120         Stack<po>
--[ 2019.11.20.15.52.21.351.0 ]--
r 120         Stack<p>
--[ 2019.11.20.15.52.21.460.0 ]--
r 120         Stack<>
--[ 2019.11.20.15.52.21.605.0 ]--
r 120         Stack<P>
--[ 2019.11.20.15.52.21.775.0 ]--
r 120         Stack<Po>
--[ 2019.11.20.15.52.21.902.0 ]--
r 120         Stack<Poi>
--[ 2019.11.20.15.52.21.958.0 ]--
r 120         Stack<Poin>
--[ 2019.11.20.15.52.22.013.0 ]--
r 120         Stack<Point>
--[ 2019.11.20.15.52.23.117.0 ]--
r 120         Stack<Point> 
--[ 2019.11.20.15.52.23.863.0 ]--
r 120         Stack<Point> s
--[ 2019.11.20.15.52.24.648.0 ]--
r 120         Stack<Point> s 
--[ 2019.11.20.15.52.24.714.0 ]--
r 120         Stack<Point> s =
--[ 2019.11.20.15.52.24.778.0 ]--
r 120         Stack<Point> s = 
--[ 2019.11.20.15.52.24.899.0 ]--
r 120         Stack<Point> s = n
--[ 2019.11.20.15.52.25.058.0 ]--
r 120         Stack<Point> s = nw
--[ 2019.11.20.15.52.25.305.0 ]--
r 120         Stack<Point> s = n
--[ 2019.11.20.15.52.25.337.0 ]--
r 120         Stack<Point> s = ne
--[ 2019.11.20.15.52.25.452.0 ]--
r 120         Stack<Point> s = new
--[ 2019.11.20.15.52.25.545.0 ]--
r 120         Stack<Point> s = new 
--[ 2019.11.20.15.52.25.651.0 ]--
r 120         Stack<Point> s = new S
--[ 2019.11.20.15.52.25.827.0 ]--
r 120         Stack<Point> s = new St
--[ 2019.11.20.15.52.25.856.0 ]--
r 120         Stack<Point> s = new Sta
--[ 2019.11.20.15.52.25.980.0 ]--
r 120         Stack<Point> s = new Stac
--[ 2019.11.20.15.52.26.059.0 ]--
r 120         Stack<Point> s = new Stack
--[ 2019.11.20.15.52.26.253.0 ]--
r 120         Stack<Point> s = new Stack<>
--[ 2019.11.20.15.52.26.630.0 ]--
r 120         Stack<Point> s = new Stack<>)
--[ 2019.11.20.15.52.26.903.0 ]--
r 120         Stack<Point> s = new Stack<>
--[ 2019.11.20.15.52.27.182.0 ]--
r 120         Stack<Point> s = new Stack<>()
--[ 2019.11.20.15.52.27.400.0 ]--
r 120         Stack<Point> s = new Stack<>();
--[ 2019.11.20.15.52.27.694.0 ]--
r 120         Stack<Point> s = new Stack<>(); 
--[ 2019.11.20.15.52.27.746.0 ]--
r 120         Stack<Point> s = new Stack<>();
--[ 2019.11.20.15.52.28.097.0 ]--
+ 121         
--[ 2019.11.20.15.52.28.923.0 ]--
+ 121         
--[ 2019.11.20.15.52.29.062.0 ]--
r 122         f
--[ 2019.11.20.15.52.29.159.0 ]--
r 122         fo
--[ 2019.11.20.15.52.29.227.0 ]--
r 122         for
--[ 2019.11.20.15.52.30.515.0 ]--
r 122         foreach
--[ 2019.11.20.15.52.30.567.0 ]--
+ 122         for ( : ) {
+ 123     
r 124 }
--[ 2019.11.20.15.52.30.589.0 ]--
r 122         for (a : a) {
r 123     a
--[ 2019.11.20.15.52.30.600.0 ]--
r 123             a
r 124         }
--[ 2019.11.20.15.52.30.612.0 ]--
+ 121 
r 122         for (a:
r 123              a) {
--[ 2019.11.20.15.52.30.621.0 ]--
r 122         for (:
r 123              ) {
r 124             
--[ 2019.11.20.15.52.37.911.0 ]--
r 122         for (p:
--[ 2019.11.20.15.52.38.832.0 ]--
r 122         for (:
--[ 2019.11.20.15.52.39.178.0 ]--
r 122         for (P:
--[ 2019.11.20.15.52.39.516.0 ]--
r 122         for (Po:
--[ 2019.11.20.15.52.39.665.0 ]--
r 122         for (Poi:
--[ 2019.11.20.15.52.39.710.0 ]--
r 122         for (Poin:
--[ 2019.11.20.15.52.39.799.0 ]--
r 122         for (Point:
--[ 2019.11.20.15.52.40.026.0 ]--
r 122         for (PointD:
--[ 2019.11.20.15.52.40.155.0 ]--
r 122         for (PointDi:
--[ 2019.11.20.15.52.40.239.0 ]--
r 122         for (PointDis:
--[ 2019.11.20.15.52.40.406.0 ]--
r 122         for (PointDist:
--[ 2019.11.20.15.52.40.716.0 ]--
r 122         for (PointDist :
--[ 2019.11.20.15.52.41.122.0 ]--
r 122         for (PointDist p:
--[ 2019.11.20.15.52.41.945.0 ]--
r 122         for (PointDist p: 
--[ 2019.11.20.15.52.42.980.0 ]--
r 122         for (PointDist p: m
--[ 2019.11.20.15.52.43.074.0 ]--
r 122         for (PointDist p: ma
--[ 2019.11.20.15.52.43.164.0 ]--
r 122         for (PointDist p: max
--[ 2019.11.20.15.52.43.817.0 ]--
r 122         for (PointDist p: ma
--[ 2019.11.20.15.52.43.913.0 ]--
r 122         for (PointDist p: m
--[ 2019.11.20.15.52.44.025.0 ]--
r 122         for (PointDist p: 
--[ 2019.11.20.15.52.44.221.0 ]--
r 122         for (PointDist p: p
--[ 2019.11.20.15.52.44.548.0 ]--
r 122         for (PointDist p: pi
--[ 2019.11.20.15.52.44.604.0 ]--
r 122         for (PointDist p: pin
--[ 2019.11.20.15.52.44.689.0 ]--
r 122         for (PointDist p: pint
--[ 2019.11.20.15.52.45.076.0 ]--
r 122         for (PointDist p: pin
--[ 2019.11.20.15.52.45.159.0 ]--
r 122         for (PointDist p: pi
--[ 2019.11.20.15.52.45.303.0 ]--
r 122         for (PointDist p: p
--[ 2019.11.20.15.52.45.525.0 ]--
r 122         for (PointDist p: po
--[ 2019.11.20.15.52.45.726.0 ]--
r 122         for (PointDist p: poi
--[ 2019.11.20.15.52.45.793.0 ]--
r 122         for (PointDist p: poin
--[ 2019.11.20.15.52.45.827.0 ]--
r 122         for (PointDist p: point
--[ 2019.11.20.15.52.45.848.0 ]--
r 122         for (PointDist p: points
--[ 2019.11.20.15.52.49.099.0 ]--
r 123         ) {
--[ 2019.11.20.15.52.49.458.0 ]--
- 122
r 122         for (PointDist p: points) {
--[ 2019.11.20.15.52.53.785.0 ]--
r 123             s
--[ 2019.11.20.15.52.53.876.0 ]--
r 123             s.
--[ 2019.11.20.15.52.54.147.0 ]--
r 123             s.p
--[ 2019.11.20.15.52.54.261.0 ]--
r 123             s.pu
--[ 2019.11.20.15.52.54.362.0 ]--
r 123             s.pus
--[ 2019.11.20.15.52.54.472.0 ]--
r 123             s.push
--[ 2019.11.20.15.52.54.742.0 ]--
r 123             s.push()
--[ 2019.11.20.15.52.56.035.0 ]--
r 123             s.push(p)
--[ 2019.11.20.15.52.56.207.0 ]--
r 123             s.push(p.)
--[ 2019.11.20.15.52.56.607.0 ]--
r 123             s.push(p.p)
--[ 2019.11.20.15.52.58.025.0 ]--
r 123             s.push(p.p )
--[ 2019.11.20.15.52.58.062.0 ]--
r 123             s.push(p.p)
--[ 2019.11.20.15.52.58.466.0 ]--
r 123             s.push(p.)
--[ 2019.11.20.15.53.00.038.0 ]--
r 123             s.push(p.p)
--[ 2019.11.20.15.53.00.223.0 ]--
r 123             s.push(p.p())
--[ 2019.11.20.15.53.01.074.0 ]--
r 123             s.push(p.p());
--[ 2019.11.20.15.53.17.275.0 ]--
r 122         for (PointDist po: points) {
--[ 2019.11.20.15.53.17.647.0 ]--
r 122         for (PointDist poi: points) {
--[ 2019.11.20.15.53.17.701.0 ]--
r 122         for (PointDist poin: points) {
--[ 2019.11.20.15.53.17.807.0 ]--
r 122         for (PointDist point: points) {
--[ 2019.11.20.15.53.20.934.0 ]--
r 123             s.push(pp.p());
--[ 2019.11.20.15.53.21.301.0 ]--
r 123             s.push(p.p());
--[ 2019.11.20.15.53.21.404.0 ]--
r 123             s.push(po.p());
--[ 2019.11.20.15.53.21.557.0 ]--
r 123             s.push(poi.p());
--[ 2019.11.20.15.53.21.607.0 ]--
r 123             s.push(poin.p());
--[ 2019.11.20.15.53.21.689.0 ]--
r 123             s.push(point.p());
--[ 2019.11.20.15.53.25.085.0 ]--
r 128         return s;
--[ 2019.11.20.15.53.27.508.0 ]--
r 119 
--[ 2019.11.20.15.53.29.142.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.20.15.54.18.485.0 ]--
r 125 
--[ 2019.11.20.15.54.18.598.0 ]--
DisposeComponent
--[ 2019.11.25.17.41.40.130.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.25.17.41.40.745.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.25.17.41.40.747.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.25.17.41.40.748.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.25.17.41.40.749.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.25.17.41.40.752.0 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.25.17.41.40.753.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.25.17.41.40.753.1 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.25.17.41.40.758.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.25.17.41.40.759.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.25.17.41.40.760.0 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {

        /* Pseudo code
        new maxPQ
        for i in k{
            add nearest points to maxPQ
            if(maxPQ.size() > k){
                remove the max from the list
            }
        }

         */

        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());
        }



        return s;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.25.17.41.40.760.1 ]--
InitFile: /.cos265


--[ 2019.11.25.17.41.40.761.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.25.17.41.40.762.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.25.17.41.40.762.1 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.25.17.42.11.987.0 ]--
:/src/PSBruteForce.java
- 124
r 124         
--[ 2019.11.25.17.43.55.679.0 ]--
UpdateTree (AD): 0 1
- /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.25.17.43.55.680.0 ]--
CompilationStatus (AEW): 0 12 0
[Ljava.lang.String;@1edc9c27
--[ 2019.11.25.17.44.16.542.0 ]--
r 124 
--[ 2019.11.25.17.44.16.543.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.25.17.44.16.572.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.25.17.44.18.632.0 ]--
UpdateTree (AD): 1 1
- /out/production/P05_KDTrees/PSBruteForce.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.25.17.44.47.249.0 ]--
DisposeComponent
--[ 2019.11.25.17.45.01.522.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.25.17.45.01.601.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.25.17.45.01.601.1 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.25.17.45.01.601.2 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.25.17.45.01.602.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.25.17.45.01.602.1 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.25.17.45.01.602.2 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {

    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }

    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
    }

    public Value get(Point p) {
        return null;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return null; }
    public Point max() { return null; }

    // return the number of Points in kD-tree
    public int size() { return 0; }

    // return whether the kD-tree is empty
    public boolean isEmpty() { return true; }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.25.17.45.01.603.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.25.17.45.01.603.1 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.25.17.45.01.603.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.25.17.45.01.603.3 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {

        /* Pseudo code
        new maxPQ
        for i in k{
            add nearest points to maxPQ
            if(maxPQ.size() > k){
                remove the max from the list
            }
        }

         */

        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());



        return s;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.25.17.45.01.604.0 ]--
InitFile: /.cos265


--[ 2019.11.25.17.45.01.604.1 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.25.17.45.01.604.2 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.25.17.45.01.604.3 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.25.17.58.43.698.0 ]--
DisposeComponent
--[ 2019.11.25.18.01.31.030.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.11.25.18.01.31.081.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.11.25.18.01.31.082.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.11.25.18.01.31.082.1 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.11.25.18.01.31.083.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.11.25.18.01.31.083.1 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.11.25.18.01.31.083.2 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {
    PointSearch<Value> kdTree;
    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }
    double xMin;
    double xMax;
    double yMin;
    double yMax;
    int treeSize = 0;
    Node root;
    // constructor makes empty kD-tree
    public PSKDTree() { kdTree = new PSKDTree<>(); }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
        if ( kdTree.size() == 0 ) {
            root = new Node();
            root.p = p;
            root.v = v;
            root.dir = Partition.Direction.LEFTRIGHT;
        }
        else {
            root = putX(root, p, v);
        }
        treeSize ++;
        if ( kdTree.size() == 1 ) {
            xMin = p.x();
            xMax = p.x();
            yMin = p.y();
            yMax = p.y();
        }
        else {
            if ( p.x() <= xMin ) {
                xMin = p.x();
            }
            else if ( p.x() >= xMax ) {
                xMax = p.x();
            }
            if ( p.y() <= yMin ) {
                yMin = p.y();
            }
            else if ( p.y() >= yMax ) {
                yMax = p.y();
            }
        }
    }
    private Node putX( Node node, Point p, Value v) {
        if( node == null ) {
            Node alt = new Node();
            alt.p = p;
            alt.v = v;
            alt.dir = Partition.Direction.DOWNUP;
            return alt;
        }
        if ( p.x() < node.p.x() ) {
            node.left = putY( node.left,p,v );
        }
        else if ( p.x() > node.p.x() ) {
            node.right = putY( node.right,p,v );
        }
        else if ( p.x() == node.p.x() ) {
            if ( p.y() == node.p.y() ) node.v = v;
            else node.left = putY( node.left,p,v );
        }
        return node;
    }
    private Node putY( Node node, Point p, Value v) {
        if( node == null ) {
            Node alt = new Node();
            alt.p = p;
            alt.v = v;
            alt.dir = Partition.Direction.LEFTRIGHT;
            return alt;
        }
        if ( p.y() < node.p.y() ) {
            node.left = putX( node.left,p,v );
        }
        else if ( p.y() > node.p.y() ) {
            node.right = putX( node.right,p,v );
        }
        else if ( p.y() == node.p.y() ) {
            if ( p.x() == node.p.x() ) node.v = v;
            else node.left = putX( node.left,p,v );
        }
        return node;
    }

    public Value get(Point p) {
        if ( p == root.p ) {
            return root.v;
        }
        Node check = root;
        while ( p != check.p ) {
            if ( check.dir == Partition.Direction.LEFTRIGHT ) {
                if ( p.x() > check.p.x() ) {
                    check = check.right;
                }
                else check = check.left;
            }
            else if ( check.dir == Partition.Direction.DOWNUP ) {
                if ( p.y() > check.p.y() ) {
                    check = check.right;
                }
                else check = check.left;
            }
            else if ( check == null ) {
                break;
            }
            else {
                throw new RuntimeException("Node in KDTree is improperly defined!");
            }
        }
        if ( check == null ) return null;
        return check.v;
    }

    public boolean contains(Point p) {
        return false;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() { return null; }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        return null;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return new Point(xMin,yMin); }
    public Point max() { return new Point(xMax,yMax); }

    // return the number of Points in kD-tree
    public int size() { return treeSize; }

    // return whether the kD-tree is empty
    public boolean isEmpty() {
        if( treeSize == 0 ) return true;
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }

}

--[ 2019.11.25.18.01.31.084.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSBruteForce<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.11.25.18.01.31.084.1 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.11.25.18.01.31.084.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.11.25.18.01.31.084.3 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return null;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {

        /* Pseudo code
        new maxPQ
        for i in k{
            add nearest points to maxPQ
            if(maxPQ.size() > k){
                remove the max from the list
            }
        }

         */

        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());



        return s;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.11.25.18.01.31.085.0 ]--
InitFile: /.cos265


--[ 2019.11.25.18.01.31.085.1 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.11.25.18.01.31.085.2 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.11.25.18.01.31.086.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.11.25.18.04.40.924.0 ]--
:/src/PSBruteForce.java
- 100
- 100
- 100
- 100
- 100
- 100
- 100
- 100
- 100
- 101
--[ 2019.11.25.18.04.42.119.0 ]--
r 100  
--[ 2019.11.25.18.04.42.226.0 ]--
- 100
--[ 2019.11.25.18.04.43.366.0 ]--
+ 100  
--[ 2019.11.25.18.05.06.788.0 ]--
r 100 
--[ 2019.11.25.18.05.08.597.0 ]--
UpdateTree (AD): 0 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class

--[ 2019.11.25.18.05.08.598.0 ]--
CompilationStatus (AEW): 0 12 0
[Ljava.lang.String;@78b69e65
--[ 2019.11.25.18.05.32.901.0 ]--
+ 114             
--[ 2019.11.25.18.05.32.902.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.32.920.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.33.437.0 ]--
- 114
--[ 2019.11.25.18.05.33.437.1 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.33.445.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.163.0 ]--
+ 114             
--[ 2019.11.25.18.05.34.164.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.171.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.427.0 ]--
r 114             }
--[ 2019.11.25.18.05.34.427.1 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.431.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.435.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.438.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.441.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.444.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.447.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.450.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.453.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.456.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.459.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.463.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.715.0 ]--
r 114         }
--[ 2019.11.25.18.05.34.716.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.34.727.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.35.877.0 ]--
r 114         } 
--[ 2019.11.25.18.05.35.878.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.35.883.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.35.902.0 ]--
r 114         }
--[ 2019.11.25.18.05.35.903.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.35.906.0 ]--
UpdateTree (AD): 2 2
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.40.584.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.05.40.585.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.18.05.47.924.0 ]--
UpdateTree (AD): 2 0
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSBruteForce.class

--[ 2019.11.25.18.06.32.203.0 ]--
:/src/PSKDTree.java
r 128         return false ;
--[ 2019.11.25.18.06.32.241.0 ]--
r 128         return false;
--[ 2019.11.25.18.06.42.941.0 ]--
r 128         ireturn false;
--[ 2019.11.25.18.06.42.967.0 ]--
r 128         ifreturn false;
--[ 2019.11.25.18.06.43.147.0 ]--
r 128         if(return false;
--[ 2019.11.25.18.06.43.800.0 ]--
r 128         if(greturn false;
--[ 2019.11.25.18.06.43.905.0 ]--
r 128         if(gereturn false;
--[ 2019.11.25.18.06.43.981.0 ]--
r 128         if(getreturn false;
--[ 2019.11.25.18.06.44.237.0 ]--
r 128         if(get(return false;
--[ 2019.11.25.18.06.44.307.0 ]--
r 128         if(get()return false;
--[ 2019.11.25.18.06.44.757.0 ]--
r 128         if(get() return false;
--[ 2019.11.25.18.06.44.908.0 ]--
r 128         if(get() =return false;
--[ 2019.11.25.18.06.45.011.0 ]--
r 128         if(get() ==return false;
--[ 2019.11.25.18.06.45.664.0 ]--
r 128         if(get() == return false;
--[ 2019.11.25.18.06.45.777.0 ]--
r 128         if(get() == nreturn false;
--[ 2019.11.25.18.06.45.848.0 ]--
r 128         if(get() == nureturn false;
--[ 2019.11.25.18.06.46.285.0 ]--
r 128         if(get() == nulreturn false;
--[ 2019.11.25.18.06.46.312.0 ]--
r 128         if(get() == nullreturn false;
--[ 2019.11.25.18.06.46.566.0 ]--
r 128         if(get() == null)return false;
--[ 2019.11.25.18.06.47.055.0 ]--
r 128         if(get() == null) return false;
--[ 2019.11.25.18.06.47.997.0 ]--
+ 129         
--[ 2019.11.25.18.06.52.723.0 ]--
r 128         if(get(p) == null) return false;
--[ 2019.11.25.18.06.54.750.0 ]--
- 129
--[ 2019.11.25.18.06.55.044.0 ]--
+ 129         
--[ 2019.11.25.18.06.55.853.0 ]--
r 129         r
--[ 2019.11.25.18.06.55.967.0 ]--
r 129         re
--[ 2019.11.25.18.06.56.036.0 ]--
r 129         ret
--[ 2019.11.25.18.06.56.130.0 ]--
r 129         retu
--[ 2019.11.25.18.06.56.195.0 ]--
r 129         retur
--[ 2019.11.25.18.06.56.268.0 ]--
r 129         return
--[ 2019.11.25.18.06.56.369.0 ]--
r 129         return 
--[ 2019.11.25.18.06.56.696.0 ]--
r 129         return t
--[ 2019.11.25.18.06.56.865.0 ]--
r 129         return tr
--[ 2019.11.25.18.06.56.906.0 ]--
r 129         return tru
--[ 2019.11.25.18.06.56.991.0 ]--
r 129         return true
--[ 2019.11.25.18.06.57.099.0 ]--
r 129         return true;
--[ 2019.11.25.18.07.27.211.0 ]--
:/src/NearestNeighborVisualizer.java
r 18         return new P<>();
--[ 2019.11.25.18.07.27.293.0 ]--
r 18         return new PS<>();
--[ 2019.11.25.18.07.27.365.0 ]--
r 18         return new PSK<>();
--[ 2019.11.25.18.07.28.857.0 ]--
r 18         return new PSKDTree<>();
--[ 2019.11.25.18.07.28.871.0 ]--
r 18         return new PSKDTree();
--[ 2019.11.25.18.07.28.884.0 ]--
r 18         return new PSKDTree<>();
--[ 2019.11.25.18.07.33.428.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.18.09.53.957.0 ]--
:/src/PSKDTree.java
r 22     public PSKDTree() { kdTree = new B<>(); }
--[ 2019.11.25.18.09.54.078.0 ]--
r 22     public PSKDTree() { kdTree = new BS<>(); }
--[ 2019.11.25.18.09.54.285.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.09.54.706.0 ]--
r 22     public PSKDTree() { kdTree = new BST <>(); }
--[ 2019.11.25.18.09.54.766.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.03.436.0 ]--
r 22     public PSKDTree() { kdTree = new BST(<>(); }
--[ 2019.11.25.18.10.03.464.0 ]--
r 22     public PSKDTree() { kdTree = new BST()<>(); }
--[ 2019.11.25.18.10.08.214.0 ]--
UpdateTree (AD): 0 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class

--[ 2019.11.25.18.10.08.216.0 ]--
CompilationStatus (AEW): 0 57 0
[Ljava.lang.String;@44062d6
--[ 2019.11.25.18.10.09.240.0 ]--
r 22     public PSKDTree() { kdTree = new BST()>(); }
--[ 2019.11.25.18.10.09.241.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.256.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.263.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.273.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.359.0 ]--
r 22     public PSKDTree() { kdTree = new BST(>(); }
--[ 2019.11.25.18.10.09.359.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.362.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.365.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.09.367.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.10.195.0 ]--
r 22     public PSKDTree() { kdTree = new BST>(); }
--[ 2019.11.25.18.10.10.196.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.10.199.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.11.006.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.11.006.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.11.010.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.20.623.0 ]--
r 22     public PSKDTree() { kdTree = new BST< >(); }
--[ 2019.11.25.18.10.20.623.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.20.626.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.20.701.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.20.701.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.20.704.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.22.012.0 ]--
r 22     public PSKDTree() { kdTree = new BST< >(); }
--[ 2019.11.25.18.10.22.013.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.22.019.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.22.069.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.22.069.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.22.072.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.23.739.0 ]--
r 22     public PSKDTree() { kdTree = new BST< >(); }
--[ 2019.11.25.18.10.23.741.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.23.747.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.24.106.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.24.107.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.24.112.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.24.348.0 ]--
r 22     public PSKDTree() { kdTree = new BST< >(); }
--[ 2019.11.25.18.10.24.349.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.24.351.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.24.650.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.24.651.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.24.654.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.149.0 ]--
r 22     public PSKDTree() { kdTree = new BST>(); }
--[ 2019.11.25.18.10.25.149.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.152.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.321.0 ]--
r 22     public PSKDTree() { kdTree = new BST()<>(); }
--[ 2019.11.25.18.10.25.321.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.323.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.325.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.327.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.827.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.10.25.827.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.830.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.833.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.835.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.990.0 ]--
r 22     public PSKDTree() { kdTree = new BST <>(); }
--[ 2019.11.25.18.10.25.990.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.25.993.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.26.178.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.10.26.179.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.26.181.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.10.26.184.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.12.18.019.0 ]--
+ 9     
--[ 2019.11.25.18.12.31.134.0 ]--
- 9
--[ 2019.11.25.18.12.31.383.0 ]--
r 8     PointSearch<Value> kdTree; 
--[ 2019.11.25.18.12.31.412.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.12.34.027.0 ]--
r 22     public PSKDTree() { kdTree = new P<>(); }
--[ 2019.11.25.18.12.34.310.0 ]--
r 22     public PSKDTree() { kdTree = new Pi<>(); }
--[ 2019.11.25.18.12.34.388.0 ]--
r 22     public PSKDTree() { kdTree = new Pin<>(); }
--[ 2019.11.25.18.12.34.502.0 ]--
r 22     public PSKDTree() { kdTree = new Pint<>(); }
--[ 2019.11.25.18.12.34.988.0 ]--
r 22     public PSKDTree() { kdTree = new Pin<>(); }
--[ 2019.11.25.18.12.35.119.0 ]--
r 22     public PSKDTree() { kdTree = new Pi<>(); }
--[ 2019.11.25.18.12.35.320.0 ]--
r 22     public PSKDTree() { kdTree = new Pio<>(); }
--[ 2019.11.25.18.12.35.471.0 ]--
r 22     public PSKDTree() { kdTree = new Pioi<>(); }
--[ 2019.11.25.18.12.35.540.0 ]--
r 22     public PSKDTree() { kdTree = new Pioin<>(); }
--[ 2019.11.25.18.12.35.683.0 ]--
r 22     public PSKDTree() { kdTree = new Pioi<>(); }
--[ 2019.11.25.18.12.35.790.0 ]--
r 22     public PSKDTree() { kdTree = new Pio<>(); }
--[ 2019.11.25.18.12.35.891.0 ]--
r 22     public PSKDTree() { kdTree = new Pi<>(); }
--[ 2019.11.25.18.12.36.158.0 ]--
r 22     public PSKDTree() { kdTree = new Pio<>(); }
--[ 2019.11.25.18.12.36.347.0 ]--
r 22     public PSKDTree() { kdTree = new Pi<>(); }
--[ 2019.11.25.18.12.36.438.0 ]--
r 22     public PSKDTree() { kdTree = new P<>(); }
--[ 2019.11.25.18.12.36.579.0 ]--
r 22     public PSKDTree() { kdTree = new Po<>(); }
--[ 2019.11.25.18.12.36.722.0 ]--
r 22     public PSKDTree() { kdTree = new Poi<>(); }
--[ 2019.11.25.18.12.36.761.0 ]--
r 22     public PSKDTree() { kdTree = new Poin<>(); }
--[ 2019.11.25.18.12.36.834.0 ]--
r 22     public PSKDTree() { kdTree = new Point<>(); }
--[ 2019.11.25.18.12.37.413.0 ]--
r 22     public PSKDTree() { kdTree = new PointS<>(); }
--[ 2019.11.25.18.12.37.576.0 ]--
r 22     public PSKDTree() { kdTree = new PointSe<>(); }
--[ 2019.11.25.18.12.37.648.0 ]--
r 22     public PSKDTree() { kdTree = new PointSea<>(); }
--[ 2019.11.25.18.12.37.762.0 ]--
r 22     public PSKDTree() { kdTree = new PointSear<>(); }
--[ 2019.11.25.18.12.37.924.0 ]--
r 22     public PSKDTree() { kdTree = new PointSearc<>(); }
--[ 2019.11.25.18.12.38.016.0 ]--
r 22     public PSKDTree() { kdTree = new PointSearch<>(); }
--[ 2019.11.25.18.12.43.309.0 ]--
r 22     public PSKDTree() { kdTree = new P<>(); }
--[ 2019.11.25.18.12.43.647.0 ]--
r 22     public PSKDTree() { kdTree = new Pio<>(); }
--[ 2019.11.25.18.12.44.006.0 ]--
r 22     public PSKDTree() { kdTree = new Pi<>(); }
--[ 2019.11.25.18.12.44.275.0 ]--
r 22     public PSKDTree() { kdTree = new Pioin<>(); }
--[ 2019.11.25.18.12.44.603.0 ]--
r 22     public PSKDTree() { kdTree = new Pi<>(); }
--[ 2019.11.25.18.12.44.922.0 ]--
r 22     public PSKDTree() { kdTree = new Pint<>(); }
--[ 2019.11.25.18.12.45.303.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.13.05.915.0 ]--
r 8     P<Value> kdTree;
--[ 2019.11.25.18.13.06.015.0 ]--
r 8     PS<Value> kdTree;
--[ 2019.11.25.18.13.06.248.0 ]--
r 8     PSKD<Value> kdTree;
--[ 2019.11.25.18.13.06.561.0 ]--
r 8     PSKDT<Value> kdTree;
--[ 2019.11.25.18.13.06.809.0 ]--
r 8     PSKDTr<Value> kdTree;
--[ 2019.11.25.18.13.06.940.0 ]--
r 8     PSKDTre<Value> kdTree;
--[ 2019.11.25.18.13.07.239.0 ]--
r 8     PSKDTree<Value> kdTree;
--[ 2019.11.25.18.13.13.363.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.18.13.14.304.0 ]--
UpdateTree (AD): 3 0
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.18.18.04.216.0 ]--
r 8     P<Value> kdTree;
--[ 2019.11.25.18.18.04.348.0 ]--
r 8     Po<Value> kdTree;
--[ 2019.11.25.18.18.04.498.0 ]--
r 8     Poi<Value> kdTree;
--[ 2019.11.25.18.18.04.560.0 ]--
r 8     Poin<Value> kdTree;
--[ 2019.11.25.18.18.05.252.0 ]--
r 8     Point<Value> kdTree;
--[ 2019.11.25.18.18.05.358.0 ]--
r 8     PointS<Value> kdTree;
--[ 2019.11.25.18.18.05.507.0 ]--
r 8     PointSe<Value> kdTree;
--[ 2019.11.25.18.18.05.578.0 ]--
r 8     PointSea<Value> kdTree;
--[ 2019.11.25.18.18.05.649.0 ]--
r 8     PointSear<Value> kdTree;
--[ 2019.11.25.18.18.05.801.0 ]--
r 8     PointSearc<Value> kdTree;
--[ 2019.11.25.18.18.05.891.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.18.06.092.0 ]--
r 8     PointSearch <Value> kdTree;
--[ 2019.11.25.18.18.06.135.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.18.43.319.0 ]--
+ 137     public Iterable<Point> points() { return 
r 138     null; }
--[ 2019.11.25.18.18.43.328.0 ]--
r 138             null; }
--[ 2019.11.25.18.18.43.864.0 ]--
- 137
r 137     public Iterable<Point> points() { return null; }
--[ 2019.11.25.18.18.49.432.0 ]--
+ 137     public Iterable<Point> points() { 
r 138         return null; }
--[ 2019.11.25.18.18.50.519.0 ]--
+ 138         
--[ 2019.11.25.18.18.51.899.0 ]--
+ 139         return null; 
r 140     }
--[ 2019.11.25.18.18.52.977.0 ]--
r 138             
--[ 2019.11.25.18.18.55.578.0 ]--
+ 138         
r 139         
--[ 2019.11.25.18.18.56.217.0 ]--
r 139         Q
--[ 2019.11.25.18.18.56.711.0 ]--
r 139         Qu
--[ 2019.11.25.18.18.56.815.0 ]--
r 139         Que
--[ 2019.11.25.18.18.56.881.0 ]--
r 139         Queu
--[ 2019.11.25.18.18.56.956.0 ]--
r 139         Queue
--[ 2019.11.25.18.18.57.198.0 ]--
r 139         QueueM
--[ 2019.11.25.18.18.57.464.0 ]--
r 139         QueueMP
--[ 2019.11.25.18.18.57.702.0 ]--
r 139         QueueMPo
--[ 2019.11.25.18.18.57.981.0 ]--
r 139         QueueMP
--[ 2019.11.25.18.18.58.091.0 ]--
r 139         QueueM
--[ 2019.11.25.18.18.59.107.0 ]--
r 139         Queue
--[ 2019.11.25.18.18.59.254.0 ]--
r 139         Queue<>
--[ 2019.11.25.18.18.59.365.0 ]--
r 139         Queue<P>
--[ 2019.11.25.18.18.59.668.0 ]--
r 139         Queue<Po>
--[ 2019.11.25.18.18.59.776.0 ]--
r 139         Queue<Poi>
--[ 2019.11.25.18.18.59.830.0 ]--
r 139         Queue<Poin>
--[ 2019.11.25.18.18.59.932.0 ]--
r 139         Queue<Point>
--[ 2019.11.25.18.19.00.392.0 ]--
r 139         Queue<Point> 
--[ 2019.11.25.18.19.00.555.0 ]--
r 139         Queue<Point> q
--[ 2019.11.25.18.19.00.678.0 ]--
r 139         Queue<Point> q 
--[ 2019.11.25.18.19.01.501.0 ]--
r 139         Queue<Point> q =
--[ 2019.11.25.18.19.01.558.0 ]--
r 139         Queue<Point> q = 
--[ 2019.11.25.18.19.01.657.0 ]--
r 139         Queue<Point> q = n
--[ 2019.11.25.18.19.01.845.0 ]--
r 139         Queue<Point> q = nw
--[ 2019.11.25.18.19.02.088.0 ]--
r 139         Queue<Point> q = n
--[ 2019.11.25.18.19.02.196.0 ]--
r 139         Queue<Point> q = ne
--[ 2019.11.25.18.19.02.542.0 ]--
r 139         Queue<Point> q = new
--[ 2019.11.25.18.19.02.644.0 ]--
r 139         Queue<Point> q = new 
--[ 2019.11.25.18.19.02.761.0 ]--
r 139         Queue<Point> q = new Q
--[ 2019.11.25.18.19.02.861.0 ]--
r 139         Queue<Point> q = new Qu
--[ 2019.11.25.18.19.02.972.0 ]--
r 139         Queue<Point> q = new Que
--[ 2019.11.25.18.19.03.059.0 ]--
r 139         Queue<Point> q = new Queu
--[ 2019.11.25.18.19.03.108.0 ]--
r 139         Queue<Point> q = new Queue
--[ 2019.11.25.18.19.03.540.0 ]--
r 139         Queue<Point> q = new Queue<>
--[ 2019.11.25.18.19.03.776.0 ]--
r 139         Queue<Point> q = new Queue<P>
--[ 2019.11.25.18.19.03.986.0 ]--
r 139         Queue<Point> q = new Queue<Po>
--[ 2019.11.25.18.19.04.134.0 ]--
r 139         Queue<Point> q = new Queue<Poi>
--[ 2019.11.25.18.19.04.207.0 ]--
r 139         Queue<Point> q = new Queue<Poin>
--[ 2019.11.25.18.19.04.315.0 ]--
r 139         Queue<Point> q = new Queue<Point>
--[ 2019.11.25.18.19.05.416.0 ]--
r 139         Queue<Point> q = new Queue<Point)>
--[ 2019.11.25.18.19.05.846.0 ]--
r 139         Queue<Point> q = new Queue<Point>
--[ 2019.11.25.18.19.07.295.0 ]--
r 139         Queue<Point> q = new Queue<Point>()
--[ 2019.11.25.18.19.07.531.0 ]--
r 139         Queue<Point> q = new Queue<Point>();
--[ 2019.11.25.18.19.07.873.0 ]--
+ 140         
--[ 2019.11.25.18.19.10.263.0 ]--
r 140         i
--[ 2019.11.25.18.19.10.438.0 ]--
r 140         in
--[ 2019.11.25.18.19.10.649.0 ]--
r 140         ino
--[ 2019.11.25.18.19.10.799.0 ]--
r 140         inor
--[ 2019.11.25.18.19.11.041.0 ]--
r 140         inord
--[ 2019.11.25.18.19.12.529.0 ]--
r 140         inordr
--[ 2019.11.25.18.19.12.954.0 ]--
r 140         inord
--[ 2019.11.25.18.19.13.020.0 ]--
r 140         inorde
--[ 2019.11.25.18.19.13.083.0 ]--
r 140         inorder
--[ 2019.11.25.18.19.15.664.0 ]--
r 140         inorder()
--[ 2019.11.25.18.19.16.797.0 ]--
r 140         inorder(r)
--[ 2019.11.25.18.19.16.850.0 ]--
r 140         inorder(ro)
--[ 2019.11.25.18.19.16.952.0 ]--
r 140         inorder(roo)
--[ 2019.11.25.18.19.17.043.0 ]--
r 140         inorder(root)
--[ 2019.11.25.18.19.17.155.0 ]--
r 140         inorder(root,)
--[ 2019.11.25.18.19.17.520.0 ]--
r 140         inorder(root,q)
--[ 2019.11.25.18.19.18.084.0 ]--
r 140         inorder(root,q):
--[ 2019.11.25.18.19.18.436.0 ]--
+ 141         
--[ 2019.11.25.18.19.18.870.0 ]--
r 141         r
--[ 2019.11.25.18.19.18.925.0 ]--
r 141         re
--[ 2019.11.25.18.19.19.052.0 ]--
r 141         ret
--[ 2019.11.25.18.19.19.109.0 ]--
r 141         retu
--[ 2019.11.25.18.19.19.207.0 ]--
r 141         retur
--[ 2019.11.25.18.19.19.274.0 ]--
r 141         return
--[ 2019.11.25.18.19.19.452.0 ]--
r 141         return 
--[ 2019.11.25.18.19.19.577.0 ]--
r 141         return q
--[ 2019.11.25.18.19.22.996.0 ]--
r 140         inorder(root,q)
--[ 2019.11.25.18.19.23.169.0 ]--
r 140         inorder(root,q)l
--[ 2019.11.25.18.19.24.209.0 ]--
r 140         inorder(root,q)
--[ 2019.11.25.18.19.24.419.0 ]--
r 140         inorder(root,q);
--[ 2019.11.25.18.19.29.068.0 ]--
+ 144     
--[ 2019.11.25.18.19.29.330.0 ]--
+ 144     
--[ 2019.11.25.18.19.31.479.0 ]--
r 145     p
--[ 2019.11.25.18.19.31.636.0 ]--
r 145     pi
--[ 2019.11.25.18.19.31.840.0 ]--
r 145     p
--[ 2019.11.25.18.19.31.928.0 ]--
r 145     pr
--[ 2019.11.25.18.19.32.002.0 ]--
r 145     pri
--[ 2019.11.25.18.19.32.093.0 ]--
r 145     priv
--[ 2019.11.25.18.19.32.202.0 ]--
r 145     priva
--[ 2019.11.25.18.19.32.321.0 ]--
r 145     privat
--[ 2019.11.25.18.19.32.390.0 ]--
r 145     private
--[ 2019.11.25.18.19.32.573.0 ]--
r 145     private 
--[ 2019.11.25.18.19.32.718.0 ]--
r 145     private v
--[ 2019.11.25.18.19.32.799.0 ]--
r 145     private vo
--[ 2019.11.25.18.19.32.954.0 ]--
r 145     private voi
--[ 2019.11.25.18.19.33.055.0 ]--
r 145     private void
--[ 2019.11.25.18.19.33.143.0 ]--
r 145     private void 
--[ 2019.11.25.18.19.33.660.0 ]--
r 145     private void i
--[ 2019.11.25.18.19.33.680.0 ]--
r 145     private void in
--[ 2019.11.25.18.19.33.887.0 ]--
r 145     private void inp
--[ 2019.11.25.18.19.34.043.0 ]--
r 145     private void inpor
--[ 2019.11.25.18.19.34.403.0 ]--
r 145     private void inpo
--[ 2019.11.25.18.19.34.529.0 ]--
r 145     private void inp
--[ 2019.11.25.18.19.34.672.0 ]--
r 145     private void in
--[ 2019.11.25.18.19.35.103.0 ]--
r 145     private void ino
--[ 2019.11.25.18.19.35.240.0 ]--
r 145     private void inor
--[ 2019.11.25.18.19.35.399.0 ]--
r 145     private void inord
--[ 2019.11.25.18.19.35.493.0 ]--
r 145     private void inorde
--[ 2019.11.25.18.19.35.575.0 ]--
r 145     private void inorder
--[ 2019.11.25.18.19.37.206.0 ]--
r 145     private void inorder()
--[ 2019.11.25.18.19.37.483.0 ]--
r 145     private void inorder(N)
--[ 2019.11.25.18.19.37.606.0 ]--
r 145     private void inorder(No)
--[ 2019.11.25.18.19.37.689.0 ]--
r 145     private void inorder(Nod)
--[ 2019.11.25.18.19.37.739.0 ]--
r 145     private void inorder(Node)
--[ 2019.11.25.18.19.37.812.0 ]--
r 145     private void inorder(Node )
--[ 2019.11.25.18.19.37.870.0 ]--
r 145     private void inorder(Node n)
--[ 2019.11.25.18.19.37.917.0 ]--
r 145     private void inorder(Node no)
--[ 2019.11.25.18.19.37.981.0 ]--
r 145     private void inorder(Node nod)
--[ 2019.11.25.18.19.38.117.0 ]--
r 145     private void inorder(Node node)
--[ 2019.11.25.18.19.38.155.0 ]--
r 145     private void inorder(Node node,)
--[ 2019.11.25.18.19.38.320.0 ]--
r 145     private void inorder(Node node, )
--[ 2019.11.25.18.19.38.547.0 ]--
r 145     private void inorder(Node node, Q)
--[ 2019.11.25.18.19.38.657.0 ]--
r 145     private void inorder(Node node, Qu)
--[ 2019.11.25.18.19.38.827.0 ]--
r 145     private void inorder(Node node, Quu)
--[ 2019.11.25.18.19.39.117.0 ]--
r 145     private void inorder(Node node, Qu)
--[ 2019.11.25.18.19.39.184.0 ]--
r 145     private void inorder(Node node, Que)
--[ 2019.11.25.18.19.39.280.0 ]--
r 145     private void inorder(Node node, Queu)
--[ 2019.11.25.18.19.39.310.0 ]--
r 145     private void inorder(Node node, Queue)
--[ 2019.11.25.18.19.39.478.0 ]--
r 145     private void inorder(Node node, Queue<>)
--[ 2019.11.25.18.19.39.697.0 ]--
r 145     private void inorder(Node node, Queue<P>)
--[ 2019.11.25.18.19.39.918.0 ]--
r 145     private void inorder(Node node, Queue<Po>)
--[ 2019.11.25.18.19.40.048.0 ]--
r 145     private void inorder(Node node, Queue<Poi>)
--[ 2019.11.25.18.19.40.137.0 ]--
r 145     private void inorder(Node node, Queue<Poin>)
--[ 2019.11.25.18.19.40.212.0 ]--
r 145     private void inorder(Node node, Queue<Point>)
--[ 2019.11.25.18.19.40.327.0 ]--
r 145     private void inorder(Node node, Queue<Point0>)
--[ 2019.11.25.18.19.40.940.0 ]--
r 145     private void inorder(Node node, Queue<Point>)
--[ 2019.11.25.18.19.41.928.0 ]--
r 145     private void inorder(Node node, Queue<Point> )
--[ 2019.11.25.18.19.41.965.0 ]--
r 145     private void inorder(Node node, Queue<Point> q)
--[ 2019.11.25.18.19.43.042.0 ]--
r 145     private void inorder(Node node, Queue<Point> q){}
--[ 2019.11.25.18.19.43.979.0 ]--
+ 145     private void inorder(Node node, Queue<Point> q){
r 146     }
--[ 2019.11.25.18.19.44.046.0 ]--
+ 146         
--[ 2019.11.25.18.19.45.402.0 ]--
r 146         i
--[ 2019.11.25.18.19.45.516.0 ]--
r 146         if
--[ 2019.11.25.18.19.45.611.0 ]--
r 146         if 
--[ 2019.11.25.18.19.45.948.0 ]--
r 146         if
--[ 2019.11.25.18.19.46.200.0 ]--
r 146         if()
--[ 2019.11.25.18.19.46.366.0 ]--
r 146         if(n)
--[ 2019.11.25.18.19.46.405.0 ]--
r 146         if(no)
--[ 2019.11.25.18.19.46.449.0 ]--
r 146         if(nod)
--[ 2019.11.25.18.19.46.515.0 ]--
r 146         if(node)
--[ 2019.11.25.18.19.46.574.0 ]--
r 146         if(node )
--[ 2019.11.25.18.19.46.638.0 ]--
r 146         if(node =)
--[ 2019.11.25.18.19.46.759.0 ]--
r 146         if(node ==)
--[ 2019.11.25.18.19.46.827.0 ]--
r 146         if(node == )
--[ 2019.11.25.18.19.46.902.0 ]--
r 146         if(node == n)
--[ 2019.11.25.18.19.47.016.0 ]--
r 146         if(node == nu)
--[ 2019.11.25.18.19.47.154.0 ]--
r 146         if(node == nul)
--[ 2019.11.25.18.19.47.438.0 ]--
r 146         if(node == null)
--[ 2019.11.25.18.19.47.931.0 ]--
r 146         if(node == null) 
--[ 2019.11.25.18.19.48.010.0 ]--
r 146         if(node == null) r
--[ 2019.11.25.18.19.48.059.0 ]--
r 146         if(node == null) re
--[ 2019.11.25.18.19.48.169.0 ]--
r 146         if(node == null) ret
--[ 2019.11.25.18.19.48.283.0 ]--
r 146         if(node == null) retu
--[ 2019.11.25.18.19.48.349.0 ]--
r 146         if(node == null) retur
--[ 2019.11.25.18.19.48.393.0 ]--
r 146         if(node == null) return
--[ 2019.11.25.18.19.48.573.0 ]--
r 146         if(node == null) return;
--[ 2019.11.25.18.19.48.789.0 ]--
+ 147         
--[ 2019.11.25.18.19.49.443.0 ]--
r 147         i
--[ 2019.11.25.18.19.49.508.0 ]--
r 147         in
--[ 2019.11.25.18.19.49.624.0 ]--
r 147         ino
--[ 2019.11.25.18.19.49.714.0 ]--
r 147         inor
--[ 2019.11.25.18.19.49.863.0 ]--
r 147         inord
--[ 2019.11.25.18.19.49.942.0 ]--
r 147         inorde
--[ 2019.11.25.18.19.50.068.0 ]--
r 147         inorder
--[ 2019.11.25.18.19.50.563.0 ]--
r 147         inorder()
--[ 2019.11.25.18.19.50.730.0 ]--
r 147         inorder(n)
--[ 2019.11.25.18.19.50.761.0 ]--
r 147         inorder(no)
--[ 2019.11.25.18.19.50.828.0 ]--
r 147         inorder(nod)
--[ 2019.11.25.18.19.50.866.0 ]--
r 147         inorder(node)
--[ 2019.11.25.18.19.50.970.0 ]--
r 147         inorder(node.)
--[ 2019.11.25.18.19.51.123.0 ]--
r 147         inorder(node.l)
--[ 2019.11.25.18.19.51.206.0 ]--
r 147         inorder(node.le)
--[ 2019.11.25.18.19.51.257.0 ]--
r 147         inorder(node.lef)
--[ 2019.11.25.18.19.51.418.0 ]--
r 147         inorder(node.left)
--[ 2019.11.25.18.19.51.567.0 ]--
r 147         inorder(node.left,)
--[ 2019.11.25.18.19.51.669.0 ]--
r 147         inorder(node.left, )
--[ 2019.11.25.18.19.51.840.0 ]--
r 147         inorder(node.left, q)
--[ 2019.11.25.18.19.52.336.0 ]--
r 147         inorder(node.left, q);
--[ 2019.11.25.18.19.52.516.0 ]--
+ 148         
--[ 2019.11.25.18.19.52.918.0 ]--
r 148         q
--[ 2019.11.25.18.19.53.022.0 ]--
r 148         q.
--[ 2019.11.25.18.19.53.193.0 ]--
r 148         q.e
--[ 2019.11.25.18.19.53.334.0 ]--
r 148         q.en
--[ 2019.11.25.18.19.53.485.0 ]--
r 148         q.enq
--[ 2019.11.25.18.19.53.604.0 ]--
r 148         q.enqu
--[ 2019.11.25.18.19.53.690.0 ]--
r 148         q.enque
--[ 2019.11.25.18.19.53.819.0 ]--
r 148         q.enqueu
--[ 2019.11.25.18.19.53.851.0 ]--
r 148         q.enqueue
--[ 2019.11.25.18.19.54.175.0 ]--
r 148         q.enqueue()
--[ 2019.11.25.18.19.54.331.0 ]--
r 148         q.enqueue(n)
--[ 2019.11.25.18.19.54.390.0 ]--
r 148         q.enqueue(no)
--[ 2019.11.25.18.19.54.476.0 ]--
r 148         q.enqueue(nod)
--[ 2019.11.25.18.19.54.512.0 ]--
r 148         q.enqueue(node)
--[ 2019.11.25.18.19.54.623.0 ]--
r 148         q.enqueue(node.)
--[ 2019.11.25.18.19.54.796.0 ]--
r 148         q.enqueue(node.p)
--[ 2019.11.25.18.19.55.223.0 ]--
r 148         q.enqueue(node.p);
--[ 2019.11.25.18.19.55.384.0 ]--
+ 149         
--[ 2019.11.25.18.19.55.563.0 ]--
r 149         i
--[ 2019.11.25.18.19.55.650.0 ]--
r 149         in
--[ 2019.11.25.18.19.55.776.0 ]--
r 149         ino
--[ 2019.11.25.18.19.55.862.0 ]--
r 149         inor
--[ 2019.11.25.18.19.55.990.0 ]--
r 149         inord
--[ 2019.11.25.18.19.56.055.0 ]--
r 149         inorde
--[ 2019.11.25.18.19.56.162.0 ]--
r 149         inorder
--[ 2019.11.25.18.19.56.530.0 ]--
r 149         inorder()
--[ 2019.11.25.18.19.56.924.0 ]--
r 149         inorder(n)
--[ 2019.11.25.18.19.57.015.0 ]--
r 149         inorder(no)
--[ 2019.11.25.18.19.57.104.0 ]--
r 149         inorder(nod)
--[ 2019.11.25.18.19.57.137.0 ]--
r 149         inorder(node)
--[ 2019.11.25.18.19.57.237.0 ]--
r 149         inorder(node.)
--[ 2019.11.25.18.19.57.368.0 ]--
r 149         inorder(node.r)
--[ 2019.11.25.18.19.57.462.0 ]--
r 149         inorder(node.ri)
--[ 2019.11.25.18.19.57.524.0 ]--
r 149         inorder(node.rig)
--[ 2019.11.25.18.19.57.582.0 ]--
r 149         inorder(node.righ)
--[ 2019.11.25.18.19.57.656.0 ]--
r 149         inorder(node.right)
--[ 2019.11.25.18.19.58.049.0 ]--
r 149         inorder(node.right,)
--[ 2019.11.25.18.19.58.173.0 ]--
r 149         inorder(node.right,q)
--[ 2019.11.25.18.19.58.701.0 ]--
r 149         inorder(node.right,q);
--[ 2019.11.25.18.19.59.366.0 ]--
r 149         inorder(node.right,q)
--[ 2019.11.25.18.20.00.415.0 ]--
r 149         inorder(node.right,q) 
--[ 2019.11.25.18.20.00.448.0 ]--
r 149         inorder(node.right,q)
--[ 2019.11.25.18.20.00.783.0 ]--
r 149         inorder(node.right,q)p
--[ 2019.11.25.18.20.01.200.0 ]--
r 149         inorder(node.right,q)
--[ 2019.11.25.18.20.01.279.0 ]--
r 149         inorder(node.right,q);
--[ 2019.11.25.18.20.04.884.0 ]--
r 141         return q;
--[ 2019.11.25.18.20.07.620.0 ]--
r 142         
--[ 2019.11.25.18.20.08.008.0 ]--
- 142
--[ 2019.11.25.18.20.14.349.0 ]--
r 137     public Iterable<Point> points() {
r 138 
r 143 
--[ 2019.11.25.18.20.17.349.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.18.26.04.829.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTre0e<>(); }
--[ 2019.11.25.18.26.05.800.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.26.07.627.0 ]--
r 22     public PSKDTree() { kdTree = new P<>(); }
--[ 2019.11.25.18.26.07.751.0 ]--
r 22     public PSKDTree() { kdTree = new Po<>(); }
--[ 2019.11.25.18.26.07.919.0 ]--
r 22     public PSKDTree() { kdTree = new Poi<>(); }
--[ 2019.11.25.18.26.07.955.0 ]--
r 22     public PSKDTree() { kdTree = new Poin<>(); }
--[ 2019.11.25.18.26.08.048.0 ]--
r 22     public PSKDTree() { kdTree = new Point<>(); }
--[ 2019.11.25.18.26.08.200.0 ]--
r 22     public PSKDTree() { kdTree = new PointS<>(); }
--[ 2019.11.25.18.26.08.364.0 ]--
r 22     public PSKDTree() { kdTree = new PointSe<>(); }
--[ 2019.11.25.18.26.08.421.0 ]--
r 22     public PSKDTree() { kdTree = new PointSea<>(); }
--[ 2019.11.25.18.26.08.480.0 ]--
r 22     public PSKDTree() { kdTree = new PointSear<>(); }
--[ 2019.11.25.18.26.08.655.0 ]--
r 22     public PSKDTree() { kdTree = new PointSearc<>(); }
--[ 2019.11.25.18.26.08.759.0 ]--
r 22     public PSKDTree() { kdTree = new PointSearch<>(); }
--[ 2019.11.25.18.26.08.919.0 ]--
r 22     public PSKDTree() { kdTree = new PointSearch <>(); }
--[ 2019.11.25.18.26.08.995.0 ]--
r 22     public PSKDTree() { kdTree = new PointSearch<>(); }
--[ 2019.11.25.18.26.13.469.0 ]--
r 22     public PSKDTree() { kdTree = new B<>(); }
--[ 2019.11.25.18.26.13.639.0 ]--
r 22     public PSKDTree() { kdTree = new BS<>(); }
--[ 2019.11.25.18.26.13.816.0 ]--
r 22     public PSKDTree() { kdTree = new BST<>(); }
--[ 2019.11.25.18.26.18.717.0 ]--
r 22     public PSKDTree() { kdTree = new R<>(); }
--[ 2019.11.25.18.26.18.893.0 ]--
r 22     public PSKDTree() { kdTree = new Re<>(); }
--[ 2019.11.25.18.26.19.054.0 ]--
r 22     public PSKDTree() { kdTree = new Red<>(); }
--[ 2019.11.25.18.26.19.654.0 ]--
r 22     public PSKDTree() { kdTree = new Redirect<>(); }
--[ 2019.11.25.18.26.19.668.0 ]--
r 22     public PSKDTree() { kdTree = new java.lang.ProcessBuilder.Redirect<>(); }
--[ 2019.11.25.18.26.19.681.0 ]--
r 22     public PSKDTree() { kdTree = new ProcessBuilder.Redirect<>(); }
--[ 2019.11.25.18.26.20.353.0 ]--
r 22     public PSKDTree() { kdTree = new ProcessBuilder.<>(); }
--[ 2019.11.25.18.26.20.646.0 ]--
r 22     public PSKDTree() { kdTree = new ProcessBuilder<>(); }
--[ 2019.11.25.18.26.21.032.0 ]--
r 22     public PSKDTree() { kdTree = new <>(); }
--[ 2019.11.25.18.26.21.397.0 ]--
r 22     public PSKDTree() { kdTree = new R<>(); }
--[ 2019.11.25.18.26.21.513.0 ]--
r 22     public PSKDTree() { kdTree = new Re<>(); }
--[ 2019.11.25.18.26.21.705.0 ]--
r 22     public PSKDTree() { kdTree = new Red<>(); }
--[ 2019.11.25.18.26.21.957.0 ]--
r 22     public PSKDTree() { kdTree = new RedB<>(); }
--[ 2019.11.25.18.26.22.522.0 ]--
r 22     public PSKDTree() { kdTree = new RedBlackBST<>(); }
--[ 2019.11.25.18.26.29.430.0 ]--
r 8     B<Value> kdTree;
--[ 2019.11.25.18.26.29.537.0 ]--
r 8     BS<Value> kdTree;
--[ 2019.11.25.18.26.29.792.0 ]--
r 8     BST<Value> kdTree;
--[ 2019.11.25.18.26.35.263.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.26.41.960.0 ]--
r 22     public PSKDTree() { kdTree = new P<>(); }
--[ 2019.11.25.18.26.42.029.0 ]--
r 22     public PSKDTree() { kdTree = new PS<>(); }
--[ 2019.11.25.18.26.42.093.0 ]--
r 22     public PSKDTree() { kdTree = new PSK<>(); }
--[ 2019.11.25.18.26.42.252.0 ]--
r 22     public PSKDTree() { kdTree = new PSKD<>(); }
--[ 2019.11.25.18.26.42.457.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDT<>(); }
--[ 2019.11.25.18.26.42.652.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTr<>(); }
--[ 2019.11.25.18.26.42.769.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTre<>(); }
--[ 2019.11.25.18.26.42.876.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.26.43.675.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree <>(); }
--[ 2019.11.25.18.26.43.726.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.28.15.210.0 ]--
r 8     P<Value> kdTree;
--[ 2019.11.25.18.28.15.319.0 ]--
r 8     PS<Value> kdTree;
--[ 2019.11.25.18.28.15.409.0 ]--
r 8     PSK<Value> kdTree;
--[ 2019.11.25.18.28.15.562.0 ]--
r 8     PSKD<Value> kdTree;
--[ 2019.11.25.18.28.16.380.0 ]--
r 8     PSKDTree<Value> kdTree;
--[ 2019.11.25.18.28.24.655.0 ]--
r 8     P<Value> kdTree;
--[ 2019.11.25.18.28.25.023.0 ]--
r 8     Po<Value> kdTree;
--[ 2019.11.25.18.28.25.146.0 ]--
r 8     Poi<Value> kdTree;
--[ 2019.11.25.18.28.25.182.0 ]--
r 8     Poin<Value> kdTree;
--[ 2019.11.25.18.28.25.257.0 ]--
r 8     Point<Value> kdTree;
--[ 2019.11.25.18.28.25.406.0 ]--
r 8     PointS<Value> kdTree;
--[ 2019.11.25.18.28.25.586.0 ]--
r 8     PointSe<Value> kdTree;
--[ 2019.11.25.18.28.25.658.0 ]--
r 8     PointSea<Value> kdTree;
--[ 2019.11.25.18.28.25.699.0 ]--
r 8     PointSear<Value> kdTree;
--[ 2019.11.25.18.28.25.864.0 ]--
r 8     PointSearc<Value> kdTree;
--[ 2019.11.25.18.28.25.965.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.28.26.069.0 ]--
r 8     PointSearch <Value> kdTree;
--[ 2019.11.25.18.28.26.177.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.30.08.375.0 ]--
r 22     public PSKDTree() { PkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.08.497.0 ]--
r 22     public PSKDTree() { PSkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.08.520.0 ]--
r 22     public PSKDTree() { PSKkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.08.640.0 ]--
r 22     public PSKDTree() { PSKDkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.08.865.0 ]--
r 22     public PSKDTree() { PSKDTkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.09.013.0 ]--
r 22     public PSKDTree() { PSKDTrkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.09.189.0 ]--
r 22     public PSKDTree() { PSKDTrekdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.09.330.0 ]--
r 22     public PSKDTree() { PSKDTreekdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.10.029.0 ]--
r 22     public PSKDTree() { PSKDTree>kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.10.155.0 ]--
r 22     public PSKDTree() { PSKDTree>VkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.10.272.0 ]--
r 22     public PSKDTree() { PSKDTree>VakdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.10.362.0 ]--
r 22     public PSKDTree() { PSKDTree>ValkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.10.519.0 ]--
r 22     public PSKDTree() { PSKDTree>ValukdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.10.624.0 ]--
r 22     public PSKDTree() { PSKDTree>ValuekdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.11.275.0 ]--
r 22     public PSKDTree() { PSKDTree>ValukdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.11.369.0 ]--
r 22     public PSKDTree() { PSKDTree>ValkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.11.480.0 ]--
r 22     public PSKDTree() { PSKDTree>VakdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.11.590.0 ]--
r 22     public PSKDTree() { PSKDTree>VkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.11.698.0 ]--
r 22     public PSKDTree() { PSKDTree>kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.12.309.0 ]--
r 22     public PSKDTree() { PSKDTreekdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.12.476.0 ]--
r 22     public PSKDTree() { PSKDTree<kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.12.557.0 ]--
r 22     public PSKDTree() { PSKDTree<vkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.12.744.0 ]--
r 22     public PSKDTree() { PSKDTree<vakdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.12.973.0 ]--
r 22     public PSKDTree() { PSKDTree<vkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.093.0 ]--
r 22     public PSKDTree() { PSKDTree<kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.182.0 ]--
r 22     public PSKDTree() { PSKDTree<VkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.318.0 ]--
r 22     public PSKDTree() { PSKDTree<VakdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.389.0 ]--
r 22     public PSKDTree() { PSKDTree<ValkdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.543.0 ]--
r 22     public PSKDTree() { PSKDTree<ValukdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.635.0 ]--
r 22     public PSKDTree() { PSKDTree<ValuekdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.13.854.0 ]--
r 22     public PSKDTree() { PSKDTree<Value>kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.14.248.0 ]--
r 22     public PSKDTree() { PSKDTree<Value> kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.18.085.0 ]--
r 8     /PointSearch<Value> kdTree;
--[ 2019.11.25.18.30.18.133.0 ]--
r 8     //PointSearch<Value> kdTree;
--[ 2019.11.25.18.30.21.441.0 ]--
r 8     /PointSearch<Value> kdTree;
--[ 2019.11.25.18.30.21.524.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.18.30.28.921.0 ]--
r 22     public PSKDTree() { \kdTree = new PSKDTree<>(); }
--[ 2019.11.25.18.30.29.988.0 ]--
r 22     public PSKDTree() { kdTree = new PSKDTree<>(); }
--[ 2019.11.25.19.52.33.692.0 ]--
r 22     public PSKDTree() {  }
--[ 2019.11.25.19.52.34.870.0 ]--
r 22     public PSKDTree() { }
--[ 2019.11.25.19.52.39.620.0 ]--
r 8 
--[ 2019.11.25.19.52.39.984.0 ]--
- 8
--[ 2019.11.25.19.52.43.755.0 ]--
UpdateTree (AD): 0 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class

--[ 2019.11.25.19.52.43.755.1 ]--
CompilationStatus (AEW): 0 2 0
[Ljava.lang.String;@2485f0c
--[ 2019.11.25.19.52.57.661.0 ]--
r 15     double xMax; 
--[ 2019.11.25.19.52.57.662.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.57.664.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.57.790.0 ]--
r 15     double xMax;
--[ 2019.11.25.19.52.57.790.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.57.792.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.58.195.0 ]--
r 15     double xMax; 
--[ 2019.11.25.19.52.58.195.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.58.197.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.58.552.0 ]--
r 15     double xMax;
--[ 2019.11.25.19.52.58.554.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.58.559.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.59.402.0 ]--
+ 8 
--[ 2019.11.25.19.52.59.403.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.59.415.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.59.812.0 ]--
r 8     PointSearch<Value> kdTree;
--[ 2019.11.25.19.52.59.812.1 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.59.814.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.59.817.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.52.59.820.0 ]--
UpdateTree (AD): 3 3
- /out/production/P05_KDTrees/PSKDTree$Node.class
- /out/production/P05_KDTrees/PSKDTree$1.class
- /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.53.08.170.0 ]--
UpdateTree (AD): 3 0
+ /out/production/P05_KDTrees/PSKDTree.class
+ /out/production/P05_KDTrees/PSKDTree$1.class
+ /out/production/P05_KDTrees/PSKDTree$Node.class

--[ 2019.11.25.19.53.08.170.1 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.19.53.29.154.0 ]--
r 26         if ( t == 0 ) {
--[ 2019.11.25.19.53.29.289.0 ]--
r 26         if ( tr == 0 ) {
--[ 2019.11.25.19.53.29.420.0 ]--
r 26         if ( tre == 0 ) {
--[ 2019.11.25.19.53.29.555.0 ]--
r 26         if ( tree == 0 ) {
--[ 2019.11.25.19.53.30.165.0 ]--
r 26         if ( treeS == 0 ) {
--[ 2019.11.25.19.53.30.237.0 ]--
r 26         if ( treeSI == 0 ) {
--[ 2019.11.25.19.53.30.317.0 ]--
r 26         if ( treeSIz == 0 ) {
--[ 2019.11.25.19.53.30.443.0 ]--
r 26         if ( treeSIze == 0 ) {
--[ 2019.11.25.19.53.30.705.0 ]--
r 26         if ( treeSIze  == 0 ) {
--[ 2019.11.25.19.53.30.767.0 ]--
r 26         if ( treeSIze == 0 ) {
--[ 2019.11.25.19.53.30.962.0 ]--
r 26         if ( treeSIz == 0 ) {
--[ 2019.11.25.19.53.31.061.0 ]--
r 26         if ( treeSI == 0 ) {
--[ 2019.11.25.19.53.31.154.0 ]--
r 26         if ( treeS == 0 ) {
--[ 2019.11.25.19.53.31.437.0 ]--
r 26         if ( treeSi == 0 ) {
--[ 2019.11.25.19.53.31.504.0 ]--
r 26         if ( treeSiz == 0 ) {
--[ 2019.11.25.19.53.31.634.0 ]--
r 26         if ( treeSize == 0 ) {
--[ 2019.11.25.19.53.39.132.0 ]--
r 36         if ( t == 1 ) {
--[ 2019.11.25.19.53.39.250.0 ]--
r 36         if ( tr == 1 ) {
--[ 2019.11.25.19.53.39.405.0 ]--
r 36         if ( tre == 1 ) {
--[ 2019.11.25.19.53.39.521.0 ]--
r 36         if ( tree == 1 ) {
--[ 2019.11.25.19.53.39.724.0 ]--
r 36         if ( treeS == 1 ) {
--[ 2019.11.25.19.53.39.891.0 ]--
r 36         if ( treeSi == 1 ) {
--[ 2019.11.25.19.53.39.907.0 ]--
r 36         if ( treeSiz == 1 ) {
--[ 2019.11.25.19.53.40.117.0 ]--
r 36         if ( treeSize == 1 ) {
--[ 2019.11.25.19.53.54.389.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.19.54.43.990.0 ]--
+ 158         
--[ 2019.11.25.19.54.44.369.0 ]--
+ 158         for(Point q : points()){
+ 159             min = q;
+ 160             break;
+ 161         }
+ 162         for(Point q : points()){
+ 163             if(q.dist(p) < min.dist(p)){
+ 164                 min = q;
+ 165             }
+ 166         }
r 167         return min;
--[ 2019.11.25.19.55.00.188.0 ]--
+ 8     
--[ 2019.11.25.19.55.00.374.0 ]--
r 8     p
--[ 2019.11.25.19.55.00.455.0 ]--
r 8     pr
--[ 2019.11.25.19.55.00.540.0 ]--
r 8     pri
--[ 2019.11.25.19.55.00.621.0 ]--
r 8     priv
--[ 2019.11.25.19.55.00.727.0 ]--
r 8     priva
--[ 2019.11.25.19.55.00.834.0 ]--
r 8     privat
--[ 2019.11.25.19.55.00.980.0 ]--
r 8     private
--[ 2019.11.25.19.55.01.083.0 ]--
r 8     private 
--[ 2019.11.25.19.55.01.357.0 ]--
r 8     private P
--[ 2019.11.25.19.55.01.456.0 ]--
r 8     private Po
--[ 2019.11.25.19.55.01.604.0 ]--
r 8     private Poi
--[ 2019.11.25.19.55.01.636.0 ]--
r 8     private Poin
--[ 2019.11.25.19.55.01.718.0 ]--
r 8     private Point
--[ 2019.11.25.19.55.01.822.0 ]--
r 8     private Point 
--[ 2019.11.25.19.55.01.884.0 ]--
r 8     private Point m
--[ 2019.11.25.19.55.01.958.0 ]--
r 8     private Point mi
--[ 2019.11.25.19.55.02.011.0 ]--
r 8     private Point min
--[ 2019.11.25.19.55.02.458.0 ]--
r 8     private Point min;
--[ 2019.11.25.19.55.09.781.0 ]--
r 169         
--[ 2019.11.25.19.55.10.000.0 ]--
- 169
--[ 2019.11.25.19.55.13.349.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.19.55.36.644.0 ]--
+ 173         
--[ 2019.11.25.19.55.36.820.0 ]--
+ 173         MaxPQ<PointDist> points = new MaxPQ<>();
+ 174         for(Point q : points()){
+ 175             points.insert(new PointDist(q, q.dist(p)));
+ 176             if(points.size() > k){
+ 177                 points.delMax();
+ 178             }
+ 179         }
+ 180 
+ 181         Stack<Point> s = new Stack<>();
+ 182 
+ 183         for (PointDist point: points) {
+ 184             s.push(point.p());
+ 185         }
+ 186 
+ 187 
+ 188 
r 189         return s;
--[ 2019.11.25.19.55.38.997.0 ]--
r 190         
--[ 2019.11.25.19.55.39.200.0 ]--
- 190
--[ 2019.11.25.19.55.42.673.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2019.11.25.19.58.54.488.0 ]--
:/src/PSBruteForce.java
r 77         return g;
--[ 2019.11.25.19.58.54.549.0 ]--
r 77         return ge;
--[ 2019.11.25.19.58.54.644.0 ]--
r 77         return get;
--[ 2019.11.25.19.58.54.818.0 ]--
r 77         return get();
--[ 2019.11.25.19.58.54.984.0 ]--
r 77         return get(n);
--[ 2019.11.25.19.58.55.110.0 ]--
r 77         return get(ne);
--[ 2019.11.25.19.58.55.169.0 ]--
r 77         return get(nea);
--[ 2019.11.25.19.58.55.256.0 ]--
r 77         return get(near);
--[ 2019.11.25.19.58.55.487.0 ]--
r 77         return get(neart);
--[ 2019.11.25.19.58.55.595.0 ]--
r 77         return get(nearte);
--[ 2019.11.25.19.58.55.664.0 ]--
r 77         return get(neartes);
--[ 2019.11.25.19.58.55.758.0 ]--
r 77         return get(neartest);
--[ 2019.11.25.19.58.55.950.0 ]--
r 77         return get(neartest());
--[ 2019.11.25.19.58.56.212.0 ]--
r 77         return get(neartest(p));
--[ 2019.11.25.19.58.56.544.0 ]--
r 77         return get(neartest(p ));
--[ 2019.11.25.19.58.56.713.0 ]--
r 77         return get(neartest());
--[ 2019.11.25.19.58.56.811.0 ]--
r 77         return get(neartest);
--[ 2019.11.25.19.58.57.543.0 ]--
r 77         return get();
--[ 2019.11.25.19.58.57.926.0 ]--
r 77         return get(n);
--[ 2019.11.25.19.58.57.991.0 ]--
r 77         return get(ne);
--[ 2019.11.25.19.58.58.037.0 ]--
r 77         return get(nea);
--[ 2019.11.25.19.58.58.127.0 ]--
r 77         return get(near);
--[ 2019.11.25.19.58.58.305.0 ]--
r 77         return get(neare);
--[ 2019.11.25.19.58.58.732.0 ]--
r 77         return get(neares);
--[ 2019.11.25.19.58.58.790.0 ]--
r 77         return get(nearest);
--[ 2019.11.25.19.58.59.153.0 ]--
r 77         return get(nearest());
--[ 2019.11.25.19.58.59.293.0 ]--
r 77         return get(nearest(p));
--[ 2019.11.25.19.59.00.941.0 ]--
r 77         return get(nearest(p)); 
--[ 2019.11.25.19.59.00.967.0 ]--
r 77         return get(nearest(p));
--[ 2019.11.25.20.19.11.454.0 ]--
:/src/PSKDTree.java
+ 209         
--[ 2019.11.25.20.21.01.785.0 ]--
r 209 
--[ 2019.11.25.20.37.09.047.0 ]--
DisposeComponent
--[ 2019.12.01.15.09.32.660.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2019.12.01.15.09.33.231.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/PSKDTree$1.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2019.12.01.15.09.33.231.1 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2019.12.01.15.09.33.232.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2019.12.01.15.09.33.232.1 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2019.12.01.15.09.33.232.2 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2019.12.01.15.09.33.232.3 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {
    private Point min;
    PointSearch<Value> kdTree;
    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }
    double xMin;
    double xMax;
    double yMin;
    double yMax;
    int treeSize = 0;
    Node root;
    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
        if ( treeSize == 0 ) {
            root = new Node();
            root.p = p;
            root.v = v;
            root.dir = Partition.Direction.LEFTRIGHT;
        }
        else {
            root = putX(root, p, v);
        }
        treeSize ++;
        if ( treeSize == 1 ) {
            xMin = p.x();
            xMax = p.x();
            yMin = p.y();
            yMax = p.y();
        }
        else {
            if ( p.x() <= xMin ) {
                xMin = p.x();
            }
            else if ( p.x() >= xMax ) {
                xMax = p.x();
            }
            if ( p.y() <= yMin ) {
                yMin = p.y();
            }
            else if ( p.y() >= yMax ) {
                yMax = p.y();
            }
        }
    }
    private Node putX( Node node, Point p, Value v) {
        if( node == null ) {
            Node alt = new Node();
            alt.p = p;
            alt.v = v;
            alt.dir = Partition.Direction.DOWNUP;
            return alt;
        }
        if ( p.x() < node.p.x() ) {
            node.left = putY( node.left,p,v );
        }
        else if ( p.x() > node.p.x() ) {
            node.right = putY( node.right,p,v );
        }
        else if ( p.x() == node.p.x() ) {
            if ( p.y() == node.p.y() ) node.v = v;
            else node.left = putY( node.left,p,v );
        }
        return node;
    }
    private Node putY( Node node, Point p, Value v) {
        if( node == null ) {
            Node alt = new Node();
            alt.p = p;
            alt.v = v;
            alt.dir = Partition.Direction.LEFTRIGHT;
            return alt;
        }
        if ( p.y() < node.p.y() ) {
            node.left = putX( node.left,p,v );
        }
        else if ( p.y() > node.p.y() ) {
            node.right = putX( node.right,p,v );
        }
        else if ( p.y() == node.p.y() ) {
            if ( p.x() == node.p.x() ) node.v = v;
            else node.left = putX( node.left,p,v );
        }
        return node;
    }

    public Value get(Point p) {
        if ( p == root.p ) {
            return root.v;
        }
        Node check = root;
        while ( p != check.p ) {
            if ( check.dir == Partition.Direction.LEFTRIGHT ) {
                if ( p.x() > check.p.x() ) {
                    check = check.right;
                }
                else check = check.left;
            }
            else if ( check.dir == Partition.Direction.DOWNUP ) {
                if ( p.y() > check.p.y() ) {
                    check = check.right;
                }
                else check = check.left;
            }
            else if ( check == null ) {
                break;
            }
            else {
                throw new RuntimeException("Node in KDTree is improperly defined!");
            }
        }
        if ( check == null ) return null;
        return check.v;
    }

    public boolean contains(Point p) {
        if(get(p) == null) return false;
        return true;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {

        Queue<Point> q = new Queue<Point>();
        inorder(root,q);
        return q;
    }

    private void inorder(Node node, Queue<Point> q){
        if(node == null) return;
        inorder(node.left, q);
        q.enqueue(node.p);
        inorder(node.right,q);
    }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());
        }



        return s;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return new Point(xMin,yMin); }
    public Point max() { return new Point(xMax,yMax); }

    // return the number of Points in kD-tree
    public int size() { return treeSize; }

    // return whether the kD-tree is empty
    public boolean isEmpty() {
        if( treeSize == 0 ) return true;
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {

    }

}

--[ 2019.12.01.15.09.33.233.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2019.12.01.15.09.33.233.1 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2019.12.01.15.09.33.233.2 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2019.12.01.15.09.33.233.3 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return get(nearest(p));
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {


        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());
        }



        return s;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2019.12.01.15.09.33.233.4 ]--
InitFile: /.cos265


--[ 2019.12.01.15.09.33.234.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2019.12.01.15.09.33.234.1 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2019.12.01.15.09.33.234.2 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2019.12.01.15.13.40.142.0 ]--
DisposeComponent
--[ 2020.07.10.21.33.24.077.0 ]--
NewLogger: P05_KDTrees
Version: 1.3
--[ 2020.07.10.21.33.24.095.0 ]--
InitTree:
/out/production/P05_KDTrees/.donotlog
/out/production/P05_KDTrees/algs4.jar
/out/production/P05_KDTrees/stdlib.jar
/out/production/P05_KDTrees/Mouse.class
/out/production/P05_KDTrees/Point.class
/out/production/P05_KDTrees/input1M.txt
/out/production/P05_KDTrees/Point$1.class
/out/production/P05_KDTrees/Point$2.class
/out/production/P05_KDTrees/Point$3.class
/out/production/P05_KDTrees/Point$4.class
/out/production/P05_KDTrees/input100K.txt
/out/production/P05_KDTrees/KeyPress.class
/out/production/P05_KDTrees/PSKDTree.class
/out/production/P05_KDTrees/burgerking.csv
/out/production/P05_KDTrees/Partition.class
/out/production/P05_KDTrees/PointDist.class
/out/production/P05_KDTrees/PSKDTree$1.class
/out/production/P05_KDTrees/Visualizer.class
/out/production/P05_KDTrees/PointSearch.class
/out/production/P05_KDTrees/PSBruteForce.class
/out/production/P05_KDTrees/PSKDTree$Node.class
/out/production/P05_KDTrees/FastFoodVisualizer.class
/out/production/P05_KDTrees/Partition$Direction.class
/out/production/P05_KDTrees/NearestNeighborVisualizer.class
/src/algs4.jar
/src/Mouse.java
/src/Point.java
/src/stdlib.jar
/src/KeyPress.java
/src/PSKDTree.java
/src/Partition.java
/src/PointDist.java
/src/Visualizer.java
/src/PointSearch.java
/src/PSBruteForce.java
/src/FastFoodVisualizer.java
/src/NearestNeighborVisualizer.java
/.log/history.log
/.idea/copyright/profiles_settings.xml
/.idea/libraries/algs4.xml
/.idea/libraries/stdlib.xml
/.idea/.name
/.idea/misc.xml
/.idea/modules.xml
/.idea/compiler.xml
/.idea/workspace.xml
/.idea/uiDesigner.xml
/tests/.donotlog
/tests/input1M.txt
/tests/input100K.txt
/tests/burgerking.csv
/.cos265
/readme.html
/P05_KDTrees.iml

--[ 2020.07.10.21.33.24.101.0 ]--
InitFile: /src/Point.java
import java.util.Comparator;

/**
 * Point is a simple tuple of doubles with some handy functions.  Point is useful for
 * storing and computing 2D points.
 */
public final class Point implements Comparable<Point> {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // generates a Point with location chosen uniformly at random in the unit square [0,1]^2
    public static Point uniform() {
        return new Point(StdRandom.uniform(), StdRandom.uniform());
    }

    // generates a Point with location chosen with gaussian distribution in unit square [0,1]^2
    // with mean of 0.5 and stddev of 0.12
    public static Point gaussian() {
        double x = -1, y = -1;
        // do not return an x,y that is outside the unit square
        while(x < 0 || y < 0 || x > 1 || y > 1) {
            x = StdRandom.gaussian(0.5, 0.12);
            y = StdRandom.gaussian(0.5, 0.12);
        }
        return new Point(x, y);
    }


    /**
     * the functions below can be used to find the min/max x/y which
     * can be used to find the bounding box of points
     */

    // returns a point with minimum component values
    public static Point min(Point p0, Point p1) {
        return new Point(Math.min(p0.x, p1.x), Math.min(p0.y, p1.y));
    }

    // returns a point with maximum component values
    public static Point max(Point p0, Point p1) {
        return new Point(Math.max(p0.x, p1.x), Math.max(p0.y, p1.y));
    }


    /**
     * use the following functions to compare Points in different ways.
     * Points are Comparable, so they know how to compareTo one another,
     * but the other functions return Comparator objects which can compare
     * Points in different ways.
     */

    // compares this to that, first by y component then by x
    public int compareTo(Point that) {
        if(this.y < that.y) return -1;
        if(this.y > that.y) return +1;
        if(this.x < that.x) return -1;
        if(this.x > that.x) return +1;
        return 0;
    }

    // do the components of this equal the components of that?
    public boolean equals(Object that) {
        if(this == that) return true;
        if(that == null) return false;
        if(that.getClass() != this.getClass()) return false;
        Point thatp = (Point)that;
        if(Double.compare(this.x, thatp.x) != 0) return false;
        if(Double.compare(this.y, thatp.y) != 0) return false;
        return true;
    }

    // returns a Comparator, comparing x first then y
    public static Comparator<Point> xyComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing y fist then x
    public static Comparator<Point> yxComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                if(o0.y < o1.y) return -1;
                if(o0.y > o1.y) return +1;
                if(o0.x < o1.x) return -1;
                if(o0.x > o1.x) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator, comparing the polar radius (dist from (0,0))
    public static Comparator<Point> polarRadiusComparator() {
        return new Comparator<Point>() {
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x*o0.x + o0.y*o0.y);
                double d1 = (o1.x*o1.x + o1.y*o1.y);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }

    // returns a Comparator for this, comparing dist between first given
    // point and this and dist between second given point and this
    public Comparator<Point> distanceToComparator() {
        return new Comparator<Point>() {
            private final double ox = x;
            private final double oy = y;
            @Override
            public int compare(Point o0, Point o1) {
                double d0 = (o0.x-ox)*(o0.x-ox) + (o0.y-oy)*(o0.y-oy);
                double d1 = (o1.x-ox)*(o1.x-ox) + (o1.y-oy)*(o1.y-oy);
                if(d0 < d1) return -1;
                if(d0 > d1) return +1;
                return 0;
            }
        };
    }


    /**
     * getters and setters
     */

    // getters of x and y
    public double x() { return x; }
    public double y() { return y; }

    // getter of either x or y depending on dir
    // dir = LEFTRIGHT => returns x
    // dir = DOWNUP    => returns y
    public double xy(Partition.Direction dir) {
        if(dir == Partition.Direction.LEFTRIGHT) return x;
        else return y;
    }


    /**
     * functions for computing distances
     */

    // computes distance^2 between this point and (x,y)
    public double distSquared(double x, double y) {
        return (this.x-x)*(this.x-x) + (this.y-y)*(this.y-y);
    }

    // computes distance^2 between this point and another (p)
    public double distSquared(Point p) {
        return distSquared(p.x, p.y);
    }

    // computes distance between this point and (x,y)
    public double dist(double x, double y) {
        return Math.sqrt(distSquared(x, y));
    }

    // computes distance between this point and another (p)
    public double dist(Point p) {
        return dist(p.x, p.y);
    }


    /**
     * misc functions
     */

    // returns a new point that has values added to components
    public Point add(double x, double y) {
        return new Point(this.x + x, this.y + y);
    }

    // returns whether point is within given min and max bounds
    public boolean isInBounds(double x0, double y0, double x1, double y1) {
        if(Double.compare(x,x0) <= 0) return false;
        if(Double.compare(y,y0) <= 0) return false;
        if(Double.compare(x1,x) <= 0) return false;
        if(Double.compare(y1,y) <= 0) return false;
        return true;
    }

    // produces a String representation of Point
    public String toString() {
        return "(" + x + "," + y + ")";
    }
}

--[ 2020.07.10.21.33.24.112.0 ]--
InitFile: /P05_KDTrees.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" type="java-resource" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="algs4" level="project" />
    <orderEntry type="library" name="stdlib" level="project" />
  </component>
</module>

--[ 2020.07.10.21.33.24.127.0 ]--
InitFile: /src/Mouse.java
/**
 * Mouse is a helper class for detecting mouse presses (not just whether the mouse is pressed)
 * and for transforming the cursor location from window-space to program-space
 */
public class Mouse {
    private boolean pressed;
    private final int xOffset, yOffset, width, height;

    public Mouse(int xOffset, int yOffset, int width, int height) {
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.width = width;
        this.height = height;
    }

    public boolean isPressed() {
        boolean p = StdDraw.mousePressed();
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }

    public Point getLocation() {
        double mouseX = (StdDraw.mouseX() - (float)xOffset) / (float)width;
        double mouseY = (StdDraw.mouseY() - (float)yOffset) / (float)height;
        return new Point(mouseX, mouseY);
    }
}

--[ 2020.07.10.21.33.24.135.0 ]--
InitFile: /src/KeyPress.java
/**
 * KeyPress is a helper class for detecting key presses (not just whether the key is pressed)
 */
public class KeyPress {
    private final int key;
    private boolean pressed;

    public KeyPress(int key) {
        this.key = key;
    }

    public boolean isDown() {
        return StdDraw.isKeyPressed(this.key);
    }

    public boolean isUp() {
        return !isDown();
    }

    public boolean isPressed() {
        boolean p = StdDraw.isKeyPressed(this.key);
        boolean v = !pressed && p;
        pressed = p;
        return v;
    }
}

--[ 2020.07.10.21.33.24.149.0 ]--
InitFile: /src/PSKDTree.java
import java.util.Iterator;

/**
 * PSKDTree is a Point collection that provides nearest neighbor searching using
 * 2d tree
 */
public class PSKDTree<Value> implements PointSearch<Value> {
    private Point min;
    PointSearch<Value> kdTree;
    private class Node {
        Point p;
        Value v;
        Node left, right;
        Partition.Direction dir;
    }
    double xMin;
    double xMax;
    double yMin;
    double yMax;
    int treeSize = 0;
    Node root;
    // constructor makes empty kD-tree
    public PSKDTree() { }

    // add the given Point to kD-tree
    public void put(Point p, Value v) {
        if ( treeSize == 0 ) {
            root = new Node();
            root.p = p;
            root.v = v;
            root.dir = Partition.Direction.LEFTRIGHT;
        }
        else {
            root = putX(root, p, v);
        }
        treeSize ++;
        if ( treeSize == 1 ) {
            xMin = p.x();
            xMax = p.x();
            yMin = p.y();
            yMax = p.y();
        }
        else {
            if ( p.x() <= xMin ) {
                xMin = p.x();
            }
            else if ( p.x() >= xMax ) {
                xMax = p.x();
            }
            if ( p.y() <= yMin ) {
                yMin = p.y();
            }
            else if ( p.y() >= yMax ) {
                yMax = p.y();
            }
        }
    }
    private Node putX( Node node, Point p, Value v) {
        if( node == null ) {
            Node alt = new Node();
            alt.p = p;
            alt.v = v;
            alt.dir = Partition.Direction.DOWNUP;
            return alt;
        }
        if ( p.x() < node.p.x() ) {
            node.left = putY( node.left,p,v );
        }
        else if ( p.x() > node.p.x() ) {
            node.right = putY( node.right,p,v );
        }
        else if ( p.x() == node.p.x() ) {
            if ( p.y() == node.p.y() ) node.v = v;
            else node.left = putY( node.left,p,v );
        }
        return node;
    }
    private Node putY( Node node, Point p, Value v) {
        if( node == null ) {
            Node alt = new Node();
            alt.p = p;
            alt.v = v;
            alt.dir = Partition.Direction.LEFTRIGHT;
            return alt;
        }
        if ( p.y() < node.p.y() ) {
            node.left = putX( node.left,p,v );
        }
        else if ( p.y() > node.p.y() ) {
            node.right = putX( node.right,p,v );
        }
        else if ( p.y() == node.p.y() ) {
            if ( p.x() == node.p.x() ) node.v = v;
            else node.left = putX( node.left,p,v );
        }
        return node;
    }

    public Value get(Point p) {
        if ( p == root.p ) {
            return root.v;
        }
        Node check = root;
        while ( p != check.p ) {
            if ( check.dir == Partition.Direction.LEFTRIGHT ) {
                if ( p.x() > check.p.x() ) {
                    check = check.right;
                }
                else check = check.left;
            }
            else if ( check.dir == Partition.Direction.DOWNUP ) {
                if ( p.y() > check.p.y() ) {
                    check = check.right;
                }
                else check = check.left;
            }
            else if ( check == null ) {
                break;
            }
            else {
                throw new RuntimeException("Node in KDTree is improperly defined!");
            }
        }
        if ( check == null ) return null;
        return check.v;
    }

    public boolean contains(Point p) {
        if(get(p) == null) return false;
        return true;
    }

    public Value getNearest(Point p) {
        return null;
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {

        Queue<Point> q = new Queue<Point>();
        inorder(root,q);
        return q;
    }

    private void inorder(Node node, Queue<Point> q){
        if(node == null) return;
        inorder(node.left, q);
        q.enqueue(node.p);
        inorder(node.right,q);
    }

    // return an iterable of all partitions that make up the kD-tree
    public Iterable<Partition> partitions() {
        return null;
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {
        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {
        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());
        }



        return s;
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if kD-tree is empty, return null.
    public Point min() { return new Point(xMin,yMin); }
    public Point max() { return new Point(xMax,yMax); }

    // return the number of Points in kD-tree
    public int size() { return treeSize; }

    // return whether the kD-tree is empty
    public boolean isEmpty() {
        if( treeSize == 0 ) return true;
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {

    }

}

--[ 2020.07.10.21.33.24.157.0 ]--
InitFile: /src/NearestNeighborVisualizer.java
import java.awt.event.KeyEvent;

/**
 * Visualizes nearest neighbors to mouse cursor and partitioning data
 */
public class NearestNeighborVisualizer {

    // number of dots to add at start
    private final static int nGaussian = 100;
    private final static int nUniform  = 100;

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // creates a new PointSearch data structure
    // note: you can swap between PSKDTree and PSBruteForce to debug your code
    private static PointSearch<Character> createNewPS() {
        return new PSKDTree<>();
    }

    public static void main(String[] args) {
        PointSearch<Character> ps = createNewPS();

        // add some random points
        for(int i = 0; i < nGaussian; i++) ps.put(Point.gaussian(), 'g');
        for(int i = 0; i < nUniform; i++) ps.put(Point.uniform(), 'u');

        // add points to match assignment write-up
        /*
        ps.put(new Point(0.8, 0.9), 'A');
        ps.put(new Point(0.5, 0.4), 'B');
        ps.put(new Point(0.2, 0.6), 'C');
        ps.put(new Point(0.3, 0.1), 'D');
        ps.put(new Point(0.9, 0.4), 'E');
        */

        StdDraw.show(0);

        int k = 10;
        boolean drawClosest = true;
        boolean drawPartitions = false;
        boolean drawBoundingBox = false;

        KeyPress keyP    = new KeyPress(KeyEvent.VK_P);
        KeyPress keyUp   = new KeyPress(KeyEvent.VK_UP);
        KeyPress keyDown = new KeyPress(KeyEvent.VK_DOWN);
        KeyPress keyC    = new KeyPress(KeyEvent.VK_C);
        KeyPress keyN    = new KeyPress(KeyEvent.VK_N);
        KeyPress keyB    = new KeyPress(KeyEvent.VK_B);
        Mouse    mouse   = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = mouse.getLocation();

            if(keyC.isPressed()) ps = createNewPS();
            if(keyUp.isPressed()) k++;
            if(keyDown.isPressed() && k > 0) k--;
            if(keyN.isPressed()) drawClosest = !drawClosest;
            if(keyP.isPressed()) drawPartitions = !drawPartitions;
            if(keyB.isPressed()) drawBoundingBox = !drawBoundingBox;
            if(mouse.isPressed()) ps.put(loc, 'm');

            Visualizer.clear();
            Visualizer.drawKDTree(ps, drawPartitions, drawBoundingBox);
            Visualizer.drawNeighbors(ps, loc, drawClosest, k);

            StdDraw.show(DELAY);
        }
    }
}

--[ 2020.07.10.21.33.24.165.0 ]--
InitFile: /src/PointSearch.java
/**
 * This interface defines the basic API for a 2D symbol table
 * where the keys are Points and the values are the generic
 * type Value
 */
public interface PointSearch<Value> {
    boolean isEmpty();
    int size();

    Point min();
    Point max();

    void put(Point p, Value v);
    Iterable<Point> points();
    boolean contains(Point p);
    Value get(Point p);
    Value getNearest(Point p);

    Point nearest(Point p);
    Iterable<Point> nearest(Point p, int k);

    Iterable<Partition> partitions();
}

--[ 2020.07.10.21.33.24.172.0 ]--
InitFile: /src/PointDist.java
/**
 * PointDist is a simple tuple of a Point and a dist.
 * This class is helpful for storing, passing, or returning the pair.
 */
public final class PointDist implements Comparable<PointDist> {
    private final Point p;
    private final double d;

    public PointDist(Point p, double d) {
        this.p = p;
        this.d = d;
    }

    public Point p() { return p; }

    public double d() { return d; }

    public int compareTo(PointDist that) {
        return Double.compare(this.d, that.d);
    }
}

--[ 2020.07.10.21.33.24.182.0 ]--
InitFile: /src/PSBruteForce.java
import java.util.Iterator;

/**
 * PSBruteForce is a Point collection that provides brute force
 * nearest neighbor searching using red-black tree.
 */
public class PSBruteForce<Value> implements PointSearch<Value> {
    RedBlackBST<Point, Value> rbTree;
    private Point min;
    private Point kmin[];
    private double minX;
    private double minY;
    private double maxX;
    private double maxY;

    // constructor makes empty collection
    public PSBruteForce() {
        rbTree = new RedBlackBST<>();
    }

    // add the given Point to KDTree
    public void put(Point p, Value v) {
        rbTree.put(p, v);

        if(size() == 1) {
            minX = p.x();
            minY = p.y();
            maxX = p.x();
            maxY = p.y();
        }
        else{
            if(p.y() <= minY){
                minY = p.y();
            }
            else if(p.y() >= maxY){
                maxY = p.y();
            }
            if(p.x() <= minX){
                minX = p.x();
            }
            else if(p.x() >= maxX){
                maxX = p.x();
            }
        }
    }

    public Value get(Point p) {
        return rbTree.get(p);
    }

    public boolean contains(Point p) {
        return rbTree.contains(p);
    }

    // return an iterable of all points in collection
    public Iterable<Point> points() {
        return rbTree.keys();
    }

    // return the Point that is closest to the given Point
    public Point nearest(Point p) {

        for(Point q : points()){
            min = q;
            break;
        }
        for(Point q : points()){
            if(q.dist(p) < min.dist(p)){
                min = q;
            }
        }
        return min;
    }

    // return the Value associated to the Point that is closest to the given Point
    public Value getNearest(Point p) {
        return get(nearest(p));
    }

    // return the min and max for all Points in collection.
    // The min-max pair will form a bounding box for all Points.
    // if KDTree is empty, return null.
    public Point min() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(minX, minY);
    }
    public Point max() {
        if(rbTree.isEmpty()){
            return null;

        }
        return new Point(maxX, maxY);
    }

    // return the k nearest Points to the given Point
    public Iterable<Point> nearest(Point p, int k) {


        MaxPQ<PointDist> points = new MaxPQ<>();
        for(Point q : points()){
            points.insert(new PointDist(q, q.dist(p)));
            if(points.size() > k){
                points.delMax();
            }
        }

        Stack<Point> s = new Stack<>();

        for (PointDist point: points) {
            s.push(point.p());
        }



        return s;
    }

    public Iterable<Partition> partitions() { return null; }

    // return the number of Points in KDTree
    public int size() { return rbTree.size(); }

    // return whether the KDTree is empty
    public boolean isEmpty() {
        if(rbTree.isEmpty()){
            return true;

        }
        return false;
    }

    // place your timing code or unit testing here
    public static void main(String[] args) {
    }
}

--[ 2020.07.10.21.33.24.195.0 ]--
InitFile: /.cos265


--[ 2020.07.10.21.33.24.206.0 ]--
InitFile: /src/Partition.java
/**
 * Partition is a simple class that stores two points and a direction,
 * where the two points make up a partition along the given direction.
 */
public final class Partition {
    // enumeration of all partition directions: Left-Right and Up-Down
    public enum Direction {
        LEFTRIGHT,
        DOWNUP
    }

    // returns the next direction in the enumeration
    public static Direction nextDirection(Direction dir) {
        if(dir == Direction.LEFTRIGHT) return Direction.DOWNUP;
        return Direction.LEFTRIGHT;
    }

    private final Point p0;
    private final Point p1;
    private final Direction dir;

    public Partition(Point p0, Point p1, Direction dir) {
        this.p0 = p0;
        this.p1 = p1;
        this.dir = dir;
    }

    public Partition(double x0, double y0, double x1, double y1, Direction dir) {
        this.p0 = new Point(x0, y0);
        this.p1 = new Point(x1, y1);
        this.dir = dir;
    }

    public Point p0() { return p0; }

    public Point p1() { return p1; }

    public Direction dir() { return dir; }
}

--[ 2020.07.10.21.33.24.217.0 ]--
InitFile: /src/FastFoodVisualizer.java
import java.awt.*;

/**
 * Loads and visualizes location data, and reports information on the closest
 * data point to mouse cursor
 */
public class FastFoodVisualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    private static final Color cText = new Color(64,64,64);

    private static void parseCSVLine(String line, String[] data) {
        boolean inQuote = false;
        int s = -1;
        int j = 0;
        for(int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if(c == ',' && !inQuote) {
                if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                    data[j] = line.substring(s+2,i-1);
                } else {
                    data[j] = line.substring(s + 1, i);
                }
                j++;
                s = i;
                continue;
            }
            if(c=='"') {
                inQuote = !inQuote;
            }
        }
        int i = line.length();
        if(s < i) {
            if(line.charAt(s+1) == '"' && line.charAt(i-1) == '"') {
                data[j] = line.substring(s+2,i-1);
            } else {
                data[j] = line.substring(s + 1, i);
            }
        }
    }

    private static String[][] readCSV(String filename, int m) {
        String[] lines = (new In(filename)).readAllLines();
        int n = lines.length;
        String[][] a = new String[n][m];
        for(int i = 0; i < n; i++) parseCSVLine(lines[i], a[i]);
        return a;
    }

    private static void insertCSV(String filename, PointSearch<String[]> ps) {
        String[][] data = readCSV(filename, 4);
        for(int i = 0; i < data.length; i++) {
            double longitude = Double.parseDouble(data[i][0]);
            double latitude = Double.parseDouble(data[i][1]);
            String[] loc = {data[i][2], data[i][3]};
            ps.put(new Point(longitude, latitude), loc);
        }
    }

    public static void main(String[] args) {
        PointSearch<String[]> psBurgerKings = new PSBruteForce<>();

        insertCSV("burgerking.csv", psBurgerKings);

        Visualizer.setScaling(psBurgerKings.min(), psBurgerKings.max());

        StdDraw.show(0);

        Mouse mouse = new Mouse(24, 36, 464, 464);

        while(true) {
            Point loc = Visualizer.xformInv(mouse.getLocation());

            Visualizer.clear();
            Visualizer.drawKDTree(psBurgerKings, false, false);
            Visualizer.drawNeighbors(psBurgerKings, loc, true, 0);

            StdDraw.setPenColor(cText);
            int i = 464;
            String[] value = psBurgerKings.getNearest(loc);
            if(value != null) {
                for (String l : value) {
                    StdDraw.text(256, i, l);
                    i -= 16;
                }
            }

            StdDraw.show(DELAY);
        }


    }
}

--[ 2020.07.10.21.33.24.228.0 ]--
InitFile: /src/Visualizer.java
import java.awt.*;

/**
 * Created by jdenning on 11/2/15.
 */
public class Visualizer {

    // delay in milliseconds (controls animation speed)
    private final static int DELAY = 10;

    // colors for vizualization
    private static final Color cDot = new Color(64,64,64);      // point (small box)
    private static final Color cKNN = new Color(200,200,255);   // k nearest neighbors
    private static final Color cNN  = new Color(64,64,255);     // nearest neighbor
    private static final Color cLR  = new Color(255,128,128);   // left-right partition
    private static final Color cUD  = new Color(128,255,128);   // up-down partition
    private static final Color cBox = new Color(192,192,192);   // bounding box

    private static double offsetX = 0.0;
    private static double offsetY = 0.0;
    private static double scale = 1.0;

    private static double dotSize = 1.0;

    public static void setScale(double scale) { Visualizer.scale = scale; }
    public static double getScale() { return Visualizer.scale; }
    public static void setOffsetX(double offsetX) { Visualizer.offsetX = offsetX; };
    public static double getOffsetX() { return Visualizer.offsetX; }
    public static void setOffsetY(double offsetY) { Visualizer.offsetY = offsetY; };
    public static double getOffsetY() { return Visualizer.offsetY; }
    public static void setScaling(double minX, double minY, double maxX, double maxY) {
        offsetX = minX; offsetY = minY;
        double d = Math.max(maxX - minX, maxY - minY);
        if(d == 0.0) scale = 0.0;
        else scale = 1.0 / d;
    }
    public static void setScaling(Point min, Point max) {
        if(min == null || max == null) return;
        setScaling(min.x(), min.y(), max.x(), max.y());
    }

    public static double getDotSize() { return dotSize; }
    public static void setDotSize(double dotSize) { Visualizer.dotSize = dotSize; }

    public static void clear() {
        StdDraw.clear();
        StdDraw.setXscale(0, 512);
        StdDraw.setYscale(0, 512);
    }
    public static void drawNeighbors(PointSearch ps, Point loc, boolean drawClosest, int k) {
        if(ps.isEmpty()) return;

        Iterable<Point> nearest = ps.nearest(loc, k);
        if(nearest != null) {
            StdDraw.setPenColor(cKNN);
            for (Point p : nearest) drawLine(loc, p);
        }

        if(drawClosest) {
            Point closest = ps.nearest(loc);
            if (closest != null) {
                StdDraw.setPenColor(cNN);
                StdDraw.setPenRadius(0.005);
                drawLine(loc, closest);
                StdDraw.setPenRadius();
            }
        }
    }
    public static void drawKDTree(PointSearch ps, boolean drawPartitions, boolean drawBoundingBox) {
        if(ps.isEmpty()) return;

        if(drawBoundingBox) {
            StdDraw.setPenColor(cBox);
            drawBox(ps.min(), ps.max());
        }

        if(drawPartitions) {
            Iterable<Partition> partitions = ps.partitions();
            if(partitions != null) {
                StdDraw.setPenRadius(0.005);
                for (Partition p : partitions) {
                    if (p.dir() == Partition.Direction.LEFTRIGHT) StdDraw.setPenColor(cLR);
                    else StdDraw.setPenColor(cUD);
                    drawLine(p.p0(), p.p1());
                }
                StdDraw.setPenRadius();
            }
        }

        Iterable<Point> points = ps.points();
        if(points != null) {
            StdDraw.setPenColor(cDot);
            setDotSize(Math.max(1.0, 5.0 / Math.pow(ps.size() + 1, 0.5)));
            for (Point p : points) drawDot(p);
        }
    }

    private static double xformX(double x) { return (x - offsetX) * scale; }
    private static double xformY(double y) { return (y - offsetY) * scale; }
    private static double xformInvX(double x) { return x / scale + offsetX; }
    private static double xformInvY(double y) { return y / scale + offsetY; }
    public static Point xform(Point p) {
        return new Point(xformX(p.x()), xformY(p.y()));
    }
    public static Point xformInv(Point p) {
        return new Point(xformInvX(p.x()), xformInvY(p.y()));
    }


    public static void drawDot(double x, double y) {
        StdDraw.square(xformX(x) * 464 + 24, xformY(y) * 464 + 36, dotSize);
    }
    public static void drawDot(Point p) {
        drawDot(p.x(), p.y());
    }

    public static void drawLine(double x0, double y0, double x1, double y1) {
        StdDraw.line(
                xformX(x0) * 464 + 24, xformY(y0) * 464 + 36,
                xformX(x1) * 464 + 24, xformY(y1) * 464 + 36
        );
    }
    public static void drawLine(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p1.y());
    }

    public static void drawBox(Point p0, Point p1) {
        drawLine(p0.x(), p0.y(), p1.x(), p0.y());
        drawLine(p1.x(), p0.y(), p1.x(), p1.y());
        drawLine(p1.x(), p1.y(), p0.x(), p1.y());
        drawLine(p0.x(), p1.y(), p0.x(), p0.y());
    }

}

--[ 2020.07.10.21.33.32.163.0 ]--
UpdateTree (AD): 1 0
+ /.idea/vcs.xml

--[ 2020.07.10.21.33.35.859.0 ]--
CompilationStatus (AEW): 0 0 0
--[ 2020.07.10.21.34.39.537.0 ]--
DisposeComponent
